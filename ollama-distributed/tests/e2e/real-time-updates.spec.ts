import { test, expect, Page } from '@playwright/test'\n\n/**\n * Real-time Updates E2E Tests\n * \n * Tests WebSocket functionality and real-time data updates including:\n * - WebSocket connection management\n * - Real-time metric updates\n * - Live notifications\n * - Connection resilience\n * - Error handling\n * - Performance under load\n */\n\ntest.describe('Real-time Updates', () => {\n  let wsMessages: any[] = []\n  let wsConnection: any = null\n\n  test.beforeEach(async ({ page, context }) => {\n    // Reset WebSocket message tracking\n    wsMessages = []\n    \n    // Mock authentication\n    await page.route('**/api/auth/me', route => {\n      route.fulfill({\n        status: 200,\n        body: JSON.stringify({\n          user: { id: 1, email: 'admin@example.com', role: 'admin' },\n          token: 'mock-jwt-token'\n        })\n      })\n    })\n\n    // Intercept WebSocket connections for testing\n    await page.addInitScript(() => {\n      const originalWebSocket = window.WebSocket\n      \n      class MockWebSocket extends EventTarget {\n        static CONNECTING = 0\n        static OPEN = 1\n        static CLOSING = 2\n        static CLOSED = 3\n        \n        readyState = MockWebSocket.CONNECTING\n        url: string\n        protocol: string\n        \n        constructor(url: string, protocols?: string | string[]) {\n          super()\n          this.url = url\n          this.protocol = Array.isArray(protocols) ? protocols[0] || '' : protocols || ''\n          \n          // Simulate connection opening\n          setTimeout(() => {\n            this.readyState = MockWebSocket.OPEN\n            this.dispatchEvent(new Event('open'))\n            ;(window as any).__wsConnection = this\n          }, 100)\n        }\n        \n        send(data: string | ArrayBuffer | Blob) {\n          ;(window as any).__wsMessages = (window as any).__wsMessages || []\n          ;(window as any).__wsMessages.push({ type: 'sent', data })\n        }\n        \n        close(code?: number, reason?: string) {\n          this.readyState = MockWebSocket.CLOSING\n          setTimeout(() => {\n            this.readyState = MockWebSocket.CLOSED\n            this.dispatchEvent(new CloseEvent('close', { code, reason }))\n          }, 50)\n        }\n        \n        // Simulate receiving messages\n        __simulateMessage(data: any) {\n          const event = new MessageEvent('message', { data: JSON.stringify(data) })\n          this.dispatchEvent(event)\n          ;(window as any).__wsMessages = (window as any).__wsMessages || []\n          ;(window as any).__wsMessages.push({ type: 'received', data })\n        }\n        \n        // Simulate connection error\n        __simulateError(error?: any) {\n          this.dispatchEvent(new Event('error'))\n        }\n      }\n      \n      ;(window as any).WebSocket = MockWebSocket\n      ;(window as any).__wsMessages = []\n    })\n  })\n\n  test.describe('WebSocket Connection', () => {\n    test('establishes WebSocket connection on dashboard load', async ({ page }) => {\n      await page.goto('/v2')\n      \n      // Wait for WebSocket connection\n      await page.waitForFunction(() => (window as any).__wsConnection)\n      \n      // Verify connection is established\n      const wsConnection = await page.evaluate(() => (window as any).__wsConnection)\n      expect(wsConnection).toBeTruthy()\n      \n      // Verify connection state\n      const readyState = await page.evaluate(() => (window as any).__wsConnection?.readyState)\n      expect(readyState).toBe(1) // WebSocket.OPEN\n    })\n\n    test('handles WebSocket connection failure gracefully', async ({ page }) => {\n      // Mock WebSocket that fails to connect\n      await page.addInitScript(() => {\n        class FailingWebSocket extends EventTarget {\n          constructor(url: string) {\n            super()\n            setTimeout(() => {\n              this.dispatchEvent(new Event('error'))\n            }, 100)\n          }\n          send() {}\n          close() {}\n        }\n        ;(window as any).WebSocket = FailingWebSocket\n      })\n      \n      await page.goto('/v2')\n      \n      // Should show error state or fallback gracefully\n      await expect(page.locator('text=Connection failed')).toBeVisible()\n      \n      // Dashboard should still be functional without real-time updates\n      await expect(page.locator('text=Dashboard')).toBeVisible()\n    })\n\n    test('automatically reconnects after connection loss', async ({ page }) => {\n      await page.goto('/v2')\n      \n      // Wait for initial connection\n      await page.waitForFunction(() => (window as any).__wsConnection)\n      \n      // Simulate connection loss\n      await page.evaluate(() => {\n        const ws = (window as any).__wsConnection\n        if (ws) {\n          ws.readyState = 3 // CLOSED\n          ws.dispatchEvent(new CloseEvent('close', { code: 1006, reason: 'Connection lost' }))\n        }\n      })\n      \n      // Should show reconnecting indicator\n      await expect(page.locator('text=Reconnecting')).toBeVisible()\n      \n      // Should attempt to reconnect\n      await page.waitForTimeout(2000)\n      \n      // Verify reconnection\n      const isReconnected = await page.evaluate(() => {\n        return (window as any).__wsConnection?.readyState === 1\n      })\n      expect(isReconnected).toBe(true)\n    })\n\n    test('displays connection status indicator', async ({ page }) => {\n      await page.goto('/v2')\n      \n      // Should show connected status\n      await expect(page.locator('[data-ws-status=\"connected\"]')).toBeVisible()\n      \n      // Simulate disconnection\n      await page.evaluate(() => {\n        const ws = (window as any).__wsConnection\n        if (ws) {\n          ws.close()\n        }\n      })\n      \n      // Should show disconnected status\n      await expect(page.locator('[data-ws-status=\"disconnected\"]')).toBeVisible()\n    })\n  })\n\n  test.describe('Real-time Metrics', () => {\n    test('receives and displays real-time cluster metrics', async ({ page }) => {\n      await page.goto('/v2')\n      \n      // Wait for WebSocket connection\n      await page.waitForFunction(() => (window as any).__wsConnection)\n      \n      // Simulate receiving metrics update\n      await page.evaluate(() => {\n        const ws = (window as any).__wsConnection\n        if (ws) {\n          ws.__simulateMessage({\n            type: 'metrics_update',\n            data: {\n              clusterUtilization: 75,\n              activeNodes: 3,\n              totalRequests: 1250,\n              averageResponseTime: 145\n            },\n            timestamp: new Date().toISOString()\n          })\n        }\n      })\n      \n      // Verify metrics are updated in UI\n      await expect(page.locator('[data-metric=\"cluster-utilization\"]')).toContainText('75%')\n      await expect(page.locator('[data-metric=\"active-nodes\"]')).toContainText('3')\n      await expect(page.locator('[data-metric=\"total-requests\"]')).toContainText('1250')\n    })\n\n    test('handles rapid metric updates without performance issues', async ({ page }) => {\n      await page.goto('/v2')\n      \n      // Wait for WebSocket connection\n      await page.waitForFunction(() => (window as any).__wsConnection)\n      \n      const startTime = Date.now()\n      \n      // Simulate rapid updates (10 per second for 5 seconds)\n      for (let i = 0; i < 50; i++) {\n        await page.evaluate((index) => {\n          const ws = (window as any).__wsConnection\n          if (ws) {\n            ws.__simulateMessage({\n              type: 'metrics_update',\n              data: {\n                clusterUtilization: 50 + (index % 40),\n                timestamp: new Date().toISOString()\n              }\n            })\n          }\n        }, i)\n        \n        if (i % 10 === 0) {\n          await page.waitForTimeout(50) // Small delay to simulate real timing\n        }\n      }\n      \n      const endTime = Date.now()\n      const updateTime = endTime - startTime\n      \n      // Should handle updates efficiently (under 2 seconds)\n      expect(updateTime).toBeLessThan(2000)\n      \n      // UI should still be responsive\n      await expect(page.locator('[data-metric=\"cluster-utilization\"]')).toBeVisible()\n    })\n\n    test('validates metric data before updating UI', async ({ page }) => {\n      await page.goto('/v2')\n      \n      // Wait for WebSocket connection\n      await page.waitForFunction(() => (window as any).__wsConnection)\n      \n      // Get initial value\n      const initialValue = await page.locator('[data-metric=\"cluster-utilization\"]').textContent()\n      \n      // Send invalid metric data\n      await page.evaluate(() => {\n        const ws = (window as any).__wsConnection\n        if (ws) {\n          ws.__simulateMessage({\n            type: 'metrics_update',\n            data: {\n              clusterUtilization: 'invalid_value',\n              invalidField: 'should_be_ignored'\n            }\n          })\n        }\n      })\n      \n      // UI should not update with invalid data\n      const currentValue = await page.locator('[data-metric=\"cluster-utilization\"]').textContent()\n      expect(currentValue).toBe(initialValue)\n      \n      // Send valid data\n      await page.evaluate(() => {\n        const ws = (window as any).__wsConnection\n        if (ws) {\n          ws.__simulateMessage({\n            type: 'metrics_update',\n            data: {\n              clusterUtilization: 85\n            }\n          })\n        }\n      })\n      \n      // Should update with valid data\n      await expect(page.locator('[data-metric=\"cluster-utilization\"]')).toContainText('85')\n    })\n  })\n\n  test.describe('Live Notifications', () => {\n    test('displays real-time notifications', async ({ page }) => {\n      await page.goto('/v2')\n      \n      // Wait for WebSocket connection\n      await page.waitForFunction(() => (window as any).__wsConnection)\n      \n      // Simulate notification\n      await page.evaluate(() => {\n        const ws = (window as any).__wsConnection\n        if (ws) {\n          ws.__simulateMessage({\n            type: 'notification',\n            data: {\n              id: 'notif-1',\n              level: 'warning',\n              title: 'High Memory Usage',\n              message: 'Node-2 memory usage is at 85%',\n              timestamp: new Date().toISOString()\n            }\n          })\n        }\n      })\n      \n      // Verify notification appears\n      await expect(page.locator('[data-notification=\"notif-1\"]')).toBeVisible()\n      await expect(page.locator('text=High Memory Usage')).toBeVisible()\n      await expect(page.locator('text=Node-2 memory usage is at 85%')).toBeVisible()\n    })\n\n    test('handles different notification levels', async ({ page }) => {\n      await page.goto('/v2')\n      \n      // Wait for WebSocket connection\n      await page.waitForFunction(() => (window as any).__wsConnection)\n      \n      // Send different notification levels\n      const notifications = [\n        { level: 'info', title: 'Info Notification', color: 'blue' },\n        { level: 'warning', title: 'Warning Notification', color: 'yellow' },\n        { level: 'error', title: 'Error Notification', color: 'red' },\n        { level: 'success', title: 'Success Notification', color: 'green' }\n      ]\n      \n      for (const [index, notif] of notifications.entries()) {\n        await page.evaluate((notification, idx) => {\n          const ws = (window as any).__wsConnection\n          if (ws) {\n            ws.__simulateMessage({\n              type: 'notification',\n              data: {\n                id: `notif-${idx}`,\n                level: notification.level,\n                title: notification.title,\n                timestamp: new Date().toISOString()\n              }\n            })\n          }\n        }, notif, index)\n        \n        // Verify notification with correct styling\n        await expect(page.locator(`[data-notification=\"notif-${index}\"]`)).toBeVisible()\n        await expect(page.locator(`[data-level=\"${notif.level}\"]`)).toBeVisible()\n      }\n    })\n\n    test('auto-dismisses notifications after timeout', async ({ page }) => {\n      await page.goto('/v2')\n      \n      // Wait for WebSocket connection\n      await page.waitForFunction(() => (window as any).__wsConnection)\n      \n      // Send notification with auto-dismiss\n      await page.evaluate(() => {\n        const ws = (window as any).__wsConnection\n        if (ws) {\n          ws.__simulateMessage({\n            type: 'notification',\n            data: {\n              id: 'auto-dismiss',\n              level: 'info',\n              title: 'Auto Dismiss',\n              autoDismiss: 2000, // 2 seconds\n              timestamp: new Date().toISOString()\n            }\n          })\n        }\n      })\n      \n      // Verify notification appears\n      await expect(page.locator('[data-notification=\"auto-dismiss\"]')).toBeVisible()\n      \n      // Wait for auto-dismiss\n      await page.waitForTimeout(2500)\n      \n      // Verify notification is dismissed\n      await expect(page.locator('[data-notification=\"auto-dismiss\"]')).not.toBeVisible()\n    })\n\n    test('allows manual dismissal of notifications', async ({ page }) => {\n      await page.goto('/v2')\n      \n      // Wait for WebSocket connection\n      await page.waitForFunction(() => (window as any).__wsConnection)\n      \n      // Send persistent notification\n      await page.evaluate(() => {\n        const ws = (window as any).__wsConnection\n        if (ws) {\n          ws.__simulateMessage({\n            type: 'notification',\n            data: {\n              id: 'manual-dismiss',\n              level: 'warning',\n              title: 'Manual Dismiss',\n              persistent: true,\n              timestamp: new Date().toISOString()\n            }\n          })\n        }\n      })\n      \n      // Verify notification appears\n      await expect(page.locator('[data-notification=\"manual-dismiss\"]')).toBeVisible()\n      \n      // Click dismiss button\n      await page.click('[data-notification=\"manual-dismiss\"] button[data-action=\"dismiss\"]')\n      \n      // Verify notification is dismissed\n      await expect(page.locator('[data-notification=\"manual-dismiss\"]')).not.toBeVisible()\n    })\n  })\n\n  test.describe('Node Status Updates', () => {\n    test('updates node status in real-time', async ({ page }) => {\n      await page.goto('/v2/admin')\n      \n      // Wait for WebSocket connection\n      await page.waitForFunction(() => (window as any).__wsConnection)\n      \n      // Simulate node status change\n      await page.evaluate(() => {\n        const ws = (window as any).__wsConnection\n        if (ws) {\n          ws.__simulateMessage({\n            type: 'node_status_update',\n            data: {\n              nodeId: 'node-1',\n              status: 'warning',\n              cpu: 85,\n              memory: 90,\n              message: 'High resource usage detected',\n              timestamp: new Date().toISOString()\n            }\n          })\n        }\n      })\n      \n      // Verify node status is updated\n      await expect(page.locator('[data-node=\"node-1\"][data-status=\"warning\"]')).toBeVisible()\n      await expect(page.locator('[data-node=\"node-1\"] text=85%')).toBeVisible()\n    })\n\n    test('handles node connection/disconnection events', async ({ page }) => {\n      await page.goto('/v2/admin')\n      \n      // Wait for WebSocket connection\n      await page.waitForFunction(() => (window as any).__wsConnection)\n      \n      // Simulate node disconnection\n      await page.evaluate(() => {\n        const ws = (window as any).__wsConnection\n        if (ws) {\n          ws.__simulateMessage({\n            type: 'node_event',\n            data: {\n              nodeId: 'node-2',\n              event: 'disconnected',\n              timestamp: new Date().toISOString()\n            }\n          })\n        }\n      })\n      \n      // Verify node shows as offline\n      await expect(page.locator('[data-node=\"node-2\"][data-status=\"offline\"]')).toBeVisible()\n      \n      // Simulate node reconnection\n      await page.evaluate(() => {\n        const ws = (window as any).__wsConnection\n        if (ws) {\n          ws.__simulateMessage({\n            type: 'node_event',\n            data: {\n              nodeId: 'node-2',\n              event: 'connected',\n              timestamp: new Date().toISOString()\n            }\n          })\n        }\n      })\n      \n      // Verify node shows as online\n      await expect(page.locator('[data-node=\"node-2\"][data-status=\"healthy\"]')).toBeVisible()\n    })\n  })\n\n  test.describe('Model Deployment Updates', () => {\n    test('tracks model deployment progress in real-time', async ({ page }) => {\n      await page.goto('/v2/admin/models')\n      \n      // Wait for WebSocket connection\n      await page.waitForFunction(() => (window as any).__wsConnection)\n      \n      // Simulate deployment progress updates\n      const progressSteps = [25, 50, 75, 100]\n      \n      for (const progress of progressSteps) {\n        await page.evaluate((prog) => {\n          const ws = (window as any).__wsConnection\n          if (ws) {\n            ws.__simulateMessage({\n              type: 'deployment_progress',\n              data: {\n                deploymentId: 'deploy-123',\n                modelName: 'llama2:7b',\n                nodeId: 'node-3',\n                progress: prog,\n                status: prog === 100 ? 'completed' : 'in_progress',\n                timestamp: new Date().toISOString()\n              }\n            })\n          }\n        }, progress)\n        \n        // Verify progress is updated\n        await expect(page.locator(`[data-deployment=\"deploy-123\"] [data-progress=\"${progress}\"]`)).toBeVisible()\n        \n        if (progress < 100) {\n          await expect(page.locator('[data-deployment=\"deploy-123\"][data-status=\"in_progress\"]')).toBeVisible()\n        }\n      }\n      \n      // Verify completion\n      await expect(page.locator('[data-deployment=\"deploy-123\"][data-status=\"completed\"]')).toBeVisible()\n    })\n\n    test('handles deployment failures with error details', async ({ page }) => {\n      await page.goto('/v2/admin/models')\n      \n      // Wait for WebSocket connection\n      await page.waitForFunction(() => (window as any).__wsConnection)\n      \n      // Simulate deployment failure\n      await page.evaluate(() => {\n        const ws = (window as any).__wsConnection\n        if (ws) {\n          ws.__simulateMessage({\n            type: 'deployment_progress',\n            data: {\n              deploymentId: 'deploy-456',\n              modelName: 'codellama:13b',\n              nodeId: 'node-2',\n              progress: 45,\n              status: 'failed',\n              error: 'Insufficient disk space',\n              timestamp: new Date().toISOString()\n            }\n          })\n        }\n      })\n      \n      // Verify failure status and error message\n      await expect(page.locator('[data-deployment=\"deploy-456\"][data-status=\"failed\"]')).toBeVisible()\n      await expect(page.locator('text=Insufficient disk space')).toBeVisible()\n    })\n  })\n\n  test.describe('Performance and Resilience', () => {\n    test('handles high-frequency updates efficiently', async ({ page }) => {\n      await page.goto('/v2')\n      \n      // Wait for WebSocket connection\n      await page.waitForFunction(() => (window as any).__wsConnection)\n      \n      const startTime = Date.now()\n      \n      // Send 100 rapid updates\n      for (let i = 0; i < 100; i++) {\n        await page.evaluate((index) => {\n          const ws = (window as any).__wsConnection\n          if (ws) {\n            ws.__simulateMessage({\n              type: 'metrics_update',\n              data: {\n                clusterUtilization: Math.floor(Math.random() * 100),\n                timestamp: new Date().toISOString()\n              }\n            })\n          }\n        }, i)\n      }\n      \n      // Wait for all updates to process\n      await page.waitForTimeout(1000)\n      \n      const endTime = Date.now()\n      const processingTime = endTime - startTime\n      \n      // Should handle all updates within reasonable time\n      expect(processingTime).toBeLessThan(3000)\n      \n      // UI should remain responsive\n      await expect(page.locator('[data-metric=\"cluster-utilization\"]')).toBeVisible()\n    })\n\n    test('maintains data consistency during rapid updates', async ({ page }) => {\n      await page.goto('/v2')\n      \n      // Wait for WebSocket connection\n      await page.waitForFunction(() => (window as any).__wsConnection)\n      \n      // Send conflicting updates\n      await page.evaluate(() => {\n        const ws = (window as any).__wsConnection\n        if (ws) {\n          // Older timestamp\n          ws.__simulateMessage({\n            type: 'metrics_update',\n            data: {\n              clusterUtilization: 30,\n              timestamp: new Date(Date.now() - 5000).toISOString()\n            }\n          })\n          \n          // Newer timestamp\n          ws.__simulateMessage({\n            type: 'metrics_update',\n            data: {\n              clusterUtilization: 70,\n              timestamp: new Date().toISOString()\n            }\n          })\n        }\n      })\n      \n      // Should show the newer value\n      await expect(page.locator('[data-metric=\"cluster-utilization\"]')).toContainText('70')\n    })\n\n    test('recovers gracefully from message parsing errors', async ({ page }) => {\n      await page.goto('/v2')\n      \n      // Wait for WebSocket connection\n      await page.waitForFunction(() => (window as any).__wsConnection)\n      \n      // Send malformed message\n      await page.evaluate(() => {\n        const ws = (window as any).__wsConnection\n        if (ws) {\n          // Simulate receiving invalid JSON\n          const event = new MessageEvent('message', { data: 'invalid json{' })\n          ws.dispatchEvent(event)\n        }\n      })\n      \n      // Application should continue working\n      await expect(page.locator('text=Dashboard')).toBeVisible()\n      \n      // Should still process valid messages\n      await page.evaluate(() => {\n        const ws = (window as any).__wsConnection\n        if (ws) {\n          ws.__simulateMessage({\n            type: 'metrics_update',\n            data: {\n              clusterUtilization: 55\n            }\n          })\n        }\n      })\n      \n      await expect(page.locator('[data-metric=\"cluster-utilization\"]')).toContainText('55')\n    })\n  })\n})"