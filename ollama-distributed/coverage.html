
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>auth: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/ollama/ollama-distributed/internal/auth/auth.go (70.5%)</option>
				
				<option value="file1">github.com/ollama/ollama-distributed/internal/auth/integration.go (0.0%)</option>
				
				<option value="file2">github.com/ollama/ollama-distributed/internal/auth/jwt.go (36.7%)</option>
				
				<option value="file3">github.com/ollama/ollama-distributed/internal/auth/middleware.go (0.0%)</option>
				
				<option value="file4">github.com/ollama/ollama-distributed/internal/auth/routes.go (0.0%)</option>
				
				<option value="file5">github.com/ollama/ollama-distributed/internal/auth/server_example.go (0.0%)</option>
				
				<option value="file6">github.com/ollama/ollama-distributed/internal/auth/types.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package auth

import (
        "crypto/rand"
        "crypto/sha256"
        "crypto/subtle"
        "encoding/hex"
        "fmt"
        "sync"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "github.com/ollama/ollama-distributed/internal/config"
        "golang.org/x/crypto/bcrypt"
)

// Manager handles all authentication operations
type Manager struct {
        config *config.AuthConfig
        
        // JWT signing key
        signingKey []byte
        
        // In-memory stores (in production, these would be backed by persistent storage)
        users          map[string]*User
        apiKeys        map[string]*APIKey
        sessions       map[string]*Session
        blacklistCache map[string]time.Time
        
        // Password hasher
        bcryptCost int
        
        // Mutex for thread safety
        mu sync.RWMutex
        
        // Background cleanup
        stopCleanup chan struct{}
}

// NewManager creates a new authentication manager
func NewManager(cfg *config.AuthConfig) (*Manager, error) <span class="cov6" title="7">{
        if cfg == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("auth config is required")
        }</span>
        
        // Generate or use provided signing key
        <span class="cov6" title="7">signingKey := []byte(cfg.SecretKey)
        if len(signingKey) == 0 </span><span class="cov0" title="0">{
                // Generate a random signing key
                signingKey = make([]byte, 32)
                if _, err := rand.Read(signingKey); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to generate signing key: %w", err)
                }</span>
        }
        
        <span class="cov6" title="7">manager := &amp;Manager{
                config:         cfg,
                signingKey:     signingKey,
                users:          make(map[string]*User),
                apiKeys:        make(map[string]*APIKey),
                sessions:       make(map[string]*Session),
                blacklistCache: make(map[string]time.Time),
                bcryptCost:     bcrypt.DefaultCost,
                stopCleanup:    make(chan struct{}),
        }
        
        // Create default admin user if none exists
        if err := manager.createDefaultAdmin(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create default admin: %w", err)
        }</span>
        
        // Start background cleanup routines
        <span class="cov6" title="7">go manager.cleanupExpiredSessions()
        go manager.cleanupBlacklist()
        
        return manager, nil</span>
}

// Close gracefully shuts down the auth manager
func (m *Manager) Close() <span class="cov6" title="7">{
        close(m.stopCleanup)
}</span>

// createDefaultAdmin creates a default admin user if no users exist
func (m *Manager) createDefaultAdmin() error <span class="cov6" title="7">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        // Check if any users exist
        if len(m.users) &gt; 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        // Create default admin user
        <span class="cov6" title="7">hashedPassword, err := bcrypt.GenerateFromPassword([]byte("admin123"), m.bcryptCost)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to hash default password: %w", err)
        }</span>
        
        <span class="cov6" title="7">adminUser := &amp;User{
                ID:          generateID(),
                Username:    "admin",
                Email:       "admin@localhost",
                Role:        RoleAdmin,
                Permissions: DefaultRolePermissions[RoleAdmin],
                Metadata: map[string]string{
                        "password_hash": string(hashedPassword),
                        "created_by":    "system",
                },
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
                Active:    true,
        }
        
        m.users[adminUser.ID] = adminUser
        
        fmt.Printf("Created default admin user (username: admin, password: admin123)\n")
        fmt.Printf("WARNING: Please change the default password immediately!\n")
        
        return nil</span>
}

// Authenticate validates credentials and returns an auth context
func (m *Manager) Authenticate(username, password string, metadata map[string]string) (*AuthContext, error) <span class="cov5" title="5">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        
        // Find user by username
        var user *User
        for _, u := range m.users </span><span class="cov6" title="6">{
                if u.Username == username &amp;&amp; u.Active </span><span class="cov5" title="5">{
                        user = u
                        break</span>
                }
        }
        
        <span class="cov5" title="5">if user == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidCredentials
        }</span>
        
        // Verify password
        <span class="cov5" title="5">passwordHash := user.Metadata["password_hash"]
        if err := bcrypt.CompareHashAndPassword([]byte(passwordHash), []byte(password)); err != nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidCredentials
        }</span>
        
        // Update last login
        <span class="cov5" title="5">now := time.Now()
        user.LastLoginAt = &amp;now
        user.UpdatedAt = now
        
        // Create session
        session := &amp;Session{
                ID:        generateID(),
                UserID:    user.ID,
                IPAddress: metadata["ip_address"],
                UserAgent: metadata["user_agent"],
                Metadata:  metadata,
                CreatedAt: now,
                ExpiresAt: now.Add(m.config.TokenExpiry),
                Active:    true,
        }
        
        m.sessions[session.ID] = session
        
        // Generate JWT token
        claims := &amp;Claims{
                UserID:      user.ID,
                Username:    user.Username,
                Email:       user.Email,
                Role:        user.Role,
                Permissions: user.Permissions,
                SessionID:   session.ID,
                Metadata:    user.Metadata,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(session.ExpiresAt),
                        IssuedAt:  jwt.NewNumericDate(now),
                        NotBefore: jwt.NewNumericDate(now),
                        Issuer:    m.config.Issuer,
                        Subject:   user.ID,
                        ID:        generateID(),
                        Audience:  []string{m.config.Audience},
                },
        }
        
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        tokenString, err := token.SignedString(m.signingKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to sign token: %w", err)
        }</span>
        
        <span class="cov5" title="5">session.TokenID = claims.ID
        
        return &amp;AuthContext{
                User:        user,
                Session:     session,
                Claims:      claims,
                TokenString: tokenString,
                Method:      AuthMethodJWT,
        }, nil</span>
}

// ValidateToken validates a JWT token and returns the auth context
func (m *Manager) ValidateToken(tokenString string) (*AuthContext, error) <span class="cov4" title="3">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov4" title="3">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov4" title="3">return m.signingKey, nil</span>
        })
        
        <span class="cov4" title="3">if err != nil </span><span class="cov0" title="0">{
                return nil, ErrTokenInvalid
        }</span>
        
        <span class="cov4" title="3">claims, ok := token.Claims.(*Claims)
        if !ok || !token.Valid </span><span class="cov0" title="0">{
                return nil, ErrTokenInvalid
        }</span>
        
        // Check if token is blacklisted
        <span class="cov4" title="3">if m.isTokenBlacklisted(claims.ID) </span><span class="cov1" title="1">{
                return nil, ErrTokenBlacklisted
        }</span>
        
        <span class="cov2" title="2">m.mu.RLock()
        defer m.mu.RUnlock()
        
        // Get user
        user, exists := m.users[claims.UserID]
        if !exists || !user.Active </span><span class="cov0" title="0">{
                return nil, ErrUserNotFound
        }</span>
        
        // Get session if available
        <span class="cov2" title="2">var session *Session
        if claims.SessionID != "" </span><span class="cov2" title="2">{
                if s, exists := m.sessions[claims.SessionID]; exists &amp;&amp; s.Active </span><span class="cov2" title="2">{
                        if time.Now().After(s.ExpiresAt) </span><span class="cov0" title="0">{
                                return nil, ErrSessionExpired
                        }</span>
                        <span class="cov2" title="2">session = s</span>
                }
        }
        
        <span class="cov2" title="2">return &amp;AuthContext{
                User:        user,
                Session:     session,
                Claims:      claims,
                TokenString: tokenString,
                Method:      AuthMethodJWT,
        }, nil</span>
}

// ValidateAPIKey validates an API key and returns the auth context
func (m *Manager) ValidateAPIKey(key string) (*AuthContext, error) <span class="cov1" title="1">{
        keyHash := hashAPIKey(key)
        
        m.mu.RLock()
        defer m.mu.RUnlock()
        
        // Find API key
        var apiKey *APIKey
        for _, ak := range m.apiKeys </span><span class="cov1" title="1">{
                if subtle.ConstantTimeCompare([]byte(ak.Key), []byte(keyHash)) == 1 &amp;&amp; ak.Active </span><span class="cov1" title="1">{
                        apiKey = ak
                        break</span>
                }
        }
        
        <span class="cov1" title="1">if apiKey == nil </span><span class="cov0" title="0">{
                return nil, ErrAPIKeyNotFound
        }</span>
        
        // Check expiration
        <span class="cov1" title="1">if apiKey.ExpiresAt != nil &amp;&amp; time.Now().After(*apiKey.ExpiresAt) </span><span class="cov0" title="0">{
                return nil, ErrAPIKeyExpired
        }</span>
        
        // Get user
        <span class="cov1" title="1">user, exists := m.users[apiKey.UserID]
        if !exists || !user.Active </span><span class="cov0" title="0">{
                return nil, ErrUserNotFound
        }</span>
        
        // Update last used
        <span class="cov1" title="1">now := time.Now()
        apiKey.LastUsedAt = &amp;now
        
        return &amp;AuthContext{
                User:   user,
                APIKey: apiKey,
                Method: AuthMethodAPIKey,
        }, nil</span>
}

// CreateUser creates a new user
func (m *Manager) CreateUser(req *CreateUserRequest) (*User, error) <span class="cov4" title="3">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        // Check if username already exists
        for _, u := range m.users </span><span class="cov4" title="3">{
                if u.Username == req.Username </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("username already exists")
                }</span>
        }
        
        // Hash password
        <span class="cov4" title="3">hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), m.bcryptCost)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to hash password: %w", err)
        }</span>
        
        // Set permissions based on role if not provided
        <span class="cov4" title="3">permissions := req.Permissions
        if len(permissions) == 0 </span><span class="cov2" title="2">{
                if rolePerms, exists := DefaultRolePermissions[req.Role]; exists </span><span class="cov2" title="2">{
                        permissions = rolePerms
                }</span>
        }
        
        // Create user
        <span class="cov4" title="3">user := &amp;User{
                ID:          generateID(),
                Username:    req.Username,
                Email:       req.Email,
                Role:        req.Role,
                Permissions: permissions,
                Metadata: map[string]string{
                        "password_hash": string(hashedPassword),
                },
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
                Active:    true,
        }
        
        // Add custom metadata
        for k, v := range req.Metadata </span><span class="cov0" title="0">{
                user.Metadata[k] = v
        }</span>
        
        <span class="cov4" title="3">m.users[user.ID] = user
        
        return user, nil</span>
}

// CreateAPIKey creates a new API key for a user
func (m *Manager) CreateAPIKey(userID string, req *CreateAPIKeyRequest) (*APIKey, string, error) <span class="cov1" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        // Check if user exists
        user, exists := m.users[userID]
        if !exists || !user.Active </span><span class="cov0" title="0">{
                return nil, "", ErrUserNotFound
        }</span>
        
        // Generate API key
        <span class="cov1" title="1">rawKey := generateAPIKey()
        keyHash := hashAPIKey(rawKey)
        
        // Set permissions
        permissions := req.Permissions
        if len(permissions) == 0 </span><span class="cov0" title="0">{
                permissions = user.Permissions
        }</span>
        
        <span class="cov1" title="1">apiKey := &amp;APIKey{
                ID:          generateID(),
                Name:        req.Name,
                Key:         keyHash,
                UserID:      userID,
                Permissions: permissions,
                Metadata:    req.Metadata,
                ExpiresAt:   req.ExpiresAt,
                CreatedAt:   time.Now(),
                Active:      true,
        }
        
        if apiKey.Metadata == nil </span><span class="cov1" title="1">{
                apiKey.Metadata = make(map[string]string)
        }</span>
        
        <span class="cov1" title="1">m.apiKeys[apiKey.ID] = apiKey
        
        return apiKey, rawKey, nil</span>
}

// RevokeToken adds a token to the blacklist
func (m *Manager) RevokeToken(tokenID string, expiry time.Time) <span class="cov1" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        m.blacklistCache[tokenID] = expiry
}</span>

// RevokeSession revokes a session
func (m *Manager) RevokeSession(sessionID string) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        session, exists := m.sessions[sessionID]
        if !exists </span><span class="cov0" title="0">{
                return ErrSessionNotFound
        }</span>
        
        <span class="cov0" title="0">session.Active = false
        
        // Also blacklist the associated token
        if session.TokenID != "" </span><span class="cov0" title="0">{
                m.blacklistCache[session.TokenID] = session.ExpiresAt
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// RevokeAPIKey revokes an API key
func (m *Manager) RevokeAPIKey(keyID string) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        apiKey, exists := m.apiKeys[keyID]
        if !exists </span><span class="cov0" title="0">{
                return ErrAPIKeyNotFound
        }</span>
        
        <span class="cov0" title="0">apiKey.Active = false
        
        return nil</span>
}

// HasPermission checks if the auth context has a specific permission
func (m *Manager) HasPermission(ctx *AuthContext, permission string) bool <span class="cov5" title="5">{
        if ctx == nil || ctx.User == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // Admin role has all permissions
        <span class="cov5" title="5">if ctx.User.Role == RoleAdmin </span><span class="cov2" title="2">{
                return true
        }</span>
        
        // Check user permissions
        <span class="cov4" title="3">for _, perm := range ctx.User.Permissions </span><span class="cov5" title="5">{
                if perm == permission || perm == PermissionSystemAdmin </span><span class="cov2" title="2">{
                        return true
                }</span>
        }
        
        // Check API key permissions if using API key auth
        <span class="cov1" title="1">if ctx.Method == AuthMethodAPIKey &amp;&amp; ctx.APIKey != nil </span><span class="cov0" title="0">{
                for _, perm := range ctx.APIKey.Permissions </span><span class="cov0" title="0">{
                        if perm == permission || perm == PermissionSystemAdmin </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        
        <span class="cov1" title="1">return false</span>
}

// isTokenBlacklisted checks if a token is blacklisted
func (m *Manager) isTokenBlacklisted(tokenID string) bool <span class="cov4" title="3">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        
        expiry, exists := m.blacklistCache[tokenID]
        if !exists </span><span class="cov2" title="2">{
                return false
        }</span>
        
        // Check if blacklist entry has expired
        <span class="cov1" title="1">if time.Now().After(expiry) </span><span class="cov0" title="0">{
                delete(m.blacklistCache, tokenID)
                return false
        }</span>
        
        <span class="cov1" title="1">return true</span>
}

// Background cleanup routines
func (m *Manager) cleanupExpiredSessions() <span class="cov6" title="7">{
        ticker := time.NewTicker(30 * time.Minute)
        defer ticker.Stop()
        
        for </span><span class="cov6" title="7">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        m.mu.Lock()
                        now := time.Now()
                        for id, session := range m.sessions </span><span class="cov0" title="0">{
                                if now.After(session.ExpiresAt) </span><span class="cov0" title="0">{
                                        delete(m.sessions, id)
                                }</span>
                        }
                        <span class="cov0" title="0">m.mu.Unlock()</span>
                case &lt;-m.stopCleanup:<span class="cov6" title="7">
                        return</span>
                }
        }
}

func (m *Manager) cleanupBlacklist() <span class="cov6" title="7">{
        ticker := time.NewTicker(time.Hour)
        defer ticker.Stop()
        
        for </span><span class="cov6" title="7">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        m.mu.Lock()
                        now := time.Now()
                        for tokenID, expiry := range m.blacklistCache </span><span class="cov0" title="0">{
                                if now.After(expiry) </span><span class="cov0" title="0">{
                                        delete(m.blacklistCache, tokenID)
                                }</span>
                        }
                        <span class="cov0" title="0">m.mu.Unlock()</span>
                case &lt;-m.stopCleanup:<span class="cov6" title="7">
                        return</span>
                }
        }
}

// Utility functions
func generateID() string <span class="cov10" title="24">{
        bytes := make([]byte, 16)
        rand.Read(bytes)
        return hex.EncodeToString(bytes)
}</span>

func generateAPIKey() string <span class="cov2" title="2">{
        bytes := make([]byte, 32)
        rand.Read(bytes)
        return "ok_" + hex.EncodeToString(bytes)
}</span>

func hashAPIKey(key string) string <span class="cov4" title="3">{
        hash := sha256.Sum256([]byte(key))
        return hex.EncodeToString(hash[:])
}</pre>
		
		<pre class="file" id="file1" style="display: none">package auth

import (
        "fmt"
        "log"

        "github.com/gin-gonic/gin"
        "github.com/ollama/ollama-distributed/internal/config"
)

// Integration provides easy integration with the existing API server
type Integration struct {
        AuthManager       *Manager
        JWTManager        *JWTManager
        MiddlewareManager *MiddlewareManager
        Routes            *Routes
}

// NewIntegration creates a complete authentication integration
func NewIntegration(cfg *config.AuthConfig) (*Integration, error) <span class="cov0" title="0">{
        // Create auth manager
        authManager, err := NewManager(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create auth manager: %w", err)
        }</span>
        
        // Create JWT manager
        <span class="cov0" title="0">jwtManager, err := NewJWTManager(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create JWT manager: %w", err)
        }</span>
        
        // Create middleware manager
        <span class="cov0" title="0">middlewareManager := NewMiddlewareManager(authManager, jwtManager, cfg)
        
        // Create routes
        routes := NewRoutes(authManager, jwtManager, middlewareManager)
        
        return &amp;Integration{
                AuthManager:       authManager,
                JWTManager:        jwtManager,
                MiddlewareManager: middlewareManager,
                Routes:            routes,
        }, nil</span>
}

// SetupRouter configures a Gin router with authentication
func (i *Integration) SetupRouter() *gin.Engine <span class="cov0" title="0">{
        router := gin.New()
        
        // Register authentication routes
        i.Routes.RegisterRoutes(router)
        
        return router
}</span>

// ProtectAPIRoutes adds authentication to existing API routes
func (i *Integration) ProtectAPIRoutes(router *gin.Engine) <span class="cov0" title="0">{
        // Apply authentication middleware to protected API routes
        api := router.Group("/api/v1")
        api.Use(i.MiddlewareManager.AuthRequired())
        
        // Node management - requires node permissions
        nodeRoutes := api.Group("/nodes")
        nodeRoutes.Use(i.MiddlewareManager.RequireAnyPermission(
                PermissionNodeRead,
                PermissionNodeWrite,
                PermissionNodeAdmin,
        ))
        
        // Model management - requires model permissions
        modelRoutes := api.Group("/models")
        modelRoutes.Use(i.MiddlewareManager.RequireAnyPermission(
                PermissionModelRead,
                PermissionModelWrite,
                PermissionModelAdmin,
        ))
        
        // Cluster management - requires cluster permissions
        clusterRoutes := api.Group("/cluster")
        clusterRoutes.Use(i.MiddlewareManager.RequireAnyPermission(
                PermissionClusterRead,
                PermissionClusterWrite,
                PermissionClusterAdmin,
        ))
        
        // Inference - requires inference permissions
        inferenceRoutes := api.Group("/")
        inferenceRoutes.Use(i.MiddlewareManager.RequireAnyPermission(
                PermissionInferenceRead,
                PermissionInferenceWrite,
        ))
        
        // Metrics - requires metrics permissions
        metricsRoutes := api.Group("/metrics")
        metricsRoutes.Use(i.MiddlewareManager.RequirePermission(PermissionMetricsRead))
}</span>

// CreateServiceToken creates a service token for internal communication
func (i *Integration) CreateServiceToken(serviceID, serviceName string) (string, error) <span class="cov0" title="0">{
        permissions := []string{
                PermissionNodeRead,
                PermissionModelRead,
                PermissionInferenceWrite,
                PermissionClusterRead,
        }
        
        return i.JWTManager.GenerateServiceToken(serviceID, serviceName, permissions)
}</span>

// CreateAdminToken creates an admin token for administrative tasks
func (i *Integration) CreateAdminToken(adminID, adminName string) (string, error) <span class="cov0" title="0">{
        permissions := DefaultRolePermissions[RoleAdmin]
        return i.JWTManager.GenerateServiceToken(adminID, adminName, permissions)
}</span>

// Close gracefully shuts down the authentication system
func (i *Integration) Close() <span class="cov0" title="0">{
        i.AuthManager.Close()
}</span>

// Example integration with existing server
func ExampleIntegration() <span class="cov0" title="0">{
        // Load configuration
        cfg := &amp;config.AuthConfig{
                Enabled:     true,
                Method:      "jwt",
                TokenExpiry: 24 * 3600, // 24 hours in seconds
                SecretKey:   "your-secret-key",
                Issuer:      "ollama-distributed",
                Audience:    "ollama-api",
        }
        
        // Create authentication integration
        authIntegration, err := NewIntegration(cfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create auth integration: %v", err)
        }</span>
        <span class="cov0" title="0">defer authIntegration.Close()
        
        // Setup router with authentication
        router := gin.New()
        
        // Register authentication routes
        authIntegration.Routes.RegisterRoutes(router)
        
        // Protect existing API routes
        authIntegration.ProtectAPIRoutes(router)
        
        // Example: Add a protected endpoint
        protected := router.Group("/api/v1/protected")
        protected.Use(authIntegration.MiddlewareManager.AuthRequired())
        protected.Use(authIntegration.MiddlewareManager.RequirePermission(PermissionSystemAdmin))
        </span><span class="cov0" title="0">{
                protected.GET("/admin-only", func(c *gin.Context) </span><span class="cov0" title="0">{
                        user := GetCurrentUser(c)
                        c.JSON(200, gin.H{
                                "message": "This is an admin-only endpoint",
                                "user":    user.Username,
                                "role":    user.Role,
                        })
                }</span>)
        }
        
        // Example: Create a service token
        <span class="cov0" title="0">serviceToken, err := authIntegration.CreateServiceToken("node-1", "Ollama Node 1")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to create service token: %v", err)
        }</span> else<span class="cov0" title="0"> {
                log.Printf("Service token created: %s", serviceToken)
        }</span>
        
        // Start server
        <span class="cov0" title="0">log.Println("Starting server with authentication on :8080")
        router.Run(":8080")</span>
}

// MiddlewareHelpers provides helper functions for common middleware patterns
type MiddlewareHelpers struct {
        integration *Integration
}

// NewMiddlewareHelpers creates middleware helpers
func NewMiddlewareHelpers(integration *Integration) *MiddlewareHelpers <span class="cov0" title="0">{
        return &amp;MiddlewareHelpers{integration: integration}
}</span>

// RequireNodePermission creates middleware for node operations
func (mh *MiddlewareHelpers) RequireNodePermission(operation string) gin.HandlerFunc <span class="cov0" title="0">{
        switch operation </span>{
        case "read":<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionNodeRead)</span>
        case "write":<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionNodeWrite)</span>
        case "admin":<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionNodeAdmin)</span>
        default:<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionNodeRead)</span>
        }
}

// RequireModelPermission creates middleware for model operations
func (mh *MiddlewareHelpers) RequireModelPermission(operation string) gin.HandlerFunc <span class="cov0" title="0">{
        switch operation </span>{
        case "read":<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionModelRead)</span>
        case "write":<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionModelWrite)</span>
        case "admin":<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionModelAdmin)</span>
        default:<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionModelRead)</span>
        }
}

// RequireClusterPermission creates middleware for cluster operations
func (mh *MiddlewareHelpers) RequireClusterPermission(operation string) gin.HandlerFunc <span class="cov0" title="0">{
        switch operation </span>{
        case "read":<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionClusterRead)</span>
        case "write":<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionClusterWrite)</span>
        case "admin":<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionClusterAdmin)</span>
        default:<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionClusterRead)</span>
        }
}

// RequireInferencePermission creates middleware for inference operations
func (mh *MiddlewareHelpers) RequireInferencePermission(operation string) gin.HandlerFunc <span class="cov0" title="0">{
        switch operation </span>{
        case "read":<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionInferenceRead)</span>
        case "write":<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionInferenceWrite)</span>
        default:<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionInferenceRead)</span>
        }
}

// Example usage in existing API handlers
func ExampleAPIIntegration(authIntegration *Integration) <span class="cov0" title="0">{
        router := gin.New()
        helpers := NewMiddlewareHelpers(authIntegration)
        
        // Register auth routes
        authIntegration.Routes.RegisterRoutes(router)
        
        // Protected API routes
        api := router.Group("/api/v1")
        api.Use(authIntegration.MiddlewareManager.AuthRequired())
        
        // Node management with granular permissions
        nodes := api.Group("/nodes")
        </span><span class="cov0" title="0">{
                nodes.GET("", helpers.RequireNodePermission("read"), func(c *gin.Context) </span><span class="cov0" title="0">{
                        // Get nodes logic
                        c.JSON(200, gin.H{"nodes": []string{}})
                }</span>)
                
                <span class="cov0" title="0">nodes.POST("", helpers.RequireNodePermission("write"), func(c *gin.Context) </span><span class="cov0" title="0">{
                        // Create node logic
                        c.JSON(201, gin.H{"message": "Node created"})
                }</span>)
                
                <span class="cov0" title="0">nodes.DELETE("/:id", helpers.RequireNodePermission("admin"), func(c *gin.Context) </span><span class="cov0" title="0">{
                        // Delete node logic
                        c.JSON(200, gin.H{"message": "Node deleted"})
                }</span>)
        }
        
        // Model management with granular permissions
        <span class="cov0" title="0">models := api.Group("/models")
        </span><span class="cov0" title="0">{
                models.GET("", helpers.RequireModelPermission("read"), func(c *gin.Context) </span><span class="cov0" title="0">{
                        // Get models logic
                        c.JSON(200, gin.H{"models": []string{}})
                }</span>)
                
                <span class="cov0" title="0">models.POST("/:name/download", helpers.RequireModelPermission("write"), func(c *gin.Context) </span><span class="cov0" title="0">{
                        // Download model logic
                        c.JSON(200, gin.H{"message": "Download started"})
                }</span>)
                
                <span class="cov0" title="0">models.DELETE("/:name", helpers.RequireModelPermission("admin"), func(c *gin.Context) </span><span class="cov0" title="0">{
                        // Delete model logic
                        c.JSON(200, gin.H{"message": "Model deleted"})
                }</span>)
        }
        
        // Inference endpoints
        <span class="cov0" title="0">inference := api.Group("/")
        </span><span class="cov0" title="0">{
                inference.POST("/generate", helpers.RequireInferencePermission("write"), func(c *gin.Context) </span><span class="cov0" title="0">{
                        // Generate logic
                        user := GetCurrentUser(c)
                        c.JSON(200, gin.H{
                                "response": "Generated text",
                                "user":     user.Username,
                        })
                }</span>)
                
                <span class="cov0" title="0">inference.POST("/chat", helpers.RequireInferencePermission("write"), func(c *gin.Context) </span><span class="cov0" title="0">{
                        // Chat logic
                        c.JSON(200, gin.H{"response": "Chat response"})
                }</span>)
        }
        
        // Metrics (read-only)
        <span class="cov0" title="0">api.GET("/metrics", helpers.RequireInferencePermission("read"), func(c *gin.Context) </span><span class="cov0" title="0">{
                // Metrics logic
                c.JSON(200, gin.H{"metrics": map[string]interface{}{}})
        }</span>)
}</pre>
		
		<pre class="file" id="file2" style="display: none">package auth

import (
        "crypto/rand"
        "crypto/rsa"
        "fmt"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "github.com/ollama/ollama-distributed/internal/config"
)

// JWTManager handles JWT token operations with advanced features
type JWTManager struct {
        config     *config.AuthConfig
        privateKey *rsa.PrivateKey
        publicKey  *rsa.PublicKey
        
        // Token blacklist and refresh tokens
        blacklist    map[string]time.Time
        refreshTokens map[string]*RefreshToken
}

// RefreshToken represents a refresh token
type RefreshToken struct {
        ID        string    `json:"id"`
        UserID    string    `json:"user_id"`
        TokenHash string    `json:"token_hash"`
        ExpiresAt time.Time `json:"expires_at"`
        CreatedAt time.Time `json:"created_at"`
        Used      bool      `json:"used"`
}

// TokenPair represents an access token and refresh token pair
type TokenPair struct {
        AccessToken  string    `json:"access_token"`
        RefreshToken string    `json:"refresh_token"`
        ExpiresAt    time.Time `json:"expires_at"`
        TokenType    string    `json:"token_type"`
}

// NewJWTManager creates a new JWT manager
func NewJWTManager(cfg *config.AuthConfig) (*JWTManager, error) <span class="cov10" title="2">{
        // Generate RSA key pair for signing
        privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate RSA key: %w", err)
        }</span>
        
        <span class="cov10" title="2">return &amp;JWTManager{
                config:        cfg,
                privateKey:    privateKey,
                publicKey:     &amp;privateKey.PublicKey,
                blacklist:     make(map[string]time.Time),
                refreshTokens: make(map[string]*RefreshToken),
        }, nil</span>
}

// GenerateTokenPair generates an access token and refresh token pair
func (jm *JWTManager) GenerateTokenPair(user *User, sessionID string, metadata map[string]string) (*TokenPair, error) <span class="cov1" title="1">{
        now := time.Now()
        accessTokenExpiry := now.Add(jm.config.TokenExpiry)
        refreshTokenExpiry := now.Add(7 * 24 * time.Hour) // 7 days for refresh token
        
        // Create access token claims
        accessClaims := &amp;Claims{
                UserID:      user.ID,
                Username:    user.Username,
                Email:       user.Email,
                Role:        user.Role,
                Permissions: user.Permissions,
                SessionID:   sessionID,
                Metadata:    metadata,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(accessTokenExpiry),
                        IssuedAt:  jwt.NewNumericDate(now),
                        NotBefore: jwt.NewNumericDate(now),
                        Issuer:    jm.config.Issuer,
                        Subject:   user.ID,
                        ID:        generateID(),
                        Audience:  []string{jm.config.Audience},
                },
        }
        
        // Sign access token
        accessToken := jwt.NewWithClaims(jwt.SigningMethodRS256, accessClaims)
        accessTokenString, err := accessToken.SignedString(jm.privateKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to sign access token: %w", err)
        }</span>
        
        // Create refresh token
        <span class="cov1" title="1">refreshTokenID := generateID()
        refreshTokenString := generateAPIKey() // Reuse the secure random generation
        refreshTokenHash := hashAPIKey(refreshTokenString)
        
        refreshToken := &amp;RefreshToken{
                ID:        refreshTokenID,
                UserID:    user.ID,
                TokenHash: refreshTokenHash,
                ExpiresAt: refreshTokenExpiry,
                CreatedAt: now,
                Used:      false,
        }
        
        jm.refreshTokens[refreshTokenID] = refreshToken
        
        return &amp;TokenPair{
                AccessToken:  accessTokenString,
                RefreshToken: refreshTokenString,
                ExpiresAt:    accessTokenExpiry,
                TokenType:    "Bearer",
        }, nil</span>
}

// RefreshAccessToken generates a new access token using a refresh token
func (jm *JWTManager) RefreshAccessToken(refreshTokenString string, user *User) (*TokenPair, error) <span class="cov0" title="0">{
        refreshTokenHash := hashAPIKey(refreshTokenString)
        
        // Find the refresh token
        var refreshToken *RefreshToken
        for _, rt := range jm.refreshTokens </span><span class="cov0" title="0">{
                if rt.TokenHash == refreshTokenHash &amp;&amp; rt.UserID == user.ID &amp;&amp; !rt.Used </span><span class="cov0" title="0">{
                        if time.Now().Before(rt.ExpiresAt) </span><span class="cov0" title="0">{
                                refreshToken = rt
                                break</span>
                        }
                }
        }
        
        <span class="cov0" title="0">if refreshToken == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid or expired refresh token")
        }</span>
        
        // Mark the old refresh token as used
        <span class="cov0" title="0">refreshToken.Used = true
        
        // Generate new token pair
        return jm.GenerateTokenPair(user, "", nil)</span>
}

// ValidateToken validates a JWT access token
func (jm *JWTManager) ValidateToken(tokenString string) (*Claims, error) <span class="cov10" title="2">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov10" title="2">{
                if _, ok := token.Method.(*jwt.SigningMethodRSA); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov10" title="2">return jm.publicKey, nil</span>
        })
        
        <span class="cov10" title="2">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse token: %w", err)
        }</span>
        
        <span class="cov10" title="2">claims, ok := token.Claims.(*Claims)
        if !ok || !token.Valid </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid token claims")
        }</span>
        
        // Check if token is blacklisted
        <span class="cov10" title="2">if jm.isBlacklisted(claims.ID) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("token is blacklisted")
        }</span>
        
        <span class="cov10" title="2">return claims, nil</span>
}

// BlacklistToken adds a token to the blacklist
func (jm *JWTManager) BlacklistToken(tokenID string, expiry time.Time) <span class="cov0" title="0">{
        jm.blacklist[tokenID] = expiry
}</span>

// RevokeRefreshToken revokes a refresh token
func (jm *JWTManager) RevokeRefreshToken(refreshTokenString, userID string) error <span class="cov0" title="0">{
        refreshTokenHash := hashAPIKey(refreshTokenString)
        
        for _, rt := range jm.refreshTokens </span><span class="cov0" title="0">{
                if rt.TokenHash == refreshTokenHash &amp;&amp; rt.UserID == userID </span><span class="cov0" title="0">{
                        rt.Used = true
                        return nil
                }</span>
        }
        
        <span class="cov0" title="0">return fmt.Errorf("refresh token not found")</span>
}

// RevokeAllUserTokens revokes all tokens for a user
func (jm *JWTManager) RevokeAllUserTokens(userID string) <span class="cov0" title="0">{
        // Mark all refresh tokens as used
        for _, rt := range jm.refreshTokens </span><span class="cov0" title="0">{
                if rt.UserID == userID </span><span class="cov0" title="0">{
                        rt.Used = true
                }</span>
        }
}

// CleanupExpiredTokens removes expired tokens from memory
func (jm *JWTManager) CleanupExpiredTokens() <span class="cov0" title="0">{
        now := time.Now()
        
        // Clean up blacklist
        for tokenID, expiry := range jm.blacklist </span><span class="cov0" title="0">{
                if now.After(expiry) </span><span class="cov0" title="0">{
                        delete(jm.blacklist, tokenID)
                }</span>
        }
        
        // Clean up refresh tokens
        <span class="cov0" title="0">for id, rt := range jm.refreshTokens </span><span class="cov0" title="0">{
                if now.After(rt.ExpiresAt) || rt.Used </span><span class="cov0" title="0">{
                        delete(jm.refreshTokens, id)
                }</span>
        }
}

// GetTokenClaims extracts claims from a token without validating it (useful for expired tokens)
func (jm *JWTManager) GetTokenClaims(tokenString string) (*Claims, error) <span class="cov0" title="0">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                return jm.publicKey, nil
        }</span>, jwt.WithoutClaimsValidation())
        
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse token: %w", err)
        }</span>
        
        <span class="cov0" title="0">claims, ok := token.Claims.(*Claims)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid token claims")
        }</span>
        
        <span class="cov0" title="0">return claims, nil</span>
}

// GenerateServiceToken generates a long-lived token for service-to-service communication
func (jm *JWTManager) GenerateServiceToken(serviceID, serviceName string, permissions []string) (string, error) <span class="cov1" title="1">{
        now := time.Now()
        expiry := now.Add(365 * 24 * time.Hour) // 1 year
        
        claims := &amp;Claims{
                UserID:      serviceID,
                Username:    serviceName,
                Role:        RoleService,
                Permissions: permissions,
                Metadata: map[string]string{
                        "token_type": "service",
                },
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(expiry),
                        IssuedAt:  jwt.NewNumericDate(now),
                        NotBefore: jwt.NewNumericDate(now),
                        Issuer:    jm.config.Issuer,
                        Subject:   serviceID,
                        ID:        generateID(),
                        Audience:  []string{jm.config.Audience},
                },
        }
        
        token := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
        return token.SignedString(jm.privateKey)
}</span>

// ValidateServiceToken validates a service token
func (jm *JWTManager) ValidateServiceToken(tokenString string) (*Claims, error) <span class="cov1" title="1">{
        claims, err := jm.ValidateToken(tokenString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // Verify this is a service token
        <span class="cov1" title="1">if claims.Metadata["token_type"] != "service" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not a service token")
        }</span>
        
        <span class="cov1" title="1">return claims, nil</span>
}

// CreateShortLivedToken creates a token with custom expiry (for specific operations)
func (jm *JWTManager) CreateShortLivedToken(user *User, duration time.Duration, purpose string) (string, error) <span class="cov0" title="0">{
        now := time.Now()
        expiry := now.Add(duration)
        
        claims := &amp;Claims{
                UserID:      user.ID,
                Username:    user.Username,
                Email:       user.Email,
                Role:        user.Role,
                Permissions: user.Permissions,
                Metadata: map[string]string{
                        "token_type": "short_lived",
                        "purpose":    purpose,
                },
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(expiry),
                        IssuedAt:  jwt.NewNumericDate(now),
                        NotBefore: jwt.NewNumericDate(now),
                        Issuer:    jm.config.Issuer,
                        Subject:   user.ID,
                        ID:        generateID(),
                        Audience:  []string{jm.config.Audience},
                },
        }
        
        token := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
        return token.SignedString(jm.privateKey)
}</span>

// GetPublicKey returns the public key for token verification by other services
func (jm *JWTManager) GetPublicKey() *rsa.PublicKey <span class="cov0" title="0">{
        return jm.publicKey
}</span>

// GetTokenStats returns statistics about tokens
func (jm *JWTManager) GetTokenStats() map[string]interface{} <span class="cov0" title="0">{
        activeRefreshTokens := 0
        expiredRefreshTokens := 0
        now := time.Now()
        
        for _, rt := range jm.refreshTokens </span><span class="cov0" title="0">{
                if rt.Used || now.After(rt.ExpiresAt) </span><span class="cov0" title="0">{
                        expiredRefreshTokens++
                }</span> else<span class="cov0" title="0"> {
                        activeRefreshTokens++
                }</span>
        }
        
        <span class="cov0" title="0">return map[string]interface{}{
                "active_refresh_tokens":  activeRefreshTokens,
                "expired_refresh_tokens": expiredRefreshTokens,
                "blacklisted_tokens":     len(jm.blacklist),
                "total_refresh_tokens":   len(jm.refreshTokens),
        }</span>
}

// isBlacklisted checks if a token ID is blacklisted
func (jm *JWTManager) isBlacklisted(tokenID string) bool <span class="cov10" title="2">{
        expiry, exists := jm.blacklist[tokenID]
        if !exists </span><span class="cov10" title="2">{
                return false
        }</span>
        
        <span class="cov0" title="0">if time.Now().After(expiry) </span><span class="cov0" title="0">{
                delete(jm.blacklist, tokenID)
                return false
        }</span>
        
        <span class="cov0" title="0">return true</span>
}</pre>
		
		<pre class="file" id="file3" style="display: none">package auth

import (
        "net/http"
        "strings"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/ollama/ollama-distributed/internal/config"
)

// MiddlewareManager handles HTTP middleware for authentication and authorization
type MiddlewareManager struct {
        authManager *Manager
        jwtManager  *JWTManager
        config      *config.AuthConfig
}

// NewMiddlewareManager creates a new middleware manager
func NewMiddlewareManager(authManager *Manager, jwtManager *JWTManager, config *config.AuthConfig) *MiddlewareManager <span class="cov0" title="0">{
        return &amp;MiddlewareManager{
                authManager: authManager,
                jwtManager:  jwtManager,
                config:      config,
        }
}</span>

// AuthRequired middleware that requires authentication
func (mm *MiddlewareManager) AuthRequired() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Skip auth if disabled
                if !mm.config.Enabled </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>
                
                // Skip auth for certain paths
                <span class="cov0" title="0">if mm.shouldSkipAuth(c.Request.URL.Path, c.Request.Method) </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>
                
                // Try to authenticate
                <span class="cov0" title="0">authCtx, err := mm.authenticate(c)
                if err != nil </span><span class="cov0" title="0">{
                        mm.handleAuthError(c, err)
                        return
                }</span>
                
                // Store auth context
                <span class="cov0" title="0">mm.setAuthContext(c, authCtx)
                c.Next()</span>
        }
}

// RequirePermission middleware that requires specific permissions
func (mm *MiddlewareManager) RequirePermission(permission string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                authCtx := mm.getAuthContext(c)
                if authCtx == nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
                        c.Abort()
                        return
                }</span>
                
                <span class="cov0" title="0">if !mm.authManager.HasPermission(authCtx, permission) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, gin.H{
                                "error": "Insufficient permissions",
                                "required_permission": permission,
                        })
                        c.Abort()
                        return
                }</span>
                
                <span class="cov0" title="0">c.Next()</span>
        }
}

// RequireRole middleware that requires a specific role
func (mm *MiddlewareManager) RequireRole(role string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                authCtx := mm.getAuthContext(c)
                if authCtx == nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
                        c.Abort()
                        return
                }</span>
                
                <span class="cov0" title="0">if authCtx.User.Role != role &amp;&amp; authCtx.User.Role != RoleAdmin </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, gin.H{
                                "error": "Insufficient role",
                                "required_role": role,
                                "user_role": authCtx.User.Role,
                        })
                        c.Abort()
                        return
                }</span>
                
                <span class="cov0" title="0">c.Next()</span>
        }
}

// RequireAnyRole middleware that requires any of the specified roles
func (mm *MiddlewareManager) RequireAnyRole(roles ...string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                authCtx := mm.getAuthContext(c)
                if authCtx == nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
                        c.Abort()
                        return
                }</span>
                
                // Admin always has access
                <span class="cov0" title="0">if authCtx.User.Role == RoleAdmin </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>
                
                // Check if user has any of the required roles
                <span class="cov0" title="0">hasRole := false
                for _, role := range roles </span><span class="cov0" title="0">{
                        if authCtx.User.Role == role </span><span class="cov0" title="0">{
                                hasRole = true
                                break</span>
                        }
                }
                
                <span class="cov0" title="0">if !hasRole </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, gin.H{
                                "error": "Insufficient role",
                                "required_roles": roles,
                                "user_role": authCtx.User.Role,
                        })
                        c.Abort()
                        return
                }</span>
                
                <span class="cov0" title="0">c.Next()</span>
        }
}

// RequireAnyPermission middleware that requires any of the specified permissions
func (mm *MiddlewareManager) RequireAnyPermission(permissions ...string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                authCtx := mm.getAuthContext(c)
                if authCtx == nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
                        c.Abort()
                        return
                }</span>
                
                // Check if user has any of the required permissions
                <span class="cov0" title="0">hasPermission := false
                for _, permission := range permissions </span><span class="cov0" title="0">{
                        if mm.authManager.HasPermission(authCtx, permission) </span><span class="cov0" title="0">{
                                hasPermission = true
                                break</span>
                        }
                }
                
                <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, gin.H{
                                "error": "Insufficient permissions",
                                "required_permissions": permissions,
                        })
                        c.Abort()
                        return
                }</span>
                
                <span class="cov0" title="0">c.Next()</span>
        }
}

// Optional middleware that attempts authentication but doesn't require it
func (mm *MiddlewareManager) Optional() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                if !mm.config.Enabled </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>
                
                // Try to authenticate but don't fail if unsuccessful
                <span class="cov0" title="0">authCtx, _ := mm.authenticate(c)
                if authCtx != nil </span><span class="cov0" title="0">{
                        mm.setAuthContext(c, authCtx)
                }</span>
                
                <span class="cov0" title="0">c.Next()</span>
        }
}

// RateLimit middleware for API rate limiting
func (mm *MiddlewareManager) RateLimit() gin.HandlerFunc <span class="cov0" title="0">{
        // This is a simplified rate limiter
        // In production, use a proper rate limiting library like tollbooth or redis-based limiter
        requestCounts := make(map[string]map[int64]int)
        
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Get client identifier (IP or user ID if authenticated)
                clientID := c.ClientIP()
                if authCtx := mm.getAuthContext(c); authCtx != nil </span><span class="cov0" title="0">{
                        clientID = authCtx.User.ID
                }</span>
                
                // Current minute window
                <span class="cov0" title="0">currentMinute := time.Now().Unix() / 60
                
                if requestCounts[clientID] == nil </span><span class="cov0" title="0">{
                        requestCounts[clientID] = make(map[int64]int)
                }</span>
                
                // Clean old entries
                <span class="cov0" title="0">for minute := range requestCounts[clientID] </span><span class="cov0" title="0">{
                        if currentMinute-minute &gt; 5 </span><span class="cov0" title="0">{ // Keep last 5 minutes
                                delete(requestCounts[clientID], minute)
                        }</span>
                }
                
                // Count requests in current minute
                <span class="cov0" title="0">requestCounts[clientID][currentMinute]++
                
                // Check limit (100 requests per minute)
                if requestCounts[clientID][currentMinute] &gt; 100 </span><span class="cov0" title="0">{
                        c.JSON(http.StatusTooManyRequests, gin.H{
                                "error": "Rate limit exceeded",
                                "retry_after": 60,
                        })
                        c.Abort()
                        return
                }</span>
                
                <span class="cov0" title="0">c.Header("X-RateLimit-Limit", "100")
                c.Header("X-RateLimit-Remaining", string(rune(100-requestCounts[clientID][currentMinute])))
                c.Header("X-RateLimit-Reset", string(rune((currentMinute+1)*60)))
                
                c.Next()</span>
        }
}

// CORS middleware with authentication-aware settings
func (mm *MiddlewareManager) CORS() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                origin := c.Request.Header.Get("Origin")
                
                // Default allowed origins
                allowedOrigins := []string{"http://localhost:8080", "https://localhost:8080"}
                
                // Check if origin is allowed
                allowed := false
                for _, allowedOrigin := range allowedOrigins </span><span class="cov0" title="0">{
                        if origin == allowedOrigin </span><span class="cov0" title="0">{
                                allowed = true
                                break</span>
                        }
                }
                
                <span class="cov0" title="0">if allowed </span><span class="cov0" title="0">{
                        c.Header("Access-Control-Allow-Origin", origin)
                }</span>
                
                <span class="cov0" title="0">c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                c.Header("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Requested-With")
                c.Header("Access-Control-Allow-Credentials", "true")
                c.Header("Access-Control-Max-Age", "3600")
                
                if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(http.StatusNoContent)
                        return
                }</span>
                
                <span class="cov0" title="0">c.Next()</span>
        }
}

// SecurityHeaders middleware that adds security headers
func (mm *MiddlewareManager) SecurityHeaders() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Header("X-Content-Type-Options", "nosniff")
                c.Header("X-Frame-Options", "DENY")
                c.Header("X-XSS-Protection", "1; mode=block")
                c.Header("Referrer-Policy", "strict-origin-when-cross-origin")
                c.Header("Content-Security-Policy", "default-src 'self'")
                c.Header("Strict-Transport-Security", "max-age=31536000; includeSubDomains")
                
                c.Next()
        }</span>
}

// AuditLog middleware that logs authentication events
func (mm *MiddlewareManager) AuditLog() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()
                
                // Process request
                c.Next()
                
                // Log after request completion
                duration := time.Since(start)
                authCtx := mm.getAuthContext(c)
                
                logData := map[string]interface{}{
                        "timestamp":    start.Unix(),
                        "method":       c.Request.Method,
                        "path":         c.Request.URL.Path,
                        "status":       c.Writer.Status(),
                        "duration_ms":  duration.Milliseconds(),
                        "ip":           c.ClientIP(),
                        "user_agent":   c.Request.Header.Get("User-Agent"),
                }
                
                if authCtx != nil </span><span class="cov0" title="0">{
                        logData["user_id"] = authCtx.User.ID
                        logData["username"] = authCtx.User.Username
                        logData["auth_method"] = string(authCtx.Method)
                        if authCtx.Session != nil </span><span class="cov0" title="0">{
                                logData["session_id"] = authCtx.Session.ID
                        }</span>
                        <span class="cov0" title="0">if authCtx.APIKey != nil </span><span class="cov0" title="0">{
                                logData["api_key_id"] = authCtx.APIKey.ID
                        }</span>
                }
                
                // In production, send this to a proper logging system
                // fmt.Printf("AUDIT: %+v\n", logData)
        }
}

// Helper methods

func (mm *MiddlewareManager) authenticate(c *gin.Context) (*AuthContext, error) <span class="cov0" title="0">{
        // Try API key authentication first
        if apiKey := mm.extractAPIKey(c); apiKey != "" </span><span class="cov0" title="0">{
                return mm.authManager.ValidateAPIKey(apiKey)
        }</span>
        
        // Try JWT token authentication
        <span class="cov0" title="0">if token := mm.extractBearerToken(c); token != "" </span><span class="cov0" title="0">{
                return mm.authManager.ValidateToken(token)
        }</span>
        
        <span class="cov0" title="0">return nil, ErrInvalidCredentials</span>
}

func (mm *MiddlewareManager) extractBearerToken(c *gin.Context) string <span class="cov0" title="0">{
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        
        <span class="cov0" title="0">parts := strings.SplitN(authHeader, " ", 2)
        if len(parts) != 2 || strings.ToLower(parts[0]) != "bearer" </span><span class="cov0" title="0">{
                return ""
        }</span>
        
        <span class="cov0" title="0">return parts[1]</span>
}

func (mm *MiddlewareManager) extractAPIKey(c *gin.Context) string <span class="cov0" title="0">{
        // Check Authorization header with API key
        authHeader := c.GetHeader("Authorization")
        if strings.HasPrefix(strings.ToLower(authHeader), "apikey ") </span><span class="cov0" title="0">{
                return strings.TrimPrefix(authHeader, "ApiKey ")
        }</span>
        
        // Check X-API-Key header
        <span class="cov0" title="0">if apiKey := c.GetHeader("X-API-Key"); apiKey != "" </span><span class="cov0" title="0">{
                return apiKey
        }</span>
        
        // Check query parameter
        <span class="cov0" title="0">if apiKey := c.Query("api_key"); apiKey != "" </span><span class="cov0" title="0">{
                return apiKey
        }</span>
        
        <span class="cov0" title="0">return ""</span>
}

func (mm *MiddlewareManager) shouldSkipAuth(path, method string) bool <span class="cov0" title="0">{
        // Public endpoints that don't require authentication
        publicPaths := []string{
                "/api/v1/health",
                "/api/v1/login",
                "/api/v1/register",
                "/metrics",
                "/favicon.ico",
        }
        
        for _, publicPath := range publicPaths </span><span class="cov0" title="0">{
                if path == publicPath </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">if strings.HasPrefix(path, "/static/") </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        
        // Always allow OPTIONS requests for CORS
        <span class="cov0" title="0">if method == "OPTIONS" </span><span class="cov0" title="0">{
                return true
        }</span>
        
        <span class="cov0" title="0">return false</span>
}

func (mm *MiddlewareManager) handleAuthError(c *gin.Context, err error) <span class="cov0" title="0">{
        var status int
        var response gin.H
        
        switch err.(type) </span>{
        case AuthError:<span class="cov0" title="0">
                authErr := err.(AuthError)
                switch authErr.Code </span>{
                case "TOKEN_EXPIRED":<span class="cov0" title="0">
                        status = http.StatusUnauthorized</span>
                case "TOKEN_INVALID":<span class="cov0" title="0">
                        status = http.StatusUnauthorized</span>
                case "TOKEN_BLACKLISTED":<span class="cov0" title="0">
                        status = http.StatusUnauthorized</span>
                case "INSUFFICIENT_PERMISSIONS":<span class="cov0" title="0">
                        status = http.StatusForbidden</span>
                case "USER_NOT_FOUND":<span class="cov0" title="0">
                        status = http.StatusUnauthorized</span>
                case "USER_INACTIVE":<span class="cov0" title="0">
                        status = http.StatusUnauthorized</span>
                default:<span class="cov0" title="0">
                        status = http.StatusUnauthorized</span>
                }
                <span class="cov0" title="0">response = gin.H{
                        "error": authErr.Message,
                        "code":  authErr.Code,
                }</span>
        default:<span class="cov0" title="0">
                status = http.StatusUnauthorized
                response = gin.H{
                        "error": "Authentication required",
                }</span>
        }
        
        <span class="cov0" title="0">c.JSON(status, response)
        c.Abort()</span>
}

func (mm *MiddlewareManager) setAuthContext(c *gin.Context, authCtx *AuthContext) <span class="cov0" title="0">{
        c.Set("auth_context", authCtx)
        c.Set("user", authCtx.User)
        c.Set("user_id", authCtx.User.ID)
        c.Set("username", authCtx.User.Username)
        c.Set("role", authCtx.User.Role)
        c.Set("permissions", authCtx.User.Permissions)
        if authCtx.Session != nil </span><span class="cov0" title="0">{
                c.Set("session", authCtx.Session)
                c.Set("session_id", authCtx.Session.ID)
        }</span>
        <span class="cov0" title="0">if authCtx.APIKey != nil </span><span class="cov0" title="0">{
                c.Set("api_key", authCtx.APIKey)
                c.Set("api_key_id", authCtx.APIKey.ID)
        }</span>
}

func (mm *MiddlewareManager) getAuthContext(c *gin.Context) *AuthContext <span class="cov0" title="0">{
        if authCtx, exists := c.Get("auth_context"); exists </span><span class="cov0" title="0">{
                if ctx, ok := authCtx.(*AuthContext); ok </span><span class="cov0" title="0">{
                        return ctx
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// GetCurrentUser helper function to get current user from context
func GetCurrentUser(c *gin.Context) *User <span class="cov0" title="0">{
        if user, exists := c.Get("user"); exists </span><span class="cov0" title="0">{
                if u, ok := user.(*User); ok </span><span class="cov0" title="0">{
                        return u
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// GetCurrentUserID helper function to get current user ID from context
func GetCurrentUserID(c *gin.Context) string <span class="cov0" title="0">{
        if userID, exists := c.Get("user_id"); exists </span><span class="cov0" title="0">{
                if id, ok := userID.(string); ok </span><span class="cov0" title="0">{
                        return id
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// HasPermission helper function to check permissions in handlers
func HasPermission(c *gin.Context, permission string) bool <span class="cov0" title="0">{
        if permissions, exists := c.Get("permissions"); exists </span><span class="cov0" title="0">{
                if perms, ok := permissions.([]string); ok </span><span class="cov0" title="0">{
                        for _, perm := range perms </span><span class="cov0" title="0">{
                                if perm == permission || perm == PermissionSystemAdmin </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return false</span>
}</pre>
		
		<pre class="file" id="file4" style="display: none">package auth

import (
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
)

// Routes handles authentication-related HTTP routes
type Routes struct {
        authManager       *Manager
        jwtManager        *JWTManager
        middlewareManager *MiddlewareManager
}

// NewRoutes creates a new routes handler
func NewRoutes(authManager *Manager, jwtManager *JWTManager, middlewareManager *MiddlewareManager) *Routes <span class="cov0" title="0">{
        return &amp;Routes{
                authManager:       authManager,
                jwtManager:        jwtManager,
                middlewareManager: middlewareManager,
        }
}</span>

// RegisterRoutes registers authentication routes with the Gin router
func (r *Routes) RegisterRoutes(router *gin.Engine) <span class="cov0" title="0">{
        // Apply global middleware
        router.Use(r.middlewareManager.CORS())
        router.Use(r.middlewareManager.SecurityHeaders())
        router.Use(r.middlewareManager.RateLimit())
        router.Use(r.middlewareManager.AuditLog())
        
        // Public routes (no authentication required)
        public := router.Group("/api/v1")
        </span><span class="cov0" title="0">{
                public.POST("/login", r.login)
                public.POST("/register", r.register)
                public.POST("/refresh", r.refreshToken)
                public.GET("/health", r.health)
        }</span>
        
        // Protected routes (authentication required)
        <span class="cov0" title="0">protected := router.Group("/api/v1")
        protected.Use(r.middlewareManager.AuthRequired())
        </span><span class="cov0" title="0">{
                // User management
                user := protected.Group("/user")
                </span><span class="cov0" title="0">{
                        user.GET("/profile", r.getProfile)
                        user.PUT("/profile", r.updateProfile)
                        user.POST("/change-password", r.changePassword)
                        user.POST("/logout", r.logout)
                        user.GET("/sessions", r.getSessions)
                        user.DELETE("/sessions/:session_id", r.revokeSession)
                }</span>
                
                // API key management
                <span class="cov0" title="0">apiKeys := protected.Group("/api-keys")
                </span><span class="cov0" title="0">{
                        apiKeys.GET("", r.listAPIKeys)
                        apiKeys.POST("", r.createAPIKey)
                        apiKeys.DELETE("/:key_id", r.revokeAPIKey)
                }</span>
                
                // Admin routes
                <span class="cov0" title="0">admin := protected.Group("/admin")
                admin.Use(r.middlewareManager.RequireRole(RoleAdmin))
                </span><span class="cov0" title="0">{
                        admin.GET("/users", r.listUsers)
                        admin.POST("/users", r.createUser)
                        admin.GET("/users/:user_id", r.getUser)
                        admin.PUT("/users/:user_id", r.updateUser)
                        admin.DELETE("/users/:user_id", r.deleteUser)
                        admin.POST("/users/:user_id/reset-password", r.resetUserPassword)
                        admin.GET("/stats", r.getAuthStats)
                }</span>
        }
}

// Authentication handlers

func (r *Routes) login(c *gin.Context) <span class="cov0" title="0">{
        var req LoginRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>
        
        // Get client metadata
        <span class="cov0" title="0">metadata := map[string]string{
                "ip_address": c.ClientIP(),
                "user_agent": c.Request.Header.Get("User-Agent"),
        }
        for k, v := range req.Metadata </span><span class="cov0" title="0">{
                metadata[k] = v
        }</span>
        
        // Authenticate user
        <span class="cov0" title="0">authCtx, err := r.authManager.Authenticate(req.Username, req.Password, metadata)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
                return
        }</span>
        
        <span class="cov0" title="0">response := LoginResponse{
                Token:     authCtx.TokenString,
                ExpiresAt: authCtx.Session.ExpiresAt,
                User:      authCtx.User,
                SessionID: authCtx.Session.ID,
        }
        
        c.JSON(http.StatusOK, response)</span>
}

func (r *Routes) register(c *gin.Context) <span class="cov0" title="0">{
        var req CreateUserRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>
        
        // Default role for registration
        <span class="cov0" title="0">if req.Role == "" </span><span class="cov0" title="0">{
                req.Role = RoleUser
        }</span>
        
        // Only allow certain roles for self-registration
        <span class="cov0" title="0">allowedRoles := []string{RoleUser, RoleReadOnly}
        roleAllowed := false
        for _, role := range allowedRoles </span><span class="cov0" title="0">{
                if req.Role == role </span><span class="cov0" title="0">{
                        roleAllowed = true
                        break</span>
                }
        }
        
        <span class="cov0" title="0">if !roleAllowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid role for registration"})
                return
        }</span>
        
        <span class="cov0" title="0">user, err := r.authManager.CreateUser(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        
        // Remove sensitive data from response
        <span class="cov0" title="0">user.Metadata = map[string]string{}
        
        c.JSON(http.StatusCreated, gin.H{"user": user})</span>
}

func (r *Routes) refreshToken(c *gin.Context) <span class="cov0" title="0">{
        var req RefreshRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>
        
        // Get user from token (even if expired)
        <span class="cov0" title="0">_, err := r.jwtManager.GetTokenClaims(req.Token)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token"})
                return
        }</span>
        
        // This is a simplified implementation
        // In a real system, you'd use a separate refresh token
        <span class="cov0" title="0">c.JSON(http.StatusNotImplemented, gin.H{"error": "Refresh token functionality not implemented"})</span>
}

func (r *Routes) health(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "status":    "healthy",
                "service":   "auth",
                "timestamp": time.Now().Unix(),
        })
}</span>

// User management handlers

func (r *Routes) getProfile(c *gin.Context) <span class="cov0" title="0">{
        user := GetCurrentUser(c)
        if user == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "User not found"})
                return
        }</span>
        
        // Remove sensitive data
        <span class="cov0" title="0">user.Metadata = map[string]string{}
        
        c.JSON(http.StatusOK, gin.H{"user": user})</span>
}

func (r *Routes) updateProfile(c *gin.Context) <span class="cov0" title="0">{
        user := GetCurrentUser(c)
        if user == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "User not found"})
                return
        }</span>
        
        <span class="cov0" title="0">var req UpdateUserRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>
        
        // Update allowed fields
        <span class="cov0" title="0">if req.Email != nil </span><span class="cov0" title="0">{
                user.Email = *req.Email
        }</span>
        <span class="cov0" title="0">if req.Metadata != nil </span><span class="cov0" title="0">{
                for k, v := range req.Metadata </span><span class="cov0" title="0">{
                        if k != "password_hash" </span><span class="cov0" title="0">{ // Prevent password hash modification
                                user.Metadata[k] = v
                        }</span>
                }
        }
        
        <span class="cov0" title="0">user.UpdatedAt = time.Now()
        
        // Remove sensitive data from response
        user.Metadata = map[string]string{}
        
        c.JSON(http.StatusOK, gin.H{"user": user})</span>
}

func (r *Routes) changePassword(c *gin.Context) <span class="cov0" title="0">{
        user := GetCurrentUser(c)
        if user == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "User not found"})
                return
        }</span>
        
        <span class="cov0" title="0">var req ChangePasswordRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>
        
        // This would need to be implemented in the auth manager
        <span class="cov0" title="0">c.JSON(http.StatusNotImplemented, gin.H{"error": "Password change not implemented"})</span>
}

func (r *Routes) logout(c *gin.Context) <span class="cov0" title="0">{
        authCtx := r.middlewareManager.getAuthContext(c)
        if authCtx == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "No active session"})
                return
        }</span>
        
        // Revoke session if it exists
        <span class="cov0" title="0">if authCtx.Session != nil </span><span class="cov0" title="0">{
                r.authManager.RevokeSession(authCtx.Session.ID)
        }</span>
        
        // Blacklist the token
        <span class="cov0" title="0">if authCtx.Claims != nil </span><span class="cov0" title="0">{
                r.authManager.RevokeToken(authCtx.Claims.ID, authCtx.Claims.ExpiresAt.Time)
        }</span>
        
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Logged out successfully"})</span>
}

func (r *Routes) getSessions(c *gin.Context) <span class="cov0" title="0">{
        // This would need to be implemented to return user sessions
        c.JSON(http.StatusNotImplemented, gin.H{"error": "Session listing not implemented"})
}</span>

func (r *Routes) revokeSession(c *gin.Context) <span class="cov0" title="0">{
        sessionID := c.Param("session_id")
        
        err := r.authManager.RevokeSession(sessionID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>
        
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Session revoked successfully"})</span>
}

// API key management handlers

func (r *Routes) listAPIKeys(c *gin.Context) <span class="cov0" title="0">{
        user := GetCurrentUser(c)
        if user == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "User not found"})
                return
        }</span>
        
        // Filter API keys to only show current user's keys
        <span class="cov0" title="0">var userAPIKeys []APIKey
        for _, apiKey := range user.APIKeys </span><span class="cov0" title="0">{
                // Remove the actual key value for security
                apiKey.Key = ""
                userAPIKeys = append(userAPIKeys, apiKey)
        }</span>
        
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"api_keys": userAPIKeys})</span>
}

func (r *Routes) createAPIKey(c *gin.Context) <span class="cov0" title="0">{
        user := GetCurrentUser(c)
        if user == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "User not found"})
                return
        }</span>
        
        <span class="cov0" title="0">var req CreateAPIKeyRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>
        
        <span class="cov0" title="0">apiKey, rawKey, err := r.authManager.CreateAPIKey(user.ID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        
        <span class="cov0" title="0">response := CreateAPIKeyResponse{
                APIKey: apiKey,
                Key:    rawKey,
        }
        
        // Remove the hashed key from the response
        response.APIKey.Key = ""
        
        c.JSON(http.StatusCreated, response)</span>
}

func (r *Routes) revokeAPIKey(c *gin.Context) <span class="cov0" title="0">{
        keyID := c.Param("key_id")
        
        err := r.authManager.RevokeAPIKey(keyID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>
        
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "API key revoked successfully"})</span>
}

// Admin handlers

func (r *Routes) listUsers(c *gin.Context) <span class="cov0" title="0">{
        // This would need to be implemented in the auth manager
        c.JSON(http.StatusNotImplemented, gin.H{"error": "User listing not implemented"})
}</span>

func (r *Routes) createUser(c *gin.Context) <span class="cov0" title="0">{
        var req CreateUserRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>
        
        <span class="cov0" title="0">user, err := r.authManager.CreateUser(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        
        // Remove sensitive data
        <span class="cov0" title="0">user.Metadata = map[string]string{}
        
        c.JSON(http.StatusCreated, gin.H{"user": user})</span>
}

func (r *Routes) getUser(c *gin.Context) <span class="cov0" title="0">{
        userID := c.Param("user_id")
        
        // This would need to be implemented in the auth manager
        c.JSON(http.StatusNotImplemented, gin.H{"error": "User retrieval not implemented", "user_id": userID})
}</span>

func (r *Routes) updateUser(c *gin.Context) <span class="cov0" title="0">{
        userID := c.Param("user_id")
        
        var req UpdateUserRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>
        
        // This would need to be implemented in the auth manager
        <span class="cov0" title="0">c.JSON(http.StatusNotImplemented, gin.H{"error": "User update not implemented", "user_id": userID})</span>
}

func (r *Routes) deleteUser(c *gin.Context) <span class="cov0" title="0">{
        userID := c.Param("user_id")
        
        // This would need to be implemented in the auth manager
        c.JSON(http.StatusNotImplemented, gin.H{"error": "User deletion not implemented", "user_id": userID})
}</span>

func (r *Routes) resetUserPassword(c *gin.Context) <span class="cov0" title="0">{
        userID := c.Param("user_id")
        
        // This would need to be implemented in the auth manager
        c.JSON(http.StatusNotImplemented, gin.H{"error": "Password reset not implemented", "user_id": userID})
}</span>

func (r *Routes) getAuthStats(c *gin.Context) <span class="cov0" title="0">{
        stats := r.jwtManager.GetTokenStats()
        
        // Add more stats from auth manager
        stats["timestamp"] = time.Now().Unix()
        
        c.JSON(http.StatusOK, gin.H{"stats": stats})
}</pre>
		
		<pre class="file" id="file5" style="display: none">package auth

import (
        "log"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/ollama/ollama-distributed/internal/config"
)

// ExampleServerWithAuth demonstrates how to integrate the authentication system
// with the existing Ollama distributed server
func ExampleServerWithAuth() <span class="cov0" title="0">{
        // Load main configuration
        cfg, err := config.Load("")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load config: %v", err)
        }</span>
        
        // Ensure auth is enabled
        <span class="cov0" title="0">if !cfg.Security.Auth.Enabled </span><span class="cov0" title="0">{
                log.Println("WARNING: Authentication is disabled. Enable it for production!")
                cfg.Security.Auth.Enabled = true
                cfg.Security.Auth.Method = "jwt"
                cfg.Security.Auth.TokenExpiry = 24 * time.Hour
                cfg.Security.Auth.SecretKey = "demo-secret-key-change-in-production"
                cfg.Security.Auth.Issuer = "ollama-distributed"
                cfg.Security.Auth.Audience = "ollama-api"
        }</span>
        
        // Create authentication integration
        <span class="cov0" title="0">authIntegration, err := NewIntegration(&amp;cfg.Security.Auth)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create auth integration: %v", err)
        }</span>
        <span class="cov0" title="0">defer authIntegration.Close()
        
        // Create Gin router
        router := gin.New()
        
        // Apply global middleware
        router.Use(gin.Logger())
        router.Use(gin.Recovery())
        router.Use(authIntegration.MiddlewareManager.SecurityHeaders())
        router.Use(authIntegration.MiddlewareManager.CORS())
        router.Use(authIntegration.MiddlewareManager.RateLimit())
        router.Use(authIntegration.MiddlewareManager.AuditLog())
        
        // Register authentication routes
        authIntegration.Routes.RegisterRoutes(router)
        
        // Setup protected API routes
        setupProtectedAPIRoutes(router, authIntegration)
        
        // Setup public routes
        setupPublicRoutes(router)
        
        // Start server
        log.Printf("Starting Ollama Distributed Server with Authentication on %s", cfg.API.Listen)
        if err := router.Run(cfg.API.Listen); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to start server: %v", err)
        }</span>
}

// setupProtectedAPIRoutes configures the protected API endpoints
func setupProtectedAPIRoutes(router *gin.Engine, authIntegration *Integration) <span class="cov0" title="0">{
        // Protected API routes
        api := router.Group("/api/v1")
        api.Use(authIntegration.MiddlewareManager.AuthRequired())
        
        // Create middleware helpers
        helpers := NewMiddlewareHelpers(authIntegration)
        
        // Node management endpoints
        setupNodeRoutes(api, helpers)
        
        // Model management endpoints
        setupModelRoutes(api, helpers)
        
        // Cluster management endpoints
        setupClusterRoutes(api, helpers)
        
        // Inference endpoints
        setupInferenceRoutes(api, helpers)
        
        // Monitoring endpoints
        setupMonitoringRoutes(api, helpers)
        
        // Distribution management endpoints
        setupDistributionRoutes(api, helpers)
}</span>

// setupNodeRoutes configures node management routes
func setupNodeRoutes(api *gin.RouterGroup, helpers *MiddlewareHelpers) <span class="cov0" title="0">{
        nodes := api.Group("/nodes")
        
        // List nodes - requires read permission
        nodes.GET("", helpers.RequireNodePermission("read"), func(c *gin.Context) </span><span class="cov0" title="0">{
                user := GetCurrentUser(c)
                log.Printf("User %s requested node list", user.Username)
                
                // Mock response - in real implementation, this would call the scheduler
                c.JSON(200, gin.H{
                        "nodes": []map[string]interface{}{
                                {
                                        "id":     "node-1",
                                        "status": "online",
                                        "cpu":    "50%",
                                        "memory": "60%",
                                },
                                {
                                        "id":     "node-2",
                                        "status": "online",
                                        "cpu":    "30%",
                                        "memory": "40%",
                                },
                        },
                        "total": 2,
                })
        }</span>)
        
        // Get specific node - requires read permission
        <span class="cov0" title="0">nodes.GET("/:id", helpers.RequireNodePermission("read"), func(c *gin.Context) </span><span class="cov0" title="0">{
                nodeID := c.Param("id")
                user := GetCurrentUser(c)
                log.Printf("User %s requested details for node %s", user.Username, nodeID)
                
                c.JSON(200, gin.H{
                        "node": map[string]interface{}{
                                "id":       nodeID,
                                "status":   "online",
                                "cpu":      "50%",
                                "memory":   "60%",
                                "models":   []string{"llama2", "codellama"},
                                "requests": 150,
                        },
                })
        }</span>)
        
        // Drain node - requires write permission
        <span class="cov0" title="0">nodes.POST("/:id/drain", helpers.RequireNodePermission("write"), func(c *gin.Context) </span><span class="cov0" title="0">{
                nodeID := c.Param("id")
                user := GetCurrentUser(c)
                log.Printf("User %s initiated drain for node %s", user.Username, nodeID)
                
                c.JSON(200, gin.H{
                        "message": "Node drain initiated",
                        "node_id": nodeID,
                        "status":  "draining",
                })
        }</span>)
        
        // Delete node - requires admin permission
        <span class="cov0" title="0">nodes.DELETE("/:id", helpers.RequireNodePermission("admin"), func(c *gin.Context) </span><span class="cov0" title="0">{
                nodeID := c.Param("id")
                user := GetCurrentUser(c)
                log.Printf("User %s deleted node %s", user.Username, nodeID)
                
                c.JSON(200, gin.H{
                        "message": "Node deleted successfully",
                        "node_id": nodeID,
                })
        }</span>)
}

// setupModelRoutes configures model management routes
func setupModelRoutes(api *gin.RouterGroup, helpers *MiddlewareHelpers) <span class="cov0" title="0">{
        models := api.Group("/models")
        
        // List models - requires read permission
        models.GET("", helpers.RequireModelPermission("read"), func(c *gin.Context) </span><span class="cov0" title="0">{
                user := GetCurrentUser(c)
                log.Printf("User %s requested model list", user.Username)
                
                c.JSON(200, gin.H{
                        "models": []map[string]interface{}{
                                {
                                        "name":      "llama2",
                                        "size":      "7B",
                                        "locations": []string{"node-1", "node-2"},
                                        "status":    "ready",
                                },
                                {
                                        "name":      "codellama",
                                        "size":      "13B",
                                        "locations": []string{"node-1"},
                                        "status":    "ready",
                                },
                        },
                })
        }</span>)
        
        // Download model - requires write permission
        <span class="cov0" title="0">models.POST("/:name/download", helpers.RequireModelPermission("write"), func(c *gin.Context) </span><span class="cov0" title="0">{
                modelName := c.Param("name")
                user := GetCurrentUser(c)
                log.Printf("User %s initiated download for model %s", user.Username, modelName)
                
                c.JSON(200, gin.H{
                        "message":    "Model download initiated",
                        "model_name": modelName,
                        "status":     "downloading",
                        "progress":   0,
                })
        }</span>)
        
        // Delete model - requires admin permission
        <span class="cov0" title="0">models.DELETE("/:name", helpers.RequireModelPermission("admin"), func(c *gin.Context) </span><span class="cov0" title="0">{
                modelName := c.Param("name")
                user := GetCurrentUser(c)
                log.Printf("User %s deleted model %s", user.Username, modelName)
                
                c.JSON(200, gin.H{
                        "message":    "Model deleted successfully",
                        "model_name": modelName,
                })
        }</span>)
}

// setupClusterRoutes configures cluster management routes
func setupClusterRoutes(api *gin.RouterGroup, helpers *MiddlewareHelpers) <span class="cov0" title="0">{
        cluster := api.Group("/cluster")
        
        // Get cluster status - requires read permission
        cluster.GET("/status", helpers.RequireClusterPermission("read"), func(c *gin.Context) </span><span class="cov0" title="0">{
                user := GetCurrentUser(c)
                log.Printf("User %s requested cluster status", user.Username)
                
                c.JSON(200, gin.H{
                        "status": "healthy",
                        "nodes":  2,
                        "leader": "node-1",
                        "peers":  1,
                })
        }</span>)
        
        // Join cluster - requires write permission
        <span class="cov0" title="0">cluster.POST("/join", helpers.RequireClusterPermission("write"), func(c *gin.Context) </span><span class="cov0" title="0">{
                var req map[string]interface{}
                c.ShouldBindJSON(&amp;req)
                
                user := GetCurrentUser(c)
                log.Printf("User %s initiated cluster join", user.Username)
                
                c.JSON(200, gin.H{
                        "message": "Node join initiated",
                })
        }</span>)
        
        // Leave cluster - requires admin permission
        <span class="cov0" title="0">cluster.POST("/leave", helpers.RequireClusterPermission("admin"), func(c *gin.Context) </span><span class="cov0" title="0">{
                user := GetCurrentUser(c)
                log.Printf("User %s initiated cluster leave", user.Username)
                
                c.JSON(200, gin.H{
                        "message": "Node leave initiated",
                })
        }</span>)
}

// setupInferenceRoutes configures inference routes
func setupInferenceRoutes(api *gin.RouterGroup, helpers *MiddlewareHelpers) <span class="cov0" title="0">{
        // Generate endpoint - requires write permission
        api.POST("/generate", helpers.RequireInferencePermission("write"), func(c *gin.Context) </span><span class="cov0" title="0">{
                var req map[string]interface{}
                c.ShouldBindJSON(&amp;req)
                
                user := GetCurrentUser(c)
                modelName := req["model"]
                log.Printf("User %s requested generation with model %v", user.Username, modelName)
                
                c.JSON(200, gin.H{
                        "response": "This is a generated response from the distributed Ollama system",
                        "model":    modelName,
                        "node_id":  "node-1",
                        "user":     user.Username,
                })
        }</span>)
        
        // Chat endpoint - requires write permission
        <span class="cov0" title="0">api.POST("/chat", helpers.RequireInferencePermission("write"), func(c *gin.Context) </span><span class="cov0" title="0">{
                var req map[string]interface{}
                c.ShouldBindJSON(&amp;req)
                
                user := GetCurrentUser(c)
                log.Printf("User %s initiated chat session", user.Username)
                
                c.JSON(200, gin.H{
                        "message": map[string]interface{}{
                                "role":    "assistant",
                                "content": "Hello! I'm your AI assistant powered by the distributed Ollama system.",
                        },
                        "user": user.Username,
                })
        }</span>)
        
        // Embeddings endpoint - requires write permission
        <span class="cov0" title="0">api.POST("/embeddings", helpers.RequireInferencePermission("write"), func(c *gin.Context) </span><span class="cov0" title="0">{
                var req map[string]interface{}
                c.ShouldBindJSON(&amp;req)
                
                user := GetCurrentUser(c)
                log.Printf("User %s requested embeddings", user.Username)
                
                c.JSON(200, gin.H{
                        "embeddings": []float64{0.1, 0.2, 0.3, 0.4, 0.5},
                        "model":      req["model"],
                        "user":       user.Username,
                })
        }</span>)
}

// setupMonitoringRoutes configures monitoring routes
func setupMonitoringRoutes(api *gin.RouterGroup, helpers *MiddlewareHelpers) <span class="cov0" title="0">{
        // Metrics endpoint - requires read permission
        api.GET("/metrics", helpers.RequireInferencePermission("read"), func(c *gin.Context) </span><span class="cov0" title="0">{
                user := GetCurrentUser(c)
                log.Printf("User %s requested metrics", user.Username)
                
                c.JSON(200, gin.H{
                        "metrics": map[string]interface{}{
                                "nodes_online":       2,
                                "models_loaded":      5,
                                "requests_processed": 1500,
                                "cpu_usage":          45.2,
                                "memory_usage":       62.8,
                                "network_usage":      23.1,
                        },
                        "timestamp": time.Now().Unix(),
                })
        }</span>)
        
        // Health check - no authentication required for monitoring
        <span class="cov0" title="0">api.GET("/health", func(c *gin.Context) </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{
                        "status":    "healthy",
                        "timestamp": time.Now().Unix(),
                        "version":   "1.0.0",
                })
        }</span>)
        
        // Transfers endpoint
        <span class="cov0" title="0">api.GET("/transfers", helpers.RequireInferencePermission("read"), func(c *gin.Context) </span><span class="cov0" title="0">{
                user := GetCurrentUser(c)
                log.Printf("User %s requested transfer status", user.Username)
                
                c.JSON(200, gin.H{
                        "transfers": []map[string]interface{}{
                                {
                                        "id":       "transfer-1",
                                        "model":    "llama2",
                                        "status":   "completed",
                                        "progress": 100,
                                },
                        },
                })
        }</span>)
}

// setupDistributionRoutes configures distribution management routes
func setupDistributionRoutes(api *gin.RouterGroup, helpers *MiddlewareHelpers) <span class="cov0" title="0">{
        distribution := api.Group("/distribution")
        
        // Auto-configure distribution - requires admin permission
        distribution.POST("/auto-configure", helpers.RequireClusterPermission("admin"), func(c *gin.Context) </span><span class="cov0" title="0">{
                var req map[string]interface{}
                c.ShouldBindJSON(&amp;req)
                
                user := GetCurrentUser(c)
                log.Printf("User %s configured auto-distribution", user.Username)
                
                c.JSON(200, gin.H{
                        "message": "Auto-distribution configured",
                        "enabled": req["enabled"],
                })
        }</span>)
}

// setupPublicRoutes configures public routes that don't require authentication
func setupPublicRoutes(router *gin.Engine) <span class="cov0" title="0">{
        // Serve static files for web UI
        router.Static("/static", "./web/static")
        router.StaticFile("/", "./web/index.html")
        router.StaticFile("/favicon.ico", "./web/favicon.ico")
        
        // Catch-all for SPA routing
        router.NoRoute(func(c *gin.Context) </span><span class="cov0" title="0">{
                c.File("./web/index.html")
        }</span>)
}

// DemoUsage shows how to use the authentication system programmatically
func DemoUsage() <span class="cov0" title="0">{
        // Create auth config
        cfg := &amp;config.AuthConfig{
                Enabled:     true,
                Method:      "jwt",
                TokenExpiry: 24 * time.Hour,
                SecretKey:   "demo-secret-key",
                Issuer:      "ollama-distributed",
                Audience:    "ollama-api",
        }
        
        // Create auth manager
        authManager, err := NewManager(cfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create auth manager: %v", err)
        }</span>
        <span class="cov0" title="0">defer authManager.Close()
        
        // Create a new user
        userReq := &amp;CreateUserRequest{
                Username: "demo-user",
                Email:    "demo@example.com",
                Password: "secure-password",
                Role:     RoleUser,
        }
        
        user, err := authManager.CreateUser(userReq)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create user: %v", err)
        }</span>
        
        <span class="cov0" title="0">log.Printf("Created user: %s (ID: %s)", user.Username, user.ID)
        
        // Authenticate user
        authCtx, err := authManager.Authenticate("demo-user", "secure-password", map[string]string{
                "ip_address": "127.0.0.1",
                "user_agent": "demo-client",
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to authenticate: %v", err)
        }</span>
        
        <span class="cov0" title="0">log.Printf("Authentication successful! Token: %s", authCtx.TokenString[:50]+"...")
        
        // Create API key
        apiKeyReq := &amp;CreateAPIKeyRequest{
                Name:        "Demo API Key",
                Permissions: []string{PermissionModelRead, PermissionInferenceWrite},
        }
        
        apiKey, rawKey, err := authManager.CreateAPIKey(user.ID, apiKeyReq)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create API key: %v", err)
        }</span>
        
        <span class="cov0" title="0">log.Printf("Created API key: %s (Key: %s)", apiKey.Name, rawKey[:20]+"...")
        
        // Validate API key
        apiAuthCtx, err := authManager.ValidateAPIKey(rawKey)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to validate API key: %v", err)
        }</span>
        
        <span class="cov0" title="0">log.Printf("API key validation successful for user: %s", apiAuthCtx.User.Username)
        
        // Check permissions
        hasModelRead := authManager.HasPermission(apiAuthCtx, PermissionModelRead)
        hasSystemAdmin := authManager.HasPermission(apiAuthCtx, PermissionSystemAdmin)
        
        log.Printf("User has model read permission: %v", hasModelRead)
        log.Printf("User has system admin permission: %v", hasSystemAdmin)</span>
}</pre>
		
		<pre class="file" id="file6" style="display: none">package auth

import (
        "time"

        "github.com/golang-jwt/jwt/v5"
)

// User represents a system user
type User struct {
        ID          string            `json:"id"`
        Username    string            `json:"username"`
        Email       string            `json:"email,omitempty"`
        Role        string            `json:"role"`
        Permissions []string          `json:"permissions"`
        APIKeys     []APIKey          `json:"api_keys,omitempty"`
        Metadata    map[string]string `json:"metadata,omitempty"`
        CreatedAt   time.Time         `json:"created_at"`
        UpdatedAt   time.Time         `json:"updated_at"`
        LastLoginAt *time.Time        `json:"last_login_at,omitempty"`
        Active      bool              `json:"active"`
}

// APIKey represents an API key for authentication
type APIKey struct {
        ID          string            `json:"id"`
        Name        string            `json:"name"`
        Key         string            `json:"key"`
        UserID      string            `json:"user_id"`
        Permissions []string          `json:"permissions"`
        Metadata    map[string]string `json:"metadata,omitempty"`
        ExpiresAt   *time.Time        `json:"expires_at,omitempty"`
        CreatedAt   time.Time         `json:"created_at"`
        LastUsedAt  *time.Time        `json:"last_used_at,omitempty"`
        Active      bool              `json:"active"`
}

// Session represents an authentication session
type Session struct {
        ID        string            `json:"id"`
        UserID    string            `json:"user_id"`
        TokenID   string            `json:"token_id"`
        IPAddress string            `json:"ip_address"`
        UserAgent string            `json:"user_agent"`
        Metadata  map[string]string `json:"metadata,omitempty"`
        CreatedAt time.Time         `json:"created_at"`
        ExpiresAt time.Time         `json:"expires_at"`
        Active    bool              `json:"active"`
}

// Claims represents JWT claims for the system
type Claims struct {
        UserID      string            `json:"user_id"`
        Username    string            `json:"username"`
        Email       string            `json:"email,omitempty"`
        Role        string            `json:"role"`
        Permissions []string          `json:"permissions"`
        SessionID   string            `json:"session_id,omitempty"`
        APIKeyID    string            `json:"api_key_id,omitempty"`
        Metadata    map[string]string `json:"metadata,omitempty"`
        jwt.RegisteredClaims
}

// AuthContext contains authentication information for a request
type AuthContext struct {
        User        *User     `json:"user"`
        Session     *Session  `json:"session,omitempty"`
        APIKey      *APIKey   `json:"api_key,omitempty"`
        Claims      *Claims   `json:"claims"`
        TokenString string    `json:"-"`
        Method      AuthMethod `json:"method"`
}

// AuthMethod represents the authentication method used
type AuthMethod string

const (
        AuthMethodJWT    AuthMethod = "jwt"
        AuthMethodAPIKey AuthMethod = "api_key"
        AuthMethodX509   AuthMethod = "x509"
        AuthMethodNone   AuthMethod = "none"
)

// Permission constants
const (
        PermissionNodeRead       = "node:read"
        PermissionNodeWrite      = "node:write"
        PermissionNodeAdmin      = "node:admin"
        PermissionModelRead      = "model:read"
        PermissionModelWrite     = "model:write"
        PermissionModelAdmin     = "model:admin"
        PermissionClusterRead    = "cluster:read"
        PermissionClusterWrite   = "cluster:write"
        PermissionClusterAdmin   = "cluster:admin"
        PermissionInferenceRead  = "inference:read"
        PermissionInferenceWrite = "inference:write"
        PermissionMetricsRead    = "metrics:read"
        PermissionSystemAdmin    = "system:admin"
        PermissionUserAdmin      = "user:admin"
)

// Role constants
const (
        RoleAdmin     = "admin"
        RoleOperator  = "operator"
        RoleUser      = "user"
        RoleReadOnly  = "readonly"
        RoleService   = "service"
)

// Default role permissions
var DefaultRolePermissions = map[string][]string{
        RoleAdmin: {
                PermissionSystemAdmin,
                PermissionUserAdmin,
                PermissionNodeAdmin,
                PermissionModelAdmin,
                PermissionClusterAdmin,
                PermissionInferenceWrite,
                PermissionMetricsRead,
        },
        RoleOperator: {
                PermissionNodeWrite,
                PermissionModelWrite,
                PermissionClusterWrite,
                PermissionInferenceWrite,
                PermissionMetricsRead,
        },
        RoleUser: {
                PermissionNodeRead,
                PermissionModelRead,
                PermissionClusterRead,
                PermissionInferenceWrite,
                PermissionMetricsRead,
        },
        RoleReadOnly: {
                PermissionNodeRead,
                PermissionModelRead,
                PermissionClusterRead,
                PermissionInferenceRead,
                PermissionMetricsRead,
        },
        RoleService: {
                PermissionNodeRead,
                PermissionModelRead,
                PermissionInferenceWrite,
        },
}

// AuthError represents authentication errors
type AuthError struct {
        Code    string `json:"code"`
        Message string `json:"message"`
        Details string `json:"details,omitempty"`
}

func (e AuthError) Error() string <span class="cov0" title="0">{
        if e.Details != "" </span><span class="cov0" title="0">{
                return e.Message + ": " + e.Details
        }</span>
        <span class="cov0" title="0">return e.Message</span>
}

// Common authentication errors
var (
        ErrInvalidCredentials = AuthError{
                Code:    "INVALID_CREDENTIALS",
                Message: "Invalid credentials provided",
        }
        ErrTokenExpired = AuthError{
                Code:    "TOKEN_EXPIRED",
                Message: "Authentication token has expired",
        }
        ErrTokenInvalid = AuthError{
                Code:    "TOKEN_INVALID",
                Message: "Authentication token is invalid",
        }
        ErrTokenBlacklisted = AuthError{
                Code:    "TOKEN_BLACKLISTED",
                Message: "Authentication token has been revoked",
        }
        ErrInsufficientPermissions = AuthError{
                Code:    "INSUFFICIENT_PERMISSIONS",
                Message: "Insufficient permissions for this operation",
        }
        ErrUserNotFound = AuthError{
                Code:    "USER_NOT_FOUND",
                Message: "User not found",
        }
        ErrUserInactive = AuthError{
                Code:    "USER_INACTIVE",
                Message: "User account is inactive",
        }
        ErrAPIKeyNotFound = AuthError{
                Code:    "API_KEY_NOT_FOUND",
                Message: "API key not found",
        }
        ErrAPIKeyInactive = AuthError{
                Code:    "API_KEY_INACTIVE",
                Message: "API key is inactive",
        }
        ErrAPIKeyExpired = AuthError{
                Code:    "API_KEY_EXPIRED",
                Message: "API key has expired",
        }
        ErrSessionNotFound = AuthError{
                Code:    "SESSION_NOT_FOUND",
                Message: "Session not found",
        }
        ErrSessionExpired = AuthError{
                Code:    "SESSION_EXPIRED",
                Message: "Session has expired",
        }
)

// LoginRequest represents a login request
type LoginRequest struct {
        Username string `json:"username" binding:"required"`
        Password string `json:"password" binding:"required"`
        Metadata map[string]string `json:"metadata,omitempty"`
}

// LoginResponse represents a login response
type LoginResponse struct {
        Token     string    `json:"token"`
        ExpiresAt time.Time `json:"expires_at"`
        User      *User     `json:"user"`
        SessionID string    `json:"session_id"`
}

// RefreshRequest represents a token refresh request
type RefreshRequest struct {
        Token string `json:"token" binding:"required"`
}

// CreateAPIKeyRequest represents an API key creation request
type CreateAPIKeyRequest struct {
        Name        string            `json:"name" binding:"required"`
        Permissions []string          `json:"permissions,omitempty"`
        ExpiresAt   *time.Time        `json:"expires_at,omitempty"`
        Metadata    map[string]string `json:"metadata,omitempty"`
}

// CreateAPIKeyResponse represents an API key creation response
type CreateAPIKeyResponse struct {
        APIKey *APIKey `json:"api_key"`
        Key    string  `json:"key"` // Only returned once during creation
}

// CreateUserRequest represents a user creation request
type CreateUserRequest struct {
        Username    string            `json:"username" binding:"required"`
        Email       string            `json:"email,omitempty"`
        Password    string            `json:"password" binding:"required"`
        Role        string            `json:"role" binding:"required"`
        Permissions []string          `json:"permissions,omitempty"`
        Metadata    map[string]string `json:"metadata,omitempty"`
}

// UpdateUserRequest represents a user update request
type UpdateUserRequest struct {
        Email       *string           `json:"email,omitempty"`
        Role        *string           `json:"role,omitempty"`
        Permissions []string          `json:"permissions,omitempty"`
        Metadata    map[string]string `json:"metadata,omitempty"`
        Active      *bool             `json:"active,omitempty"`
}

// ChangePasswordRequest represents a password change request
type ChangePasswordRequest struct {
        CurrentPassword string `json:"current_password" binding:"required"`
        NewPassword     string `json:"new_password" binding:"required"`
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
