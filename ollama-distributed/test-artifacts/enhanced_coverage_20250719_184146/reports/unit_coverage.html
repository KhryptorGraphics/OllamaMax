
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>auth: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/ollama/ollama-distributed/internal/auth/auth.go (70.5%)</option>
				
				<option value="file1">github.com/ollama/ollama-distributed/internal/auth/integration.go (0.0%)</option>
				
				<option value="file2">github.com/ollama/ollama-distributed/internal/auth/jwt.go (36.7%)</option>
				
				<option value="file3">github.com/ollama/ollama-distributed/internal/auth/middleware.go (0.0%)</option>
				
				<option value="file4">github.com/ollama/ollama-distributed/internal/auth/routes.go (0.0%)</option>
				
				<option value="file5">github.com/ollama/ollama-distributed/internal/auth/server_example.go (0.0%)</option>
				
				<option value="file6">github.com/ollama/ollama-distributed/internal/auth/types.go (0.0%)</option>
				
				<option value="file7">github.com/ollama/ollama-distributed/internal/config/config.go (0.0%)</option>
				
				<option value="file8">github.com/ollama/ollama-distributed/internal/metrics/metrics.go (0.0%)</option>
				
				<option value="file9">github.com/ollama/ollama-distributed/pkg/config/types.go (0.0%)</option>
				
				<option value="file10">github.com/ollama/ollama-distributed/pkg/integration/ollama_client_stubs.go (0.0%)</option>
				
				<option value="file11">github.com/ollama/ollama-distributed/pkg/models/cas_store.go (0.0%)</option>
				
				<option value="file12">github.com/ollama/ollama-distributed/pkg/models/delta_tracker.go (0.0%)</option>
				
				<option value="file13">github.com/ollama/ollama-distributed/pkg/models/distributed_model_manager.go (0.0%)</option>
				
				<option value="file14">github.com/ollama/ollama-distributed/pkg/models/distribution.go (0.0%)</option>
				
				<option value="file15">github.com/ollama/ollama-distributed/pkg/models/ollama_integration.go (0.0%)</option>
				
				<option value="file16">github.com/ollama/ollama-distributed/pkg/models/replication_manager.go (0.0%)</option>
				
				<option value="file17">github.com/ollama/ollama-distributed/pkg/models/sync_manager.go (0.0%)</option>
				
				<option value="file18">github.com/ollama/ollama-distributed/pkg/p2p/discovery/discovery.go (0.0%)</option>
				
				<option value="file19">github.com/ollama/ollama-distributed/pkg/p2p/discovery/strategies.go (0.0%)</option>
				
				<option value="file20">github.com/ollama/ollama-distributed/pkg/p2p/host/host.go (0.0%)</option>
				
				<option value="file21">github.com/ollama/ollama-distributed/pkg/p2p/resources/advertiser.go (0.0%)</option>
				
				<option value="file22">github.com/ollama/ollama-distributed/pkg/p2p/resources/discovery_types.go (0.0%)</option>
				
				<option value="file23">github.com/ollama/ollama-distributed/pkg/p2p/routing/content.go (0.0%)</option>
				
				<option value="file24">github.com/ollama/ollama-distributed/pkg/p2p/security/security.go (0.0%)</option>
				
				<option value="file25">github.com/ollama/ollama-distributed/pkg/scheduler/engine.go (0.0%)</option>
				
				<option value="file26">github.com/ollama/ollama-distributed/pkg/scheduler/fault_tolerance/fault_tolerance_manager.go (0.0%)</option>
				
				<option value="file27">github.com/ollama/ollama-distributed/pkg/scheduler/fault_tolerance/health_checker_impls.go (0.0%)</option>
				
				<option value="file28">github.com/ollama/ollama-distributed/pkg/scheduler/fault_tolerance/recovery_strategies.go (0.0%)</option>
				
				<option value="file29">github.com/ollama/ollama-distributed/pkg/scheduler/loadbalancer/algorithms.go (0.0%)</option>
				
				<option value="file30">github.com/ollama/ollama-distributed/pkg/scheduler/loadbalancer/intelligent_load_balancer.go (0.0%)</option>
				
				<option value="file31">github.com/ollama/ollama-distributed/pkg/scheduler/orchestration/aggregation_strategies.go (0.0%)</option>
				
				<option value="file32">github.com/ollama/ollama-distributed/pkg/scheduler/orchestration/orchestration_engine.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package auth

import (
        "crypto/rand"
        "crypto/sha256"
        "crypto/subtle"
        "encoding/hex"
        "fmt"
        "sync"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "github.com/ollama/ollama-distributed/internal/config"
        "golang.org/x/crypto/bcrypt"
)

// Manager handles all authentication operations
type Manager struct {
        config *config.AuthConfig
        
        // JWT signing key
        signingKey []byte
        
        // In-memory stores (in production, these would be backed by persistent storage)
        users          map[string]*User
        apiKeys        map[string]*APIKey
        sessions       map[string]*Session
        blacklistCache map[string]time.Time
        
        // Password hasher
        bcryptCost int
        
        // Mutex for thread safety
        mu sync.RWMutex
        
        // Background cleanup
        stopCleanup chan struct{}
}

// NewManager creates a new authentication manager
func NewManager(cfg *config.AuthConfig) (*Manager, error) <span class="cov6" title="7">{
        if cfg == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("auth config is required")
        }</span>
        
        // Generate or use provided signing key
        <span class="cov6" title="7">signingKey := []byte(cfg.SecretKey)
        if len(signingKey) == 0 </span><span class="cov0" title="0">{
                // Generate a random signing key
                signingKey = make([]byte, 32)
                if _, err := rand.Read(signingKey); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to generate signing key: %w", err)
                }</span>
        }
        
        <span class="cov6" title="7">manager := &amp;Manager{
                config:         cfg,
                signingKey:     signingKey,
                users:          make(map[string]*User),
                apiKeys:        make(map[string]*APIKey),
                sessions:       make(map[string]*Session),
                blacklistCache: make(map[string]time.Time),
                bcryptCost:     bcrypt.DefaultCost,
                stopCleanup:    make(chan struct{}),
        }
        
        // Create default admin user if none exists
        if err := manager.createDefaultAdmin(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create default admin: %w", err)
        }</span>
        
        // Start background cleanup routines
        <span class="cov6" title="7">go manager.cleanupExpiredSessions()
        go manager.cleanupBlacklist()
        
        return manager, nil</span>
}

// Close gracefully shuts down the auth manager
func (m *Manager) Close() <span class="cov6" title="7">{
        close(m.stopCleanup)
}</span>

// createDefaultAdmin creates a default admin user if no users exist
func (m *Manager) createDefaultAdmin() error <span class="cov6" title="7">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        // Check if any users exist
        if len(m.users) &gt; 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        // Create default admin user
        <span class="cov6" title="7">hashedPassword, err := bcrypt.GenerateFromPassword([]byte("admin123"), m.bcryptCost)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to hash default password: %w", err)
        }</span>
        
        <span class="cov6" title="7">adminUser := &amp;User{
                ID:          generateID(),
                Username:    "admin",
                Email:       "admin@localhost",
                Role:        RoleAdmin,
                Permissions: DefaultRolePermissions[RoleAdmin],
                Metadata: map[string]string{
                        "password_hash": string(hashedPassword),
                        "created_by":    "system",
                },
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
                Active:    true,
        }
        
        m.users[adminUser.ID] = adminUser
        
        fmt.Printf("Created default admin user (username: admin, password: admin123)\n")
        fmt.Printf("WARNING: Please change the default password immediately!\n")
        
        return nil</span>
}

// Authenticate validates credentials and returns an auth context
func (m *Manager) Authenticate(username, password string, metadata map[string]string) (*AuthContext, error) <span class="cov5" title="5">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        
        // Find user by username
        var user *User
        for _, u := range m.users </span><span class="cov6" title="6">{
                if u.Username == username &amp;&amp; u.Active </span><span class="cov5" title="5">{
                        user = u
                        break</span>
                }
        }
        
        <span class="cov5" title="5">if user == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidCredentials
        }</span>
        
        // Verify password
        <span class="cov5" title="5">passwordHash := user.Metadata["password_hash"]
        if err := bcrypt.CompareHashAndPassword([]byte(passwordHash), []byte(password)); err != nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidCredentials
        }</span>
        
        // Update last login
        <span class="cov5" title="5">now := time.Now()
        user.LastLoginAt = &amp;now
        user.UpdatedAt = now
        
        // Create session
        session := &amp;Session{
                ID:        generateID(),
                UserID:    user.ID,
                IPAddress: metadata["ip_address"],
                UserAgent: metadata["user_agent"],
                Metadata:  metadata,
                CreatedAt: now,
                ExpiresAt: now.Add(m.config.TokenExpiry),
                Active:    true,
        }
        
        m.sessions[session.ID] = session
        
        // Generate JWT token
        claims := &amp;Claims{
                UserID:      user.ID,
                Username:    user.Username,
                Email:       user.Email,
                Role:        user.Role,
                Permissions: user.Permissions,
                SessionID:   session.ID,
                Metadata:    user.Metadata,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(session.ExpiresAt),
                        IssuedAt:  jwt.NewNumericDate(now),
                        NotBefore: jwt.NewNumericDate(now),
                        Issuer:    m.config.Issuer,
                        Subject:   user.ID,
                        ID:        generateID(),
                        Audience:  []string{m.config.Audience},
                },
        }
        
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        tokenString, err := token.SignedString(m.signingKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to sign token: %w", err)
        }</span>
        
        <span class="cov5" title="5">session.TokenID = claims.ID
        
        return &amp;AuthContext{
                User:        user,
                Session:     session,
                Claims:      claims,
                TokenString: tokenString,
                Method:      AuthMethodJWT,
        }, nil</span>
}

// ValidateToken validates a JWT token and returns the auth context
func (m *Manager) ValidateToken(tokenString string) (*AuthContext, error) <span class="cov4" title="3">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov4" title="3">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov4" title="3">return m.signingKey, nil</span>
        })
        
        <span class="cov4" title="3">if err != nil </span><span class="cov0" title="0">{
                return nil, ErrTokenInvalid
        }</span>
        
        <span class="cov4" title="3">claims, ok := token.Claims.(*Claims)
        if !ok || !token.Valid </span><span class="cov0" title="0">{
                return nil, ErrTokenInvalid
        }</span>
        
        // Check if token is blacklisted
        <span class="cov4" title="3">if m.isTokenBlacklisted(claims.ID) </span><span class="cov1" title="1">{
                return nil, ErrTokenBlacklisted
        }</span>
        
        <span class="cov2" title="2">m.mu.RLock()
        defer m.mu.RUnlock()
        
        // Get user
        user, exists := m.users[claims.UserID]
        if !exists || !user.Active </span><span class="cov0" title="0">{
                return nil, ErrUserNotFound
        }</span>
        
        // Get session if available
        <span class="cov2" title="2">var session *Session
        if claims.SessionID != "" </span><span class="cov2" title="2">{
                if s, exists := m.sessions[claims.SessionID]; exists &amp;&amp; s.Active </span><span class="cov2" title="2">{
                        if time.Now().After(s.ExpiresAt) </span><span class="cov0" title="0">{
                                return nil, ErrSessionExpired
                        }</span>
                        <span class="cov2" title="2">session = s</span>
                }
        }
        
        <span class="cov2" title="2">return &amp;AuthContext{
                User:        user,
                Session:     session,
                Claims:      claims,
                TokenString: tokenString,
                Method:      AuthMethodJWT,
        }, nil</span>
}

// ValidateAPIKey validates an API key and returns the auth context
func (m *Manager) ValidateAPIKey(key string) (*AuthContext, error) <span class="cov1" title="1">{
        keyHash := hashAPIKey(key)
        
        m.mu.RLock()
        defer m.mu.RUnlock()
        
        // Find API key
        var apiKey *APIKey
        for _, ak := range m.apiKeys </span><span class="cov1" title="1">{
                if subtle.ConstantTimeCompare([]byte(ak.Key), []byte(keyHash)) == 1 &amp;&amp; ak.Active </span><span class="cov1" title="1">{
                        apiKey = ak
                        break</span>
                }
        }
        
        <span class="cov1" title="1">if apiKey == nil </span><span class="cov0" title="0">{
                return nil, ErrAPIKeyNotFound
        }</span>
        
        // Check expiration
        <span class="cov1" title="1">if apiKey.ExpiresAt != nil &amp;&amp; time.Now().After(*apiKey.ExpiresAt) </span><span class="cov0" title="0">{
                return nil, ErrAPIKeyExpired
        }</span>
        
        // Get user
        <span class="cov1" title="1">user, exists := m.users[apiKey.UserID]
        if !exists || !user.Active </span><span class="cov0" title="0">{
                return nil, ErrUserNotFound
        }</span>
        
        // Update last used
        <span class="cov1" title="1">now := time.Now()
        apiKey.LastUsedAt = &amp;now
        
        return &amp;AuthContext{
                User:   user,
                APIKey: apiKey,
                Method: AuthMethodAPIKey,
        }, nil</span>
}

// CreateUser creates a new user
func (m *Manager) CreateUser(req *CreateUserRequest) (*User, error) <span class="cov4" title="3">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        // Check if username already exists
        for _, u := range m.users </span><span class="cov4" title="3">{
                if u.Username == req.Username </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("username already exists")
                }</span>
        }
        
        // Hash password
        <span class="cov4" title="3">hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), m.bcryptCost)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to hash password: %w", err)
        }</span>
        
        // Set permissions based on role if not provided
        <span class="cov4" title="3">permissions := req.Permissions
        if len(permissions) == 0 </span><span class="cov2" title="2">{
                if rolePerms, exists := DefaultRolePermissions[req.Role]; exists </span><span class="cov2" title="2">{
                        permissions = rolePerms
                }</span>
        }
        
        // Create user
        <span class="cov4" title="3">user := &amp;User{
                ID:          generateID(),
                Username:    req.Username,
                Email:       req.Email,
                Role:        req.Role,
                Permissions: permissions,
                Metadata: map[string]string{
                        "password_hash": string(hashedPassword),
                },
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
                Active:    true,
        }
        
        // Add custom metadata
        for k, v := range req.Metadata </span><span class="cov0" title="0">{
                user.Metadata[k] = v
        }</span>
        
        <span class="cov4" title="3">m.users[user.ID] = user
        
        return user, nil</span>
}

// CreateAPIKey creates a new API key for a user
func (m *Manager) CreateAPIKey(userID string, req *CreateAPIKeyRequest) (*APIKey, string, error) <span class="cov1" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        // Check if user exists
        user, exists := m.users[userID]
        if !exists || !user.Active </span><span class="cov0" title="0">{
                return nil, "", ErrUserNotFound
        }</span>
        
        // Generate API key
        <span class="cov1" title="1">rawKey := generateAPIKey()
        keyHash := hashAPIKey(rawKey)
        
        // Set permissions
        permissions := req.Permissions
        if len(permissions) == 0 </span><span class="cov0" title="0">{
                permissions = user.Permissions
        }</span>
        
        <span class="cov1" title="1">apiKey := &amp;APIKey{
                ID:          generateID(),
                Name:        req.Name,
                Key:         keyHash,
                UserID:      userID,
                Permissions: permissions,
                Metadata:    req.Metadata,
                ExpiresAt:   req.ExpiresAt,
                CreatedAt:   time.Now(),
                Active:      true,
        }
        
        if apiKey.Metadata == nil </span><span class="cov1" title="1">{
                apiKey.Metadata = make(map[string]string)
        }</span>
        
        <span class="cov1" title="1">m.apiKeys[apiKey.ID] = apiKey
        
        return apiKey, rawKey, nil</span>
}

// RevokeToken adds a token to the blacklist
func (m *Manager) RevokeToken(tokenID string, expiry time.Time) <span class="cov1" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        m.blacklistCache[tokenID] = expiry
}</span>

// RevokeSession revokes a session
func (m *Manager) RevokeSession(sessionID string) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        session, exists := m.sessions[sessionID]
        if !exists </span><span class="cov0" title="0">{
                return ErrSessionNotFound
        }</span>
        
        <span class="cov0" title="0">session.Active = false
        
        // Also blacklist the associated token
        if session.TokenID != "" </span><span class="cov0" title="0">{
                m.blacklistCache[session.TokenID] = session.ExpiresAt
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// RevokeAPIKey revokes an API key
func (m *Manager) RevokeAPIKey(keyID string) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        apiKey, exists := m.apiKeys[keyID]
        if !exists </span><span class="cov0" title="0">{
                return ErrAPIKeyNotFound
        }</span>
        
        <span class="cov0" title="0">apiKey.Active = false
        
        return nil</span>
}

// HasPermission checks if the auth context has a specific permission
func (m *Manager) HasPermission(ctx *AuthContext, permission string) bool <span class="cov5" title="5">{
        if ctx == nil || ctx.User == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // Admin role has all permissions
        <span class="cov5" title="5">if ctx.User.Role == RoleAdmin </span><span class="cov2" title="2">{
                return true
        }</span>
        
        // Check user permissions
        <span class="cov4" title="3">for _, perm := range ctx.User.Permissions </span><span class="cov5" title="5">{
                if perm == permission || perm == PermissionSystemAdmin </span><span class="cov2" title="2">{
                        return true
                }</span>
        }
        
        // Check API key permissions if using API key auth
        <span class="cov1" title="1">if ctx.Method == AuthMethodAPIKey &amp;&amp; ctx.APIKey != nil </span><span class="cov0" title="0">{
                for _, perm := range ctx.APIKey.Permissions </span><span class="cov0" title="0">{
                        if perm == permission || perm == PermissionSystemAdmin </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        
        <span class="cov1" title="1">return false</span>
}

// isTokenBlacklisted checks if a token is blacklisted
func (m *Manager) isTokenBlacklisted(tokenID string) bool <span class="cov4" title="3">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        
        expiry, exists := m.blacklistCache[tokenID]
        if !exists </span><span class="cov2" title="2">{
                return false
        }</span>
        
        // Check if blacklist entry has expired
        <span class="cov1" title="1">if time.Now().After(expiry) </span><span class="cov0" title="0">{
                delete(m.blacklistCache, tokenID)
                return false
        }</span>
        
        <span class="cov1" title="1">return true</span>
}

// Background cleanup routines
func (m *Manager) cleanupExpiredSessions() <span class="cov6" title="7">{
        ticker := time.NewTicker(30 * time.Minute)
        defer ticker.Stop()
        
        for </span><span class="cov6" title="7">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        m.mu.Lock()
                        now := time.Now()
                        for id, session := range m.sessions </span><span class="cov0" title="0">{
                                if now.After(session.ExpiresAt) </span><span class="cov0" title="0">{
                                        delete(m.sessions, id)
                                }</span>
                        }
                        <span class="cov0" title="0">m.mu.Unlock()</span>
                case &lt;-m.stopCleanup:<span class="cov6" title="7">
                        return</span>
                }
        }
}

func (m *Manager) cleanupBlacklist() <span class="cov6" title="7">{
        ticker := time.NewTicker(time.Hour)
        defer ticker.Stop()
        
        for </span><span class="cov6" title="7">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        m.mu.Lock()
                        now := time.Now()
                        for tokenID, expiry := range m.blacklistCache </span><span class="cov0" title="0">{
                                if now.After(expiry) </span><span class="cov0" title="0">{
                                        delete(m.blacklistCache, tokenID)
                                }</span>
                        }
                        <span class="cov0" title="0">m.mu.Unlock()</span>
                case &lt;-m.stopCleanup:<span class="cov6" title="7">
                        return</span>
                }
        }
}

// Utility functions
func generateID() string <span class="cov10" title="24">{
        bytes := make([]byte, 16)
        rand.Read(bytes)
        return hex.EncodeToString(bytes)
}</span>

func generateAPIKey() string <span class="cov2" title="2">{
        bytes := make([]byte, 32)
        rand.Read(bytes)
        return "ok_" + hex.EncodeToString(bytes)
}</span>

func hashAPIKey(key string) string <span class="cov4" title="3">{
        hash := sha256.Sum256([]byte(key))
        return hex.EncodeToString(hash[:])
}</pre>
		
		<pre class="file" id="file1" style="display: none">package auth

import (
        "fmt"
        "log"

        "github.com/gin-gonic/gin"
        "github.com/ollama/ollama-distributed/internal/config"
)

// Integration provides easy integration with the existing API server
type Integration struct {
        AuthManager       *Manager
        JWTManager        *JWTManager
        MiddlewareManager *MiddlewareManager
        Routes            *Routes
}

// NewIntegration creates a complete authentication integration
func NewIntegration(cfg *config.AuthConfig) (*Integration, error) <span class="cov0" title="0">{
        // Create auth manager
        authManager, err := NewManager(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create auth manager: %w", err)
        }</span>
        
        // Create JWT manager
        <span class="cov0" title="0">jwtManager, err := NewJWTManager(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create JWT manager: %w", err)
        }</span>
        
        // Create middleware manager
        <span class="cov0" title="0">middlewareManager := NewMiddlewareManager(authManager, jwtManager, cfg)
        
        // Create routes
        routes := NewRoutes(authManager, jwtManager, middlewareManager)
        
        return &amp;Integration{
                AuthManager:       authManager,
                JWTManager:        jwtManager,
                MiddlewareManager: middlewareManager,
                Routes:            routes,
        }, nil</span>
}

// SetupRouter configures a Gin router with authentication
func (i *Integration) SetupRouter() *gin.Engine <span class="cov0" title="0">{
        router := gin.New()
        
        // Register authentication routes
        i.Routes.RegisterRoutes(router)
        
        return router
}</span>

// ProtectAPIRoutes adds authentication to existing API routes
func (i *Integration) ProtectAPIRoutes(router *gin.Engine) <span class="cov0" title="0">{
        // Apply authentication middleware to protected API routes
        api := router.Group("/api/v1")
        api.Use(i.MiddlewareManager.AuthRequired())
        
        // Node management - requires node permissions
        nodeRoutes := api.Group("/nodes")
        nodeRoutes.Use(i.MiddlewareManager.RequireAnyPermission(
                PermissionNodeRead,
                PermissionNodeWrite,
                PermissionNodeAdmin,
        ))
        
        // Model management - requires model permissions
        modelRoutes := api.Group("/models")
        modelRoutes.Use(i.MiddlewareManager.RequireAnyPermission(
                PermissionModelRead,
                PermissionModelWrite,
                PermissionModelAdmin,
        ))
        
        // Cluster management - requires cluster permissions
        clusterRoutes := api.Group("/cluster")
        clusterRoutes.Use(i.MiddlewareManager.RequireAnyPermission(
                PermissionClusterRead,
                PermissionClusterWrite,
                PermissionClusterAdmin,
        ))
        
        // Inference - requires inference permissions
        inferenceRoutes := api.Group("/")
        inferenceRoutes.Use(i.MiddlewareManager.RequireAnyPermission(
                PermissionInferenceRead,
                PermissionInferenceWrite,
        ))
        
        // Metrics - requires metrics permissions
        metricsRoutes := api.Group("/metrics")
        metricsRoutes.Use(i.MiddlewareManager.RequirePermission(PermissionMetricsRead))
}</span>

// CreateServiceToken creates a service token for internal communication
func (i *Integration) CreateServiceToken(serviceID, serviceName string) (string, error) <span class="cov0" title="0">{
        permissions := []string{
                PermissionNodeRead,
                PermissionModelRead,
                PermissionInferenceWrite,
                PermissionClusterRead,
        }
        
        return i.JWTManager.GenerateServiceToken(serviceID, serviceName, permissions)
}</span>

// CreateAdminToken creates an admin token for administrative tasks
func (i *Integration) CreateAdminToken(adminID, adminName string) (string, error) <span class="cov0" title="0">{
        permissions := DefaultRolePermissions[RoleAdmin]
        return i.JWTManager.GenerateServiceToken(adminID, adminName, permissions)
}</span>

// Close gracefully shuts down the authentication system
func (i *Integration) Close() <span class="cov0" title="0">{
        i.AuthManager.Close()
}</span>

// Example integration with existing server
func ExampleIntegration() <span class="cov0" title="0">{
        // Load configuration
        cfg := &amp;config.AuthConfig{
                Enabled:     true,
                Method:      "jwt",
                TokenExpiry: 24 * 3600, // 24 hours in seconds
                SecretKey:   "your-secret-key",
                Issuer:      "ollama-distributed",
                Audience:    "ollama-api",
        }
        
        // Create authentication integration
        authIntegration, err := NewIntegration(cfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create auth integration: %v", err)
        }</span>
        <span class="cov0" title="0">defer authIntegration.Close()
        
        // Setup router with authentication
        router := gin.New()
        
        // Register authentication routes
        authIntegration.Routes.RegisterRoutes(router)
        
        // Protect existing API routes
        authIntegration.ProtectAPIRoutes(router)
        
        // Example: Add a protected endpoint
        protected := router.Group("/api/v1/protected")
        protected.Use(authIntegration.MiddlewareManager.AuthRequired())
        protected.Use(authIntegration.MiddlewareManager.RequirePermission(PermissionSystemAdmin))
        </span><span class="cov0" title="0">{
                protected.GET("/admin-only", func(c *gin.Context) </span><span class="cov0" title="0">{
                        user := GetCurrentUser(c)
                        c.JSON(200, gin.H{
                                "message": "This is an admin-only endpoint",
                                "user":    user.Username,
                                "role":    user.Role,
                        })
                }</span>)
        }
        
        // Example: Create a service token
        <span class="cov0" title="0">serviceToken, err := authIntegration.CreateServiceToken("node-1", "Ollama Node 1")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to create service token: %v", err)
        }</span> else<span class="cov0" title="0"> {
                log.Printf("Service token created: %s", serviceToken)
        }</span>
        
        // Start server
        <span class="cov0" title="0">log.Println("Starting server with authentication on :8080")
        router.Run(":8080")</span>
}

// MiddlewareHelpers provides helper functions for common middleware patterns
type MiddlewareHelpers struct {
        integration *Integration
}

// NewMiddlewareHelpers creates middleware helpers
func NewMiddlewareHelpers(integration *Integration) *MiddlewareHelpers <span class="cov0" title="0">{
        return &amp;MiddlewareHelpers{integration: integration}
}</span>

// RequireNodePermission creates middleware for node operations
func (mh *MiddlewareHelpers) RequireNodePermission(operation string) gin.HandlerFunc <span class="cov0" title="0">{
        switch operation </span>{
        case "read":<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionNodeRead)</span>
        case "write":<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionNodeWrite)</span>
        case "admin":<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionNodeAdmin)</span>
        default:<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionNodeRead)</span>
        }
}

// RequireModelPermission creates middleware for model operations
func (mh *MiddlewareHelpers) RequireModelPermission(operation string) gin.HandlerFunc <span class="cov0" title="0">{
        switch operation </span>{
        case "read":<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionModelRead)</span>
        case "write":<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionModelWrite)</span>
        case "admin":<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionModelAdmin)</span>
        default:<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionModelRead)</span>
        }
}

// RequireClusterPermission creates middleware for cluster operations
func (mh *MiddlewareHelpers) RequireClusterPermission(operation string) gin.HandlerFunc <span class="cov0" title="0">{
        switch operation </span>{
        case "read":<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionClusterRead)</span>
        case "write":<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionClusterWrite)</span>
        case "admin":<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionClusterAdmin)</span>
        default:<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionClusterRead)</span>
        }
}

// RequireInferencePermission creates middleware for inference operations
func (mh *MiddlewareHelpers) RequireInferencePermission(operation string) gin.HandlerFunc <span class="cov0" title="0">{
        switch operation </span>{
        case "read":<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionInferenceRead)</span>
        case "write":<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionInferenceWrite)</span>
        default:<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionInferenceRead)</span>
        }
}

// Example usage in existing API handlers
func ExampleAPIIntegration(authIntegration *Integration) <span class="cov0" title="0">{
        router := gin.New()
        helpers := NewMiddlewareHelpers(authIntegration)
        
        // Register auth routes
        authIntegration.Routes.RegisterRoutes(router)
        
        // Protected API routes
        api := router.Group("/api/v1")
        api.Use(authIntegration.MiddlewareManager.AuthRequired())
        
        // Node management with granular permissions
        nodes := api.Group("/nodes")
        </span><span class="cov0" title="0">{
                nodes.GET("", helpers.RequireNodePermission("read"), func(c *gin.Context) </span><span class="cov0" title="0">{
                        // Get nodes logic
                        c.JSON(200, gin.H{"nodes": []string{}})
                }</span>)
                
                <span class="cov0" title="0">nodes.POST("", helpers.RequireNodePermission("write"), func(c *gin.Context) </span><span class="cov0" title="0">{
                        // Create node logic
                        c.JSON(201, gin.H{"message": "Node created"})
                }</span>)
                
                <span class="cov0" title="0">nodes.DELETE("/:id", helpers.RequireNodePermission("admin"), func(c *gin.Context) </span><span class="cov0" title="0">{
                        // Delete node logic
                        c.JSON(200, gin.H{"message": "Node deleted"})
                }</span>)
        }
        
        // Model management with granular permissions
        <span class="cov0" title="0">models := api.Group("/models")
        </span><span class="cov0" title="0">{
                models.GET("", helpers.RequireModelPermission("read"), func(c *gin.Context) </span><span class="cov0" title="0">{
                        // Get models logic
                        c.JSON(200, gin.H{"models": []string{}})
                }</span>)
                
                <span class="cov0" title="0">models.POST("/:name/download", helpers.RequireModelPermission("write"), func(c *gin.Context) </span><span class="cov0" title="0">{
                        // Download model logic
                        c.JSON(200, gin.H{"message": "Download started"})
                }</span>)
                
                <span class="cov0" title="0">models.DELETE("/:name", helpers.RequireModelPermission("admin"), func(c *gin.Context) </span><span class="cov0" title="0">{
                        // Delete model logic
                        c.JSON(200, gin.H{"message": "Model deleted"})
                }</span>)
        }
        
        // Inference endpoints
        <span class="cov0" title="0">inference := api.Group("/")
        </span><span class="cov0" title="0">{
                inference.POST("/generate", helpers.RequireInferencePermission("write"), func(c *gin.Context) </span><span class="cov0" title="0">{
                        // Generate logic
                        user := GetCurrentUser(c)
                        c.JSON(200, gin.H{
                                "response": "Generated text",
                                "user":     user.Username,
                        })
                }</span>)
                
                <span class="cov0" title="0">inference.POST("/chat", helpers.RequireInferencePermission("write"), func(c *gin.Context) </span><span class="cov0" title="0">{
                        // Chat logic
                        c.JSON(200, gin.H{"response": "Chat response"})
                }</span>)
        }
        
        // Metrics (read-only)
        <span class="cov0" title="0">api.GET("/metrics", helpers.RequireInferencePermission("read"), func(c *gin.Context) </span><span class="cov0" title="0">{
                // Metrics logic
                c.JSON(200, gin.H{"metrics": map[string]interface{}{}})
        }</span>)
}</pre>
		
		<pre class="file" id="file2" style="display: none">package auth

import (
        "crypto/rand"
        "crypto/rsa"
        "fmt"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "github.com/ollama/ollama-distributed/internal/config"
)

// JWTManager handles JWT token operations with advanced features
type JWTManager struct {
        config     *config.AuthConfig
        privateKey *rsa.PrivateKey
        publicKey  *rsa.PublicKey
        
        // Token blacklist and refresh tokens
        blacklist    map[string]time.Time
        refreshTokens map[string]*RefreshToken
}

// RefreshToken represents a refresh token
type RefreshToken struct {
        ID        string    `json:"id"`
        UserID    string    `json:"user_id"`
        TokenHash string    `json:"token_hash"`
        ExpiresAt time.Time `json:"expires_at"`
        CreatedAt time.Time `json:"created_at"`
        Used      bool      `json:"used"`
}

// TokenPair represents an access token and refresh token pair
type TokenPair struct {
        AccessToken  string    `json:"access_token"`
        RefreshToken string    `json:"refresh_token"`
        ExpiresAt    time.Time `json:"expires_at"`
        TokenType    string    `json:"token_type"`
}

// NewJWTManager creates a new JWT manager
func NewJWTManager(cfg *config.AuthConfig) (*JWTManager, error) <span class="cov10" title="2">{
        // Generate RSA key pair for signing
        privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate RSA key: %w", err)
        }</span>
        
        <span class="cov10" title="2">return &amp;JWTManager{
                config:        cfg,
                privateKey:    privateKey,
                publicKey:     &amp;privateKey.PublicKey,
                blacklist:     make(map[string]time.Time),
                refreshTokens: make(map[string]*RefreshToken),
        }, nil</span>
}

// GenerateTokenPair generates an access token and refresh token pair
func (jm *JWTManager) GenerateTokenPair(user *User, sessionID string, metadata map[string]string) (*TokenPair, error) <span class="cov1" title="1">{
        now := time.Now()
        accessTokenExpiry := now.Add(jm.config.TokenExpiry)
        refreshTokenExpiry := now.Add(7 * 24 * time.Hour) // 7 days for refresh token
        
        // Create access token claims
        accessClaims := &amp;Claims{
                UserID:      user.ID,
                Username:    user.Username,
                Email:       user.Email,
                Role:        user.Role,
                Permissions: user.Permissions,
                SessionID:   sessionID,
                Metadata:    metadata,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(accessTokenExpiry),
                        IssuedAt:  jwt.NewNumericDate(now),
                        NotBefore: jwt.NewNumericDate(now),
                        Issuer:    jm.config.Issuer,
                        Subject:   user.ID,
                        ID:        generateID(),
                        Audience:  []string{jm.config.Audience},
                },
        }
        
        // Sign access token
        accessToken := jwt.NewWithClaims(jwt.SigningMethodRS256, accessClaims)
        accessTokenString, err := accessToken.SignedString(jm.privateKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to sign access token: %w", err)
        }</span>
        
        // Create refresh token
        <span class="cov1" title="1">refreshTokenID := generateID()
        refreshTokenString := generateAPIKey() // Reuse the secure random generation
        refreshTokenHash := hashAPIKey(refreshTokenString)
        
        refreshToken := &amp;RefreshToken{
                ID:        refreshTokenID,
                UserID:    user.ID,
                TokenHash: refreshTokenHash,
                ExpiresAt: refreshTokenExpiry,
                CreatedAt: now,
                Used:      false,
        }
        
        jm.refreshTokens[refreshTokenID] = refreshToken
        
        return &amp;TokenPair{
                AccessToken:  accessTokenString,
                RefreshToken: refreshTokenString,
                ExpiresAt:    accessTokenExpiry,
                TokenType:    "Bearer",
        }, nil</span>
}

// RefreshAccessToken generates a new access token using a refresh token
func (jm *JWTManager) RefreshAccessToken(refreshTokenString string, user *User) (*TokenPair, error) <span class="cov0" title="0">{
        refreshTokenHash := hashAPIKey(refreshTokenString)
        
        // Find the refresh token
        var refreshToken *RefreshToken
        for _, rt := range jm.refreshTokens </span><span class="cov0" title="0">{
                if rt.TokenHash == refreshTokenHash &amp;&amp; rt.UserID == user.ID &amp;&amp; !rt.Used </span><span class="cov0" title="0">{
                        if time.Now().Before(rt.ExpiresAt) </span><span class="cov0" title="0">{
                                refreshToken = rt
                                break</span>
                        }
                }
        }
        
        <span class="cov0" title="0">if refreshToken == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid or expired refresh token")
        }</span>
        
        // Mark the old refresh token as used
        <span class="cov0" title="0">refreshToken.Used = true
        
        // Generate new token pair
        return jm.GenerateTokenPair(user, "", nil)</span>
}

// ValidateToken validates a JWT access token
func (jm *JWTManager) ValidateToken(tokenString string) (*Claims, error) <span class="cov10" title="2">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov10" title="2">{
                if _, ok := token.Method.(*jwt.SigningMethodRSA); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov10" title="2">return jm.publicKey, nil</span>
        })
        
        <span class="cov10" title="2">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse token: %w", err)
        }</span>
        
        <span class="cov10" title="2">claims, ok := token.Claims.(*Claims)
        if !ok || !token.Valid </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid token claims")
        }</span>
        
        // Check if token is blacklisted
        <span class="cov10" title="2">if jm.isBlacklisted(claims.ID) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("token is blacklisted")
        }</span>
        
        <span class="cov10" title="2">return claims, nil</span>
}

// BlacklistToken adds a token to the blacklist
func (jm *JWTManager) BlacklistToken(tokenID string, expiry time.Time) <span class="cov0" title="0">{
        jm.blacklist[tokenID] = expiry
}</span>

// RevokeRefreshToken revokes a refresh token
func (jm *JWTManager) RevokeRefreshToken(refreshTokenString, userID string) error <span class="cov0" title="0">{
        refreshTokenHash := hashAPIKey(refreshTokenString)
        
        for _, rt := range jm.refreshTokens </span><span class="cov0" title="0">{
                if rt.TokenHash == refreshTokenHash &amp;&amp; rt.UserID == userID </span><span class="cov0" title="0">{
                        rt.Used = true
                        return nil
                }</span>
        }
        
        <span class="cov0" title="0">return fmt.Errorf("refresh token not found")</span>
}

// RevokeAllUserTokens revokes all tokens for a user
func (jm *JWTManager) RevokeAllUserTokens(userID string) <span class="cov0" title="0">{
        // Mark all refresh tokens as used
        for _, rt := range jm.refreshTokens </span><span class="cov0" title="0">{
                if rt.UserID == userID </span><span class="cov0" title="0">{
                        rt.Used = true
                }</span>
        }
}

// CleanupExpiredTokens removes expired tokens from memory
func (jm *JWTManager) CleanupExpiredTokens() <span class="cov0" title="0">{
        now := time.Now()
        
        // Clean up blacklist
        for tokenID, expiry := range jm.blacklist </span><span class="cov0" title="0">{
                if now.After(expiry) </span><span class="cov0" title="0">{
                        delete(jm.blacklist, tokenID)
                }</span>
        }
        
        // Clean up refresh tokens
        <span class="cov0" title="0">for id, rt := range jm.refreshTokens </span><span class="cov0" title="0">{
                if now.After(rt.ExpiresAt) || rt.Used </span><span class="cov0" title="0">{
                        delete(jm.refreshTokens, id)
                }</span>
        }
}

// GetTokenClaims extracts claims from a token without validating it (useful for expired tokens)
func (jm *JWTManager) GetTokenClaims(tokenString string) (*Claims, error) <span class="cov0" title="0">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                return jm.publicKey, nil
        }</span>, jwt.WithoutClaimsValidation())
        
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse token: %w", err)
        }</span>
        
        <span class="cov0" title="0">claims, ok := token.Claims.(*Claims)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid token claims")
        }</span>
        
        <span class="cov0" title="0">return claims, nil</span>
}

// GenerateServiceToken generates a long-lived token for service-to-service communication
func (jm *JWTManager) GenerateServiceToken(serviceID, serviceName string, permissions []string) (string, error) <span class="cov1" title="1">{
        now := time.Now()
        expiry := now.Add(365 * 24 * time.Hour) // 1 year
        
        claims := &amp;Claims{
                UserID:      serviceID,
                Username:    serviceName,
                Role:        RoleService,
                Permissions: permissions,
                Metadata: map[string]string{
                        "token_type": "service",
                },
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(expiry),
                        IssuedAt:  jwt.NewNumericDate(now),
                        NotBefore: jwt.NewNumericDate(now),
                        Issuer:    jm.config.Issuer,
                        Subject:   serviceID,
                        ID:        generateID(),
                        Audience:  []string{jm.config.Audience},
                },
        }
        
        token := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
        return token.SignedString(jm.privateKey)
}</span>

// ValidateServiceToken validates a service token
func (jm *JWTManager) ValidateServiceToken(tokenString string) (*Claims, error) <span class="cov1" title="1">{
        claims, err := jm.ValidateToken(tokenString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // Verify this is a service token
        <span class="cov1" title="1">if claims.Metadata["token_type"] != "service" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not a service token")
        }</span>
        
        <span class="cov1" title="1">return claims, nil</span>
}

// CreateShortLivedToken creates a token with custom expiry (for specific operations)
func (jm *JWTManager) CreateShortLivedToken(user *User, duration time.Duration, purpose string) (string, error) <span class="cov0" title="0">{
        now := time.Now()
        expiry := now.Add(duration)
        
        claims := &amp;Claims{
                UserID:      user.ID,
                Username:    user.Username,
                Email:       user.Email,
                Role:        user.Role,
                Permissions: user.Permissions,
                Metadata: map[string]string{
                        "token_type": "short_lived",
                        "purpose":    purpose,
                },
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(expiry),
                        IssuedAt:  jwt.NewNumericDate(now),
                        NotBefore: jwt.NewNumericDate(now),
                        Issuer:    jm.config.Issuer,
                        Subject:   user.ID,
                        ID:        generateID(),
                        Audience:  []string{jm.config.Audience},
                },
        }
        
        token := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
        return token.SignedString(jm.privateKey)
}</span>

// GetPublicKey returns the public key for token verification by other services
func (jm *JWTManager) GetPublicKey() *rsa.PublicKey <span class="cov0" title="0">{
        return jm.publicKey
}</span>

// GetTokenStats returns statistics about tokens
func (jm *JWTManager) GetTokenStats() map[string]interface{} <span class="cov0" title="0">{
        activeRefreshTokens := 0
        expiredRefreshTokens := 0
        now := time.Now()
        
        for _, rt := range jm.refreshTokens </span><span class="cov0" title="0">{
                if rt.Used || now.After(rt.ExpiresAt) </span><span class="cov0" title="0">{
                        expiredRefreshTokens++
                }</span> else<span class="cov0" title="0"> {
                        activeRefreshTokens++
                }</span>
        }
        
        <span class="cov0" title="0">return map[string]interface{}{
                "active_refresh_tokens":  activeRefreshTokens,
                "expired_refresh_tokens": expiredRefreshTokens,
                "blacklisted_tokens":     len(jm.blacklist),
                "total_refresh_tokens":   len(jm.refreshTokens),
        }</span>
}

// isBlacklisted checks if a token ID is blacklisted
func (jm *JWTManager) isBlacklisted(tokenID string) bool <span class="cov10" title="2">{
        expiry, exists := jm.blacklist[tokenID]
        if !exists </span><span class="cov10" title="2">{
                return false
        }</span>
        
        <span class="cov0" title="0">if time.Now().After(expiry) </span><span class="cov0" title="0">{
                delete(jm.blacklist, tokenID)
                return false
        }</span>
        
        <span class="cov0" title="0">return true</span>
}</pre>
		
		<pre class="file" id="file3" style="display: none">package auth

import (
        "net/http"
        "strings"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/ollama/ollama-distributed/internal/config"
)

// MiddlewareManager handles HTTP middleware for authentication and authorization
type MiddlewareManager struct {
        authManager *Manager
        jwtManager  *JWTManager
        config      *config.AuthConfig
}

// NewMiddlewareManager creates a new middleware manager
func NewMiddlewareManager(authManager *Manager, jwtManager *JWTManager, config *config.AuthConfig) *MiddlewareManager <span class="cov0" title="0">{
        return &amp;MiddlewareManager{
                authManager: authManager,
                jwtManager:  jwtManager,
                config:      config,
        }
}</span>

// AuthRequired middleware that requires authentication
func (mm *MiddlewareManager) AuthRequired() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Skip auth if disabled
                if !mm.config.Enabled </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>
                
                // Skip auth for certain paths
                <span class="cov0" title="0">if mm.shouldSkipAuth(c.Request.URL.Path, c.Request.Method) </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>
                
                // Try to authenticate
                <span class="cov0" title="0">authCtx, err := mm.authenticate(c)
                if err != nil </span><span class="cov0" title="0">{
                        mm.handleAuthError(c, err)
                        return
                }</span>
                
                // Store auth context
                <span class="cov0" title="0">mm.setAuthContext(c, authCtx)
                c.Next()</span>
        }
}

// RequirePermission middleware that requires specific permissions
func (mm *MiddlewareManager) RequirePermission(permission string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                authCtx := mm.getAuthContext(c)
                if authCtx == nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
                        c.Abort()
                        return
                }</span>
                
                <span class="cov0" title="0">if !mm.authManager.HasPermission(authCtx, permission) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, gin.H{
                                "error": "Insufficient permissions",
                                "required_permission": permission,
                        })
                        c.Abort()
                        return
                }</span>
                
                <span class="cov0" title="0">c.Next()</span>
        }
}

// RequireRole middleware that requires a specific role
func (mm *MiddlewareManager) RequireRole(role string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                authCtx := mm.getAuthContext(c)
                if authCtx == nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
                        c.Abort()
                        return
                }</span>
                
                <span class="cov0" title="0">if authCtx.User.Role != role &amp;&amp; authCtx.User.Role != RoleAdmin </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, gin.H{
                                "error": "Insufficient role",
                                "required_role": role,
                                "user_role": authCtx.User.Role,
                        })
                        c.Abort()
                        return
                }</span>
                
                <span class="cov0" title="0">c.Next()</span>
        }
}

// RequireAnyRole middleware that requires any of the specified roles
func (mm *MiddlewareManager) RequireAnyRole(roles ...string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                authCtx := mm.getAuthContext(c)
                if authCtx == nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
                        c.Abort()
                        return
                }</span>
                
                // Admin always has access
                <span class="cov0" title="0">if authCtx.User.Role == RoleAdmin </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>
                
                // Check if user has any of the required roles
                <span class="cov0" title="0">hasRole := false
                for _, role := range roles </span><span class="cov0" title="0">{
                        if authCtx.User.Role == role </span><span class="cov0" title="0">{
                                hasRole = true
                                break</span>
                        }
                }
                
                <span class="cov0" title="0">if !hasRole </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, gin.H{
                                "error": "Insufficient role",
                                "required_roles": roles,
                                "user_role": authCtx.User.Role,
                        })
                        c.Abort()
                        return
                }</span>
                
                <span class="cov0" title="0">c.Next()</span>
        }
}

// RequireAnyPermission middleware that requires any of the specified permissions
func (mm *MiddlewareManager) RequireAnyPermission(permissions ...string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                authCtx := mm.getAuthContext(c)
                if authCtx == nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
                        c.Abort()
                        return
                }</span>
                
                // Check if user has any of the required permissions
                <span class="cov0" title="0">hasPermission := false
                for _, permission := range permissions </span><span class="cov0" title="0">{
                        if mm.authManager.HasPermission(authCtx, permission) </span><span class="cov0" title="0">{
                                hasPermission = true
                                break</span>
                        }
                }
                
                <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, gin.H{
                                "error": "Insufficient permissions",
                                "required_permissions": permissions,
                        })
                        c.Abort()
                        return
                }</span>
                
                <span class="cov0" title="0">c.Next()</span>
        }
}

// Optional middleware that attempts authentication but doesn't require it
func (mm *MiddlewareManager) Optional() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                if !mm.config.Enabled </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>
                
                // Try to authenticate but don't fail if unsuccessful
                <span class="cov0" title="0">authCtx, _ := mm.authenticate(c)
                if authCtx != nil </span><span class="cov0" title="0">{
                        mm.setAuthContext(c, authCtx)
                }</span>
                
                <span class="cov0" title="0">c.Next()</span>
        }
}

// RateLimit middleware for API rate limiting
func (mm *MiddlewareManager) RateLimit() gin.HandlerFunc <span class="cov0" title="0">{
        // This is a simplified rate limiter
        // In production, use a proper rate limiting library like tollbooth or redis-based limiter
        requestCounts := make(map[string]map[int64]int)
        
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Get client identifier (IP or user ID if authenticated)
                clientID := c.ClientIP()
                if authCtx := mm.getAuthContext(c); authCtx != nil </span><span class="cov0" title="0">{
                        clientID = authCtx.User.ID
                }</span>
                
                // Current minute window
                <span class="cov0" title="0">currentMinute := time.Now().Unix() / 60
                
                if requestCounts[clientID] == nil </span><span class="cov0" title="0">{
                        requestCounts[clientID] = make(map[int64]int)
                }</span>
                
                // Clean old entries
                <span class="cov0" title="0">for minute := range requestCounts[clientID] </span><span class="cov0" title="0">{
                        if currentMinute-minute &gt; 5 </span><span class="cov0" title="0">{ // Keep last 5 minutes
                                delete(requestCounts[clientID], minute)
                        }</span>
                }
                
                // Count requests in current minute
                <span class="cov0" title="0">requestCounts[clientID][currentMinute]++
                
                // Check limit (100 requests per minute)
                if requestCounts[clientID][currentMinute] &gt; 100 </span><span class="cov0" title="0">{
                        c.JSON(http.StatusTooManyRequests, gin.H{
                                "error": "Rate limit exceeded",
                                "retry_after": 60,
                        })
                        c.Abort()
                        return
                }</span>
                
                <span class="cov0" title="0">c.Header("X-RateLimit-Limit", "100")
                c.Header("X-RateLimit-Remaining", string(rune(100-requestCounts[clientID][currentMinute])))
                c.Header("X-RateLimit-Reset", string(rune((currentMinute+1)*60)))
                
                c.Next()</span>
        }
}

// CORS middleware with authentication-aware settings
func (mm *MiddlewareManager) CORS() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                origin := c.Request.Header.Get("Origin")
                
                // Default allowed origins
                allowedOrigins := []string{"http://localhost:8080", "https://localhost:8080"}
                
                // Check if origin is allowed
                allowed := false
                for _, allowedOrigin := range allowedOrigins </span><span class="cov0" title="0">{
                        if origin == allowedOrigin </span><span class="cov0" title="0">{
                                allowed = true
                                break</span>
                        }
                }
                
                <span class="cov0" title="0">if allowed </span><span class="cov0" title="0">{
                        c.Header("Access-Control-Allow-Origin", origin)
                }</span>
                
                <span class="cov0" title="0">c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                c.Header("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Requested-With")
                c.Header("Access-Control-Allow-Credentials", "true")
                c.Header("Access-Control-Max-Age", "3600")
                
                if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(http.StatusNoContent)
                        return
                }</span>
                
                <span class="cov0" title="0">c.Next()</span>
        }
}

// SecurityHeaders middleware that adds security headers
func (mm *MiddlewareManager) SecurityHeaders() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Header("X-Content-Type-Options", "nosniff")
                c.Header("X-Frame-Options", "DENY")
                c.Header("X-XSS-Protection", "1; mode=block")
                c.Header("Referrer-Policy", "strict-origin-when-cross-origin")
                c.Header("Content-Security-Policy", "default-src 'self'")
                c.Header("Strict-Transport-Security", "max-age=31536000; includeSubDomains")
                
                c.Next()
        }</span>
}

// AuditLog middleware that logs authentication events
func (mm *MiddlewareManager) AuditLog() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()
                
                // Process request
                c.Next()
                
                // Log after request completion
                duration := time.Since(start)
                authCtx := mm.getAuthContext(c)
                
                logData := map[string]interface{}{
                        "timestamp":    start.Unix(),
                        "method":       c.Request.Method,
                        "path":         c.Request.URL.Path,
                        "status":       c.Writer.Status(),
                        "duration_ms":  duration.Milliseconds(),
                        "ip":           c.ClientIP(),
                        "user_agent":   c.Request.Header.Get("User-Agent"),
                }
                
                if authCtx != nil </span><span class="cov0" title="0">{
                        logData["user_id"] = authCtx.User.ID
                        logData["username"] = authCtx.User.Username
                        logData["auth_method"] = string(authCtx.Method)
                        if authCtx.Session != nil </span><span class="cov0" title="0">{
                                logData["session_id"] = authCtx.Session.ID
                        }</span>
                        <span class="cov0" title="0">if authCtx.APIKey != nil </span><span class="cov0" title="0">{
                                logData["api_key_id"] = authCtx.APIKey.ID
                        }</span>
                }
                
                // In production, send this to a proper logging system
                // fmt.Printf("AUDIT: %+v\n", logData)
        }
}

// Helper methods

func (mm *MiddlewareManager) authenticate(c *gin.Context) (*AuthContext, error) <span class="cov0" title="0">{
        // Try API key authentication first
        if apiKey := mm.extractAPIKey(c); apiKey != "" </span><span class="cov0" title="0">{
                return mm.authManager.ValidateAPIKey(apiKey)
        }</span>
        
        // Try JWT token authentication
        <span class="cov0" title="0">if token := mm.extractBearerToken(c); token != "" </span><span class="cov0" title="0">{
                return mm.authManager.ValidateToken(token)
        }</span>
        
        <span class="cov0" title="0">return nil, ErrInvalidCredentials</span>
}

func (mm *MiddlewareManager) extractBearerToken(c *gin.Context) string <span class="cov0" title="0">{
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        
        <span class="cov0" title="0">parts := strings.SplitN(authHeader, " ", 2)
        if len(parts) != 2 || strings.ToLower(parts[0]) != "bearer" </span><span class="cov0" title="0">{
                return ""
        }</span>
        
        <span class="cov0" title="0">return parts[1]</span>
}

func (mm *MiddlewareManager) extractAPIKey(c *gin.Context) string <span class="cov0" title="0">{
        // Check Authorization header with API key
        authHeader := c.GetHeader("Authorization")
        if strings.HasPrefix(strings.ToLower(authHeader), "apikey ") </span><span class="cov0" title="0">{
                return strings.TrimPrefix(authHeader, "ApiKey ")
        }</span>
        
        // Check X-API-Key header
        <span class="cov0" title="0">if apiKey := c.GetHeader("X-API-Key"); apiKey != "" </span><span class="cov0" title="0">{
                return apiKey
        }</span>
        
        // Check query parameter
        <span class="cov0" title="0">if apiKey := c.Query("api_key"); apiKey != "" </span><span class="cov0" title="0">{
                return apiKey
        }</span>
        
        <span class="cov0" title="0">return ""</span>
}

func (mm *MiddlewareManager) shouldSkipAuth(path, method string) bool <span class="cov0" title="0">{
        // Public endpoints that don't require authentication
        publicPaths := []string{
                "/api/v1/health",
                "/api/v1/login",
                "/api/v1/register",
                "/metrics",
                "/favicon.ico",
        }
        
        for _, publicPath := range publicPaths </span><span class="cov0" title="0">{
                if path == publicPath </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">if strings.HasPrefix(path, "/static/") </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        
        // Always allow OPTIONS requests for CORS
        <span class="cov0" title="0">if method == "OPTIONS" </span><span class="cov0" title="0">{
                return true
        }</span>
        
        <span class="cov0" title="0">return false</span>
}

func (mm *MiddlewareManager) handleAuthError(c *gin.Context, err error) <span class="cov0" title="0">{
        var status int
        var response gin.H
        
        switch err.(type) </span>{
        case AuthError:<span class="cov0" title="0">
                authErr := err.(AuthError)
                switch authErr.Code </span>{
                case "TOKEN_EXPIRED":<span class="cov0" title="0">
                        status = http.StatusUnauthorized</span>
                case "TOKEN_INVALID":<span class="cov0" title="0">
                        status = http.StatusUnauthorized</span>
                case "TOKEN_BLACKLISTED":<span class="cov0" title="0">
                        status = http.StatusUnauthorized</span>
                case "INSUFFICIENT_PERMISSIONS":<span class="cov0" title="0">
                        status = http.StatusForbidden</span>
                case "USER_NOT_FOUND":<span class="cov0" title="0">
                        status = http.StatusUnauthorized</span>
                case "USER_INACTIVE":<span class="cov0" title="0">
                        status = http.StatusUnauthorized</span>
                default:<span class="cov0" title="0">
                        status = http.StatusUnauthorized</span>
                }
                <span class="cov0" title="0">response = gin.H{
                        "error": authErr.Message,
                        "code":  authErr.Code,
                }</span>
        default:<span class="cov0" title="0">
                status = http.StatusUnauthorized
                response = gin.H{
                        "error": "Authentication required",
                }</span>
        }
        
        <span class="cov0" title="0">c.JSON(status, response)
        c.Abort()</span>
}

func (mm *MiddlewareManager) setAuthContext(c *gin.Context, authCtx *AuthContext) <span class="cov0" title="0">{
        c.Set("auth_context", authCtx)
        c.Set("user", authCtx.User)
        c.Set("user_id", authCtx.User.ID)
        c.Set("username", authCtx.User.Username)
        c.Set("role", authCtx.User.Role)
        c.Set("permissions", authCtx.User.Permissions)
        if authCtx.Session != nil </span><span class="cov0" title="0">{
                c.Set("session", authCtx.Session)
                c.Set("session_id", authCtx.Session.ID)
        }</span>
        <span class="cov0" title="0">if authCtx.APIKey != nil </span><span class="cov0" title="0">{
                c.Set("api_key", authCtx.APIKey)
                c.Set("api_key_id", authCtx.APIKey.ID)
        }</span>
}

func (mm *MiddlewareManager) getAuthContext(c *gin.Context) *AuthContext <span class="cov0" title="0">{
        if authCtx, exists := c.Get("auth_context"); exists </span><span class="cov0" title="0">{
                if ctx, ok := authCtx.(*AuthContext); ok </span><span class="cov0" title="0">{
                        return ctx
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// GetCurrentUser helper function to get current user from context
func GetCurrentUser(c *gin.Context) *User <span class="cov0" title="0">{
        if user, exists := c.Get("user"); exists </span><span class="cov0" title="0">{
                if u, ok := user.(*User); ok </span><span class="cov0" title="0">{
                        return u
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// GetCurrentUserID helper function to get current user ID from context
func GetCurrentUserID(c *gin.Context) string <span class="cov0" title="0">{
        if userID, exists := c.Get("user_id"); exists </span><span class="cov0" title="0">{
                if id, ok := userID.(string); ok </span><span class="cov0" title="0">{
                        return id
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// HasPermission helper function to check permissions in handlers
func HasPermission(c *gin.Context, permission string) bool <span class="cov0" title="0">{
        if permissions, exists := c.Get("permissions"); exists </span><span class="cov0" title="0">{
                if perms, ok := permissions.([]string); ok </span><span class="cov0" title="0">{
                        for _, perm := range perms </span><span class="cov0" title="0">{
                                if perm == permission || perm == PermissionSystemAdmin </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return false</span>
}</pre>
		
		<pre class="file" id="file4" style="display: none">package auth

import (
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
)

// Routes handles authentication-related HTTP routes
type Routes struct {
        authManager       *Manager
        jwtManager        *JWTManager
        middlewareManager *MiddlewareManager
}

// NewRoutes creates a new routes handler
func NewRoutes(authManager *Manager, jwtManager *JWTManager, middlewareManager *MiddlewareManager) *Routes <span class="cov0" title="0">{
        return &amp;Routes{
                authManager:       authManager,
                jwtManager:        jwtManager,
                middlewareManager: middlewareManager,
        }
}</span>

// RegisterRoutes registers authentication routes with the Gin router
func (r *Routes) RegisterRoutes(router *gin.Engine) <span class="cov0" title="0">{
        // Apply global middleware
        router.Use(r.middlewareManager.CORS())
        router.Use(r.middlewareManager.SecurityHeaders())
        router.Use(r.middlewareManager.RateLimit())
        router.Use(r.middlewareManager.AuditLog())
        
        // Public routes (no authentication required)
        public := router.Group("/api/v1")
        </span><span class="cov0" title="0">{
                public.POST("/login", r.login)
                public.POST("/register", r.register)
                public.POST("/refresh", r.refreshToken)
                public.GET("/health", r.health)
        }</span>
        
        // Protected routes (authentication required)
        <span class="cov0" title="0">protected := router.Group("/api/v1")
        protected.Use(r.middlewareManager.AuthRequired())
        </span><span class="cov0" title="0">{
                // User management
                user := protected.Group("/user")
                </span><span class="cov0" title="0">{
                        user.GET("/profile", r.getProfile)
                        user.PUT("/profile", r.updateProfile)
                        user.POST("/change-password", r.changePassword)
                        user.POST("/logout", r.logout)
                        user.GET("/sessions", r.getSessions)
                        user.DELETE("/sessions/:session_id", r.revokeSession)
                }</span>
                
                // API key management
                <span class="cov0" title="0">apiKeys := protected.Group("/api-keys")
                </span><span class="cov0" title="0">{
                        apiKeys.GET("", r.listAPIKeys)
                        apiKeys.POST("", r.createAPIKey)
                        apiKeys.DELETE("/:key_id", r.revokeAPIKey)
                }</span>
                
                // Admin routes
                <span class="cov0" title="0">admin := protected.Group("/admin")
                admin.Use(r.middlewareManager.RequireRole(RoleAdmin))
                </span><span class="cov0" title="0">{
                        admin.GET("/users", r.listUsers)
                        admin.POST("/users", r.createUser)
                        admin.GET("/users/:user_id", r.getUser)
                        admin.PUT("/users/:user_id", r.updateUser)
                        admin.DELETE("/users/:user_id", r.deleteUser)
                        admin.POST("/users/:user_id/reset-password", r.resetUserPassword)
                        admin.GET("/stats", r.getAuthStats)
                }</span>
        }
}

// Authentication handlers

func (r *Routes) login(c *gin.Context) <span class="cov0" title="0">{
        var req LoginRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>
        
        // Get client metadata
        <span class="cov0" title="0">metadata := map[string]string{
                "ip_address": c.ClientIP(),
                "user_agent": c.Request.Header.Get("User-Agent"),
        }
        for k, v := range req.Metadata </span><span class="cov0" title="0">{
                metadata[k] = v
        }</span>
        
        // Authenticate user
        <span class="cov0" title="0">authCtx, err := r.authManager.Authenticate(req.Username, req.Password, metadata)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
                return
        }</span>
        
        <span class="cov0" title="0">response := LoginResponse{
                Token:     authCtx.TokenString,
                ExpiresAt: authCtx.Session.ExpiresAt,
                User:      authCtx.User,
                SessionID: authCtx.Session.ID,
        }
        
        c.JSON(http.StatusOK, response)</span>
}

func (r *Routes) register(c *gin.Context) <span class="cov0" title="0">{
        var req CreateUserRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>
        
        // Default role for registration
        <span class="cov0" title="0">if req.Role == "" </span><span class="cov0" title="0">{
                req.Role = RoleUser
        }</span>
        
        // Only allow certain roles for self-registration
        <span class="cov0" title="0">allowedRoles := []string{RoleUser, RoleReadOnly}
        roleAllowed := false
        for _, role := range allowedRoles </span><span class="cov0" title="0">{
                if req.Role == role </span><span class="cov0" title="0">{
                        roleAllowed = true
                        break</span>
                }
        }
        
        <span class="cov0" title="0">if !roleAllowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid role for registration"})
                return
        }</span>
        
        <span class="cov0" title="0">user, err := r.authManager.CreateUser(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        
        // Remove sensitive data from response
        <span class="cov0" title="0">user.Metadata = map[string]string{}
        
        c.JSON(http.StatusCreated, gin.H{"user": user})</span>
}

func (r *Routes) refreshToken(c *gin.Context) <span class="cov0" title="0">{
        var req RefreshRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>
        
        // Get user from token (even if expired)
        <span class="cov0" title="0">_, err := r.jwtManager.GetTokenClaims(req.Token)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token"})
                return
        }</span>
        
        // This is a simplified implementation
        // In a real system, you'd use a separate refresh token
        <span class="cov0" title="0">c.JSON(http.StatusNotImplemented, gin.H{"error": "Refresh token functionality not implemented"})</span>
}

func (r *Routes) health(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "status":    "healthy",
                "service":   "auth",
                "timestamp": time.Now().Unix(),
        })
}</span>

// User management handlers

func (r *Routes) getProfile(c *gin.Context) <span class="cov0" title="0">{
        user := GetCurrentUser(c)
        if user == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "User not found"})
                return
        }</span>
        
        // Remove sensitive data
        <span class="cov0" title="0">user.Metadata = map[string]string{}
        
        c.JSON(http.StatusOK, gin.H{"user": user})</span>
}

func (r *Routes) updateProfile(c *gin.Context) <span class="cov0" title="0">{
        user := GetCurrentUser(c)
        if user == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "User not found"})
                return
        }</span>
        
        <span class="cov0" title="0">var req UpdateUserRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>
        
        // Update allowed fields
        <span class="cov0" title="0">if req.Email != nil </span><span class="cov0" title="0">{
                user.Email = *req.Email
        }</span>
        <span class="cov0" title="0">if req.Metadata != nil </span><span class="cov0" title="0">{
                for k, v := range req.Metadata </span><span class="cov0" title="0">{
                        if k != "password_hash" </span><span class="cov0" title="0">{ // Prevent password hash modification
                                user.Metadata[k] = v
                        }</span>
                }
        }
        
        <span class="cov0" title="0">user.UpdatedAt = time.Now()
        
        // Remove sensitive data from response
        user.Metadata = map[string]string{}
        
        c.JSON(http.StatusOK, gin.H{"user": user})</span>
}

func (r *Routes) changePassword(c *gin.Context) <span class="cov0" title="0">{
        user := GetCurrentUser(c)
        if user == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "User not found"})
                return
        }</span>
        
        <span class="cov0" title="0">var req ChangePasswordRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>
        
        // This would need to be implemented in the auth manager
        <span class="cov0" title="0">c.JSON(http.StatusNotImplemented, gin.H{"error": "Password change not implemented"})</span>
}

func (r *Routes) logout(c *gin.Context) <span class="cov0" title="0">{
        authCtx := r.middlewareManager.getAuthContext(c)
        if authCtx == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "No active session"})
                return
        }</span>
        
        // Revoke session if it exists
        <span class="cov0" title="0">if authCtx.Session != nil </span><span class="cov0" title="0">{
                r.authManager.RevokeSession(authCtx.Session.ID)
        }</span>
        
        // Blacklist the token
        <span class="cov0" title="0">if authCtx.Claims != nil </span><span class="cov0" title="0">{
                r.authManager.RevokeToken(authCtx.Claims.ID, authCtx.Claims.ExpiresAt.Time)
        }</span>
        
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Logged out successfully"})</span>
}

func (r *Routes) getSessions(c *gin.Context) <span class="cov0" title="0">{
        // This would need to be implemented to return user sessions
        c.JSON(http.StatusNotImplemented, gin.H{"error": "Session listing not implemented"})
}</span>

func (r *Routes) revokeSession(c *gin.Context) <span class="cov0" title="0">{
        sessionID := c.Param("session_id")
        
        err := r.authManager.RevokeSession(sessionID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>
        
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Session revoked successfully"})</span>
}

// API key management handlers

func (r *Routes) listAPIKeys(c *gin.Context) <span class="cov0" title="0">{
        user := GetCurrentUser(c)
        if user == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "User not found"})
                return
        }</span>
        
        // Filter API keys to only show current user's keys
        <span class="cov0" title="0">var userAPIKeys []APIKey
        for _, apiKey := range user.APIKeys </span><span class="cov0" title="0">{
                // Remove the actual key value for security
                apiKey.Key = ""
                userAPIKeys = append(userAPIKeys, apiKey)
        }</span>
        
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"api_keys": userAPIKeys})</span>
}

func (r *Routes) createAPIKey(c *gin.Context) <span class="cov0" title="0">{
        user := GetCurrentUser(c)
        if user == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "User not found"})
                return
        }</span>
        
        <span class="cov0" title="0">var req CreateAPIKeyRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>
        
        <span class="cov0" title="0">apiKey, rawKey, err := r.authManager.CreateAPIKey(user.ID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        
        <span class="cov0" title="0">response := CreateAPIKeyResponse{
                APIKey: apiKey,
                Key:    rawKey,
        }
        
        // Remove the hashed key from the response
        response.APIKey.Key = ""
        
        c.JSON(http.StatusCreated, response)</span>
}

func (r *Routes) revokeAPIKey(c *gin.Context) <span class="cov0" title="0">{
        keyID := c.Param("key_id")
        
        err := r.authManager.RevokeAPIKey(keyID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>
        
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "API key revoked successfully"})</span>
}

// Admin handlers

func (r *Routes) listUsers(c *gin.Context) <span class="cov0" title="0">{
        // This would need to be implemented in the auth manager
        c.JSON(http.StatusNotImplemented, gin.H{"error": "User listing not implemented"})
}</span>

func (r *Routes) createUser(c *gin.Context) <span class="cov0" title="0">{
        var req CreateUserRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>
        
        <span class="cov0" title="0">user, err := r.authManager.CreateUser(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        
        // Remove sensitive data
        <span class="cov0" title="0">user.Metadata = map[string]string{}
        
        c.JSON(http.StatusCreated, gin.H{"user": user})</span>
}

func (r *Routes) getUser(c *gin.Context) <span class="cov0" title="0">{
        userID := c.Param("user_id")
        
        // This would need to be implemented in the auth manager
        c.JSON(http.StatusNotImplemented, gin.H{"error": "User retrieval not implemented", "user_id": userID})
}</span>

func (r *Routes) updateUser(c *gin.Context) <span class="cov0" title="0">{
        userID := c.Param("user_id")
        
        var req UpdateUserRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>
        
        // This would need to be implemented in the auth manager
        <span class="cov0" title="0">c.JSON(http.StatusNotImplemented, gin.H{"error": "User update not implemented", "user_id": userID})</span>
}

func (r *Routes) deleteUser(c *gin.Context) <span class="cov0" title="0">{
        userID := c.Param("user_id")
        
        // This would need to be implemented in the auth manager
        c.JSON(http.StatusNotImplemented, gin.H{"error": "User deletion not implemented", "user_id": userID})
}</span>

func (r *Routes) resetUserPassword(c *gin.Context) <span class="cov0" title="0">{
        userID := c.Param("user_id")
        
        // This would need to be implemented in the auth manager
        c.JSON(http.StatusNotImplemented, gin.H{"error": "Password reset not implemented", "user_id": userID})
}</span>

func (r *Routes) getAuthStats(c *gin.Context) <span class="cov0" title="0">{
        stats := r.jwtManager.GetTokenStats()
        
        // Add more stats from auth manager
        stats["timestamp"] = time.Now().Unix()
        
        c.JSON(http.StatusOK, gin.H{"stats": stats})
}</pre>
		
		<pre class="file" id="file5" style="display: none">package auth

import (
        "log"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/ollama/ollama-distributed/internal/config"
)

// ExampleServerWithAuth demonstrates how to integrate the authentication system
// with the existing Ollama distributed server
func ExampleServerWithAuth() <span class="cov0" title="0">{
        // Load main configuration
        cfg, err := config.Load("")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load config: %v", err)
        }</span>
        
        // Ensure auth is enabled
        <span class="cov0" title="0">if !cfg.Security.Auth.Enabled </span><span class="cov0" title="0">{
                log.Println("WARNING: Authentication is disabled. Enable it for production!")
                cfg.Security.Auth.Enabled = true
                cfg.Security.Auth.Method = "jwt"
                cfg.Security.Auth.TokenExpiry = 24 * time.Hour
                cfg.Security.Auth.SecretKey = "demo-secret-key-change-in-production"
                cfg.Security.Auth.Issuer = "ollama-distributed"
                cfg.Security.Auth.Audience = "ollama-api"
        }</span>
        
        // Create authentication integration
        <span class="cov0" title="0">authIntegration, err := NewIntegration(&amp;cfg.Security.Auth)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create auth integration: %v", err)
        }</span>
        <span class="cov0" title="0">defer authIntegration.Close()
        
        // Create Gin router
        router := gin.New()
        
        // Apply global middleware
        router.Use(gin.Logger())
        router.Use(gin.Recovery())
        router.Use(authIntegration.MiddlewareManager.SecurityHeaders())
        router.Use(authIntegration.MiddlewareManager.CORS())
        router.Use(authIntegration.MiddlewareManager.RateLimit())
        router.Use(authIntegration.MiddlewareManager.AuditLog())
        
        // Register authentication routes
        authIntegration.Routes.RegisterRoutes(router)
        
        // Setup protected API routes
        setupProtectedAPIRoutes(router, authIntegration)
        
        // Setup public routes
        setupPublicRoutes(router)
        
        // Start server
        log.Printf("Starting Ollama Distributed Server with Authentication on %s", cfg.API.Listen)
        if err := router.Run(cfg.API.Listen); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to start server: %v", err)
        }</span>
}

// setupProtectedAPIRoutes configures the protected API endpoints
func setupProtectedAPIRoutes(router *gin.Engine, authIntegration *Integration) <span class="cov0" title="0">{
        // Protected API routes
        api := router.Group("/api/v1")
        api.Use(authIntegration.MiddlewareManager.AuthRequired())
        
        // Create middleware helpers
        helpers := NewMiddlewareHelpers(authIntegration)
        
        // Node management endpoints
        setupNodeRoutes(api, helpers)
        
        // Model management endpoints
        setupModelRoutes(api, helpers)
        
        // Cluster management endpoints
        setupClusterRoutes(api, helpers)
        
        // Inference endpoints
        setupInferenceRoutes(api, helpers)
        
        // Monitoring endpoints
        setupMonitoringRoutes(api, helpers)
        
        // Distribution management endpoints
        setupDistributionRoutes(api, helpers)
}</span>

// setupNodeRoutes configures node management routes
func setupNodeRoutes(api *gin.RouterGroup, helpers *MiddlewareHelpers) <span class="cov0" title="0">{
        nodes := api.Group("/nodes")
        
        // List nodes - requires read permission
        nodes.GET("", helpers.RequireNodePermission("read"), func(c *gin.Context) </span><span class="cov0" title="0">{
                user := GetCurrentUser(c)
                log.Printf("User %s requested node list", user.Username)
                
                // Mock response - in real implementation, this would call the scheduler
                c.JSON(200, gin.H{
                        "nodes": []map[string]interface{}{
                                {
                                        "id":     "node-1",
                                        "status": "online",
                                        "cpu":    "50%",
                                        "memory": "60%",
                                },
                                {
                                        "id":     "node-2",
                                        "status": "online",
                                        "cpu":    "30%",
                                        "memory": "40%",
                                },
                        },
                        "total": 2,
                })
        }</span>)
        
        // Get specific node - requires read permission
        <span class="cov0" title="0">nodes.GET("/:id", helpers.RequireNodePermission("read"), func(c *gin.Context) </span><span class="cov0" title="0">{
                nodeID := c.Param("id")
                user := GetCurrentUser(c)
                log.Printf("User %s requested details for node %s", user.Username, nodeID)
                
                c.JSON(200, gin.H{
                        "node": map[string]interface{}{
                                "id":       nodeID,
                                "status":   "online",
                                "cpu":      "50%",
                                "memory":   "60%",
                                "models":   []string{"llama2", "codellama"},
                                "requests": 150,
                        },
                })
        }</span>)
        
        // Drain node - requires write permission
        <span class="cov0" title="0">nodes.POST("/:id/drain", helpers.RequireNodePermission("write"), func(c *gin.Context) </span><span class="cov0" title="0">{
                nodeID := c.Param("id")
                user := GetCurrentUser(c)
                log.Printf("User %s initiated drain for node %s", user.Username, nodeID)
                
                c.JSON(200, gin.H{
                        "message": "Node drain initiated",
                        "node_id": nodeID,
                        "status":  "draining",
                })
        }</span>)
        
        // Delete node - requires admin permission
        <span class="cov0" title="0">nodes.DELETE("/:id", helpers.RequireNodePermission("admin"), func(c *gin.Context) </span><span class="cov0" title="0">{
                nodeID := c.Param("id")
                user := GetCurrentUser(c)
                log.Printf("User %s deleted node %s", user.Username, nodeID)
                
                c.JSON(200, gin.H{
                        "message": "Node deleted successfully",
                        "node_id": nodeID,
                })
        }</span>)
}

// setupModelRoutes configures model management routes
func setupModelRoutes(api *gin.RouterGroup, helpers *MiddlewareHelpers) <span class="cov0" title="0">{
        models := api.Group("/models")
        
        // List models - requires read permission
        models.GET("", helpers.RequireModelPermission("read"), func(c *gin.Context) </span><span class="cov0" title="0">{
                user := GetCurrentUser(c)
                log.Printf("User %s requested model list", user.Username)
                
                c.JSON(200, gin.H{
                        "models": []map[string]interface{}{
                                {
                                        "name":      "llama2",
                                        "size":      "7B",
                                        "locations": []string{"node-1", "node-2"},
                                        "status":    "ready",
                                },
                                {
                                        "name":      "codellama",
                                        "size":      "13B",
                                        "locations": []string{"node-1"},
                                        "status":    "ready",
                                },
                        },
                })
        }</span>)
        
        // Download model - requires write permission
        <span class="cov0" title="0">models.POST("/:name/download", helpers.RequireModelPermission("write"), func(c *gin.Context) </span><span class="cov0" title="0">{
                modelName := c.Param("name")
                user := GetCurrentUser(c)
                log.Printf("User %s initiated download for model %s", user.Username, modelName)
                
                c.JSON(200, gin.H{
                        "message":    "Model download initiated",
                        "model_name": modelName,
                        "status":     "downloading",
                        "progress":   0,
                })
        }</span>)
        
        // Delete model - requires admin permission
        <span class="cov0" title="0">models.DELETE("/:name", helpers.RequireModelPermission("admin"), func(c *gin.Context) </span><span class="cov0" title="0">{
                modelName := c.Param("name")
                user := GetCurrentUser(c)
                log.Printf("User %s deleted model %s", user.Username, modelName)
                
                c.JSON(200, gin.H{
                        "message":    "Model deleted successfully",
                        "model_name": modelName,
                })
        }</span>)
}

// setupClusterRoutes configures cluster management routes
func setupClusterRoutes(api *gin.RouterGroup, helpers *MiddlewareHelpers) <span class="cov0" title="0">{
        cluster := api.Group("/cluster")
        
        // Get cluster status - requires read permission
        cluster.GET("/status", helpers.RequireClusterPermission("read"), func(c *gin.Context) </span><span class="cov0" title="0">{
                user := GetCurrentUser(c)
                log.Printf("User %s requested cluster status", user.Username)
                
                c.JSON(200, gin.H{
                        "status": "healthy",
                        "nodes":  2,
                        "leader": "node-1",
                        "peers":  1,
                })
        }</span>)
        
        // Join cluster - requires write permission
        <span class="cov0" title="0">cluster.POST("/join", helpers.RequireClusterPermission("write"), func(c *gin.Context) </span><span class="cov0" title="0">{
                var req map[string]interface{}
                c.ShouldBindJSON(&amp;req)
                
                user := GetCurrentUser(c)
                log.Printf("User %s initiated cluster join", user.Username)
                
                c.JSON(200, gin.H{
                        "message": "Node join initiated",
                })
        }</span>)
        
        // Leave cluster - requires admin permission
        <span class="cov0" title="0">cluster.POST("/leave", helpers.RequireClusterPermission("admin"), func(c *gin.Context) </span><span class="cov0" title="0">{
                user := GetCurrentUser(c)
                log.Printf("User %s initiated cluster leave", user.Username)
                
                c.JSON(200, gin.H{
                        "message": "Node leave initiated",
                })
        }</span>)
}

// setupInferenceRoutes configures inference routes
func setupInferenceRoutes(api *gin.RouterGroup, helpers *MiddlewareHelpers) <span class="cov0" title="0">{
        // Generate endpoint - requires write permission
        api.POST("/generate", helpers.RequireInferencePermission("write"), func(c *gin.Context) </span><span class="cov0" title="0">{
                var req map[string]interface{}
                c.ShouldBindJSON(&amp;req)
                
                user := GetCurrentUser(c)
                modelName := req["model"]
                log.Printf("User %s requested generation with model %v", user.Username, modelName)
                
                c.JSON(200, gin.H{
                        "response": "This is a generated response from the distributed Ollama system",
                        "model":    modelName,
                        "node_id":  "node-1",
                        "user":     user.Username,
                })
        }</span>)
        
        // Chat endpoint - requires write permission
        <span class="cov0" title="0">api.POST("/chat", helpers.RequireInferencePermission("write"), func(c *gin.Context) </span><span class="cov0" title="0">{
                var req map[string]interface{}
                c.ShouldBindJSON(&amp;req)
                
                user := GetCurrentUser(c)
                log.Printf("User %s initiated chat session", user.Username)
                
                c.JSON(200, gin.H{
                        "message": map[string]interface{}{
                                "role":    "assistant",
                                "content": "Hello! I'm your AI assistant powered by the distributed Ollama system.",
                        },
                        "user": user.Username,
                })
        }</span>)
        
        // Embeddings endpoint - requires write permission
        <span class="cov0" title="0">api.POST("/embeddings", helpers.RequireInferencePermission("write"), func(c *gin.Context) </span><span class="cov0" title="0">{
                var req map[string]interface{}
                c.ShouldBindJSON(&amp;req)
                
                user := GetCurrentUser(c)
                log.Printf("User %s requested embeddings", user.Username)
                
                c.JSON(200, gin.H{
                        "embeddings": []float64{0.1, 0.2, 0.3, 0.4, 0.5},
                        "model":      req["model"],
                        "user":       user.Username,
                })
        }</span>)
}

// setupMonitoringRoutes configures monitoring routes
func setupMonitoringRoutes(api *gin.RouterGroup, helpers *MiddlewareHelpers) <span class="cov0" title="0">{
        // Metrics endpoint - requires read permission
        api.GET("/metrics", helpers.RequireInferencePermission("read"), func(c *gin.Context) </span><span class="cov0" title="0">{
                user := GetCurrentUser(c)
                log.Printf("User %s requested metrics", user.Username)
                
                c.JSON(200, gin.H{
                        "metrics": map[string]interface{}{
                                "nodes_online":       2,
                                "models_loaded":      5,
                                "requests_processed": 1500,
                                "cpu_usage":          45.2,
                                "memory_usage":       62.8,
                                "network_usage":      23.1,
                        },
                        "timestamp": time.Now().Unix(),
                })
        }</span>)
        
        // Health check - no authentication required for monitoring
        <span class="cov0" title="0">api.GET("/health", func(c *gin.Context) </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{
                        "status":    "healthy",
                        "timestamp": time.Now().Unix(),
                        "version":   "1.0.0",
                })
        }</span>)
        
        // Transfers endpoint
        <span class="cov0" title="0">api.GET("/transfers", helpers.RequireInferencePermission("read"), func(c *gin.Context) </span><span class="cov0" title="0">{
                user := GetCurrentUser(c)
                log.Printf("User %s requested transfer status", user.Username)
                
                c.JSON(200, gin.H{
                        "transfers": []map[string]interface{}{
                                {
                                        "id":       "transfer-1",
                                        "model":    "llama2",
                                        "status":   "completed",
                                        "progress": 100,
                                },
                        },
                })
        }</span>)
}

// setupDistributionRoutes configures distribution management routes
func setupDistributionRoutes(api *gin.RouterGroup, helpers *MiddlewareHelpers) <span class="cov0" title="0">{
        distribution := api.Group("/distribution")
        
        // Auto-configure distribution - requires admin permission
        distribution.POST("/auto-configure", helpers.RequireClusterPermission("admin"), func(c *gin.Context) </span><span class="cov0" title="0">{
                var req map[string]interface{}
                c.ShouldBindJSON(&amp;req)
                
                user := GetCurrentUser(c)
                log.Printf("User %s configured auto-distribution", user.Username)
                
                c.JSON(200, gin.H{
                        "message": "Auto-distribution configured",
                        "enabled": req["enabled"],
                })
        }</span>)
}

// setupPublicRoutes configures public routes that don't require authentication
func setupPublicRoutes(router *gin.Engine) <span class="cov0" title="0">{
        // Serve static files for web UI
        router.Static("/static", "./web/static")
        router.StaticFile("/", "./web/index.html")
        router.StaticFile("/favicon.ico", "./web/favicon.ico")
        
        // Catch-all for SPA routing
        router.NoRoute(func(c *gin.Context) </span><span class="cov0" title="0">{
                c.File("./web/index.html")
        }</span>)
}

// DemoUsage shows how to use the authentication system programmatically
func DemoUsage() <span class="cov0" title="0">{
        // Create auth config
        cfg := &amp;config.AuthConfig{
                Enabled:     true,
                Method:      "jwt",
                TokenExpiry: 24 * time.Hour,
                SecretKey:   "demo-secret-key",
                Issuer:      "ollama-distributed",
                Audience:    "ollama-api",
        }
        
        // Create auth manager
        authManager, err := NewManager(cfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create auth manager: %v", err)
        }</span>
        <span class="cov0" title="0">defer authManager.Close()
        
        // Create a new user
        userReq := &amp;CreateUserRequest{
                Username: "demo-user",
                Email:    "demo@example.com",
                Password: "secure-password",
                Role:     RoleUser,
        }
        
        user, err := authManager.CreateUser(userReq)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create user: %v", err)
        }</span>
        
        <span class="cov0" title="0">log.Printf("Created user: %s (ID: %s)", user.Username, user.ID)
        
        // Authenticate user
        authCtx, err := authManager.Authenticate("demo-user", "secure-password", map[string]string{
                "ip_address": "127.0.0.1",
                "user_agent": "demo-client",
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to authenticate: %v", err)
        }</span>
        
        <span class="cov0" title="0">log.Printf("Authentication successful! Token: %s", authCtx.TokenString[:50]+"...")
        
        // Create API key
        apiKeyReq := &amp;CreateAPIKeyRequest{
                Name:        "Demo API Key",
                Permissions: []string{PermissionModelRead, PermissionInferenceWrite},
        }
        
        apiKey, rawKey, err := authManager.CreateAPIKey(user.ID, apiKeyReq)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create API key: %v", err)
        }</span>
        
        <span class="cov0" title="0">log.Printf("Created API key: %s (Key: %s)", apiKey.Name, rawKey[:20]+"...")
        
        // Validate API key
        apiAuthCtx, err := authManager.ValidateAPIKey(rawKey)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to validate API key: %v", err)
        }</span>
        
        <span class="cov0" title="0">log.Printf("API key validation successful for user: %s", apiAuthCtx.User.Username)
        
        // Check permissions
        hasModelRead := authManager.HasPermission(apiAuthCtx, PermissionModelRead)
        hasSystemAdmin := authManager.HasPermission(apiAuthCtx, PermissionSystemAdmin)
        
        log.Printf("User has model read permission: %v", hasModelRead)
        log.Printf("User has system admin permission: %v", hasSystemAdmin)</span>
}</pre>
		
		<pre class="file" id="file6" style="display: none">package auth

import (
        "time"

        "github.com/golang-jwt/jwt/v5"
)

// User represents a system user
type User struct {
        ID          string            `json:"id"`
        Username    string            `json:"username"`
        Email       string            `json:"email,omitempty"`
        Role        string            `json:"role"`
        Permissions []string          `json:"permissions"`
        APIKeys     []APIKey          `json:"api_keys,omitempty"`
        Metadata    map[string]string `json:"metadata,omitempty"`
        CreatedAt   time.Time         `json:"created_at"`
        UpdatedAt   time.Time         `json:"updated_at"`
        LastLoginAt *time.Time        `json:"last_login_at,omitempty"`
        Active      bool              `json:"active"`
}

// APIKey represents an API key for authentication
type APIKey struct {
        ID          string            `json:"id"`
        Name        string            `json:"name"`
        Key         string            `json:"key"`
        UserID      string            `json:"user_id"`
        Permissions []string          `json:"permissions"`
        Metadata    map[string]string `json:"metadata,omitempty"`
        ExpiresAt   *time.Time        `json:"expires_at,omitempty"`
        CreatedAt   time.Time         `json:"created_at"`
        LastUsedAt  *time.Time        `json:"last_used_at,omitempty"`
        Active      bool              `json:"active"`
}

// Session represents an authentication session
type Session struct {
        ID        string            `json:"id"`
        UserID    string            `json:"user_id"`
        TokenID   string            `json:"token_id"`
        IPAddress string            `json:"ip_address"`
        UserAgent string            `json:"user_agent"`
        Metadata  map[string]string `json:"metadata,omitempty"`
        CreatedAt time.Time         `json:"created_at"`
        ExpiresAt time.Time         `json:"expires_at"`
        Active    bool              `json:"active"`
}

// Claims represents JWT claims for the system
type Claims struct {
        UserID      string            `json:"user_id"`
        Username    string            `json:"username"`
        Email       string            `json:"email,omitempty"`
        Role        string            `json:"role"`
        Permissions []string          `json:"permissions"`
        SessionID   string            `json:"session_id,omitempty"`
        APIKeyID    string            `json:"api_key_id,omitempty"`
        Metadata    map[string]string `json:"metadata,omitempty"`
        jwt.RegisteredClaims
}

// AuthContext contains authentication information for a request
type AuthContext struct {
        User        *User     `json:"user"`
        Session     *Session  `json:"session,omitempty"`
        APIKey      *APIKey   `json:"api_key,omitempty"`
        Claims      *Claims   `json:"claims"`
        TokenString string    `json:"-"`
        Method      AuthMethod `json:"method"`
}

// AuthMethod represents the authentication method used
type AuthMethod string

const (
        AuthMethodJWT    AuthMethod = "jwt"
        AuthMethodAPIKey AuthMethod = "api_key"
        AuthMethodX509   AuthMethod = "x509"
        AuthMethodNone   AuthMethod = "none"
)

// Permission constants
const (
        PermissionNodeRead       = "node:read"
        PermissionNodeWrite      = "node:write"
        PermissionNodeAdmin      = "node:admin"
        PermissionModelRead      = "model:read"
        PermissionModelWrite     = "model:write"
        PermissionModelAdmin     = "model:admin"
        PermissionClusterRead    = "cluster:read"
        PermissionClusterWrite   = "cluster:write"
        PermissionClusterAdmin   = "cluster:admin"
        PermissionInferenceRead  = "inference:read"
        PermissionInferenceWrite = "inference:write"
        PermissionMetricsRead    = "metrics:read"
        PermissionSystemAdmin    = "system:admin"
        PermissionUserAdmin      = "user:admin"
)

// Role constants
const (
        RoleAdmin     = "admin"
        RoleOperator  = "operator"
        RoleUser      = "user"
        RoleReadOnly  = "readonly"
        RoleService   = "service"
)

// Default role permissions
var DefaultRolePermissions = map[string][]string{
        RoleAdmin: {
                PermissionSystemAdmin,
                PermissionUserAdmin,
                PermissionNodeAdmin,
                PermissionModelAdmin,
                PermissionClusterAdmin,
                PermissionInferenceWrite,
                PermissionMetricsRead,
        },
        RoleOperator: {
                PermissionNodeWrite,
                PermissionModelWrite,
                PermissionClusterWrite,
                PermissionInferenceWrite,
                PermissionMetricsRead,
        },
        RoleUser: {
                PermissionNodeRead,
                PermissionModelRead,
                PermissionClusterRead,
                PermissionInferenceWrite,
                PermissionMetricsRead,
        },
        RoleReadOnly: {
                PermissionNodeRead,
                PermissionModelRead,
                PermissionClusterRead,
                PermissionInferenceRead,
                PermissionMetricsRead,
        },
        RoleService: {
                PermissionNodeRead,
                PermissionModelRead,
                PermissionInferenceWrite,
        },
}

// AuthError represents authentication errors
type AuthError struct {
        Code    string `json:"code"`
        Message string `json:"message"`
        Details string `json:"details,omitempty"`
}

func (e AuthError) Error() string <span class="cov0" title="0">{
        if e.Details != "" </span><span class="cov0" title="0">{
                return e.Message + ": " + e.Details
        }</span>
        <span class="cov0" title="0">return e.Message</span>
}

// Common authentication errors
var (
        ErrInvalidCredentials = AuthError{
                Code:    "INVALID_CREDENTIALS",
                Message: "Invalid credentials provided",
        }
        ErrTokenExpired = AuthError{
                Code:    "TOKEN_EXPIRED",
                Message: "Authentication token has expired",
        }
        ErrTokenInvalid = AuthError{
                Code:    "TOKEN_INVALID",
                Message: "Authentication token is invalid",
        }
        ErrTokenBlacklisted = AuthError{
                Code:    "TOKEN_BLACKLISTED",
                Message: "Authentication token has been revoked",
        }
        ErrInsufficientPermissions = AuthError{
                Code:    "INSUFFICIENT_PERMISSIONS",
                Message: "Insufficient permissions for this operation",
        }
        ErrUserNotFound = AuthError{
                Code:    "USER_NOT_FOUND",
                Message: "User not found",
        }
        ErrUserInactive = AuthError{
                Code:    "USER_INACTIVE",
                Message: "User account is inactive",
        }
        ErrAPIKeyNotFound = AuthError{
                Code:    "API_KEY_NOT_FOUND",
                Message: "API key not found",
        }
        ErrAPIKeyInactive = AuthError{
                Code:    "API_KEY_INACTIVE",
                Message: "API key is inactive",
        }
        ErrAPIKeyExpired = AuthError{
                Code:    "API_KEY_EXPIRED",
                Message: "API key has expired",
        }
        ErrSessionNotFound = AuthError{
                Code:    "SESSION_NOT_FOUND",
                Message: "Session not found",
        }
        ErrSessionExpired = AuthError{
                Code:    "SESSION_EXPIRED",
                Message: "Session has expired",
        }
)

// LoginRequest represents a login request
type LoginRequest struct {
        Username string `json:"username" binding:"required"`
        Password string `json:"password" binding:"required"`
        Metadata map[string]string `json:"metadata,omitempty"`
}

// LoginResponse represents a login response
type LoginResponse struct {
        Token     string    `json:"token"`
        ExpiresAt time.Time `json:"expires_at"`
        User      *User     `json:"user"`
        SessionID string    `json:"session_id"`
}

// RefreshRequest represents a token refresh request
type RefreshRequest struct {
        Token string `json:"token" binding:"required"`
}

// CreateAPIKeyRequest represents an API key creation request
type CreateAPIKeyRequest struct {
        Name        string            `json:"name" binding:"required"`
        Permissions []string          `json:"permissions,omitempty"`
        ExpiresAt   *time.Time        `json:"expires_at,omitempty"`
        Metadata    map[string]string `json:"metadata,omitempty"`
}

// CreateAPIKeyResponse represents an API key creation response
type CreateAPIKeyResponse struct {
        APIKey *APIKey `json:"api_key"`
        Key    string  `json:"key"` // Only returned once during creation
}

// CreateUserRequest represents a user creation request
type CreateUserRequest struct {
        Username    string            `json:"username" binding:"required"`
        Email       string            `json:"email,omitempty"`
        Password    string            `json:"password" binding:"required"`
        Role        string            `json:"role" binding:"required"`
        Permissions []string          `json:"permissions,omitempty"`
        Metadata    map[string]string `json:"metadata,omitempty"`
}

// UpdateUserRequest represents a user update request
type UpdateUserRequest struct {
        Email       *string           `json:"email,omitempty"`
        Role        *string           `json:"role,omitempty"`
        Permissions []string          `json:"permissions,omitempty"`
        Metadata    map[string]string `json:"metadata,omitempty"`
        Active      *bool             `json:"active,omitempty"`
}

// ChangePasswordRequest represents a password change request
type ChangePasswordRequest struct {
        CurrentPassword string `json:"current_password" binding:"required"`
        NewPassword     string `json:"new_password" binding:"required"`
}</pre>
		
		<pre class="file" id="file7" style="display: none">package config

import (
        "fmt"
        "os"
        "path/filepath"
        "time"

        "github.com/spf13/viper"
)

// Config represents the complete configuration for a distributed Ollama node
type Config struct {
        // Node configuration
        Node        NodeConfig        `yaml:"node"`
        API         APIConfig         `yaml:"api"`
        P2P         P2PConfig         `yaml:"p2p"`
        Consensus   ConsensusConfig   `yaml:"consensus"`
        Scheduler   SchedulerConfig   `yaml:"scheduler"`
        Storage     StorageConfig     `yaml:"storage"`
        Security    SecurityConfig    `yaml:"security"`
        Web         WebConfig         `yaml:"web"`
        Metrics     MetricsConfig     `yaml:"metrics"`
        Logging     LoggingConfig     `yaml:"logging"`
        Sync        SyncConfig        `yaml:"sync"`
        Replication ReplicationConfig `yaml:"replication"`
        Distributed DistributedConfig `yaml:"distributed"`
}

// NodeConfig holds node-specific configuration
type NodeConfig struct {
        ID          string            `yaml:"id"`
        Name        string            `yaml:"name"`
        Region      string            `yaml:"region"`
        Zone        string            `yaml:"zone"`
        Environment string            `yaml:"environment"`
        Tags        map[string]string `yaml:"tags"`
}

// APIConfig holds API server configuration
type APIConfig struct {
        Listen      string        `yaml:"listen"`
        TLS         TLSConfig     `yaml:"tls"`
        Cors        CorsConfig    `yaml:"cors"`
        RateLimit   RateLimitConfig `yaml:"rate_limit"`
        Timeout     time.Duration `yaml:"timeout"`
        MaxBodySize int64         `yaml:"max_body_size"`
}

// P2PConfig holds P2P networking configuration
type P2PConfig struct {
        Listen        string   `yaml:"listen"`
        Bootstrap     []string `yaml:"bootstrap"`
        PrivateKey    string   `yaml:"private_key"`
        EnableDHT     bool     `yaml:"enable_dht"`
        EnablePubSub  bool     `yaml:"enable_pubsub"`
        ConnMgrLow    int      `yaml:"conn_mgr_low"`
        ConnMgrHigh   int      `yaml:"conn_mgr_high"`
        ConnMgrGrace  string   `yaml:"conn_mgr_grace"`
        DialTimeout   time.Duration `yaml:"dial_timeout"`
        MaxStreams    int      `yaml:"max_streams"`
}

// ConsensusConfig holds consensus engine configuration
type ConsensusConfig struct {
        DataDir          string        `yaml:"data_dir"`
        BindAddr         string        `yaml:"bind_addr"`
        AdvertiseAddr    string        `yaml:"advertise_addr"`
        Bootstrap        bool          `yaml:"bootstrap"`
        LogLevel         string        `yaml:"log_level"`
        HeartbeatTimeout time.Duration `yaml:"heartbeat_timeout"`
        ElectionTimeout  time.Duration `yaml:"election_timeout"`
        CommitTimeout    time.Duration `yaml:"commit_timeout"`
        MaxAppendEntries int           `yaml:"max_append_entries"`
        SnapshotInterval time.Duration `yaml:"snapshot_interval"`
        SnapshotThreshold uint64       `yaml:"snapshot_threshold"`
}

// SchedulerConfig holds scheduler configuration
type SchedulerConfig struct {
        Algorithm        string        `yaml:"algorithm"`
        LoadBalancing    string        `yaml:"load_balancing"`
        HealthCheckInterval time.Duration `yaml:"health_check_interval"`
        MaxRetries       int           `yaml:"max_retries"`
        RetryDelay       time.Duration `yaml:"retry_delay"`
        QueueSize        int           `yaml:"queue_size"`
        WorkerCount      int           `yaml:"worker_count"`
}

// StorageConfig holds storage configuration
type StorageConfig struct {
        DataDir     string `yaml:"data_dir"`
        ModelDir    string `yaml:"model_dir"`
        CacheDir    string `yaml:"cache_dir"`
        MaxDiskSize int64  `yaml:"max_disk_size"`
        CleanupAge  time.Duration `yaml:"cleanup_age"`
}

// SecurityConfig holds security configuration
type SecurityConfig struct {
        TLS         TLSConfig         `yaml:"tls"`
        Auth        AuthConfig        `yaml:"auth"`
        Encryption  EncryptionConfig  `yaml:"encryption"`
        Firewall    FirewallConfig    `yaml:"firewall"`
        Audit       AuditConfig       `yaml:"audit"`
}

// TLSConfig holds TLS configuration
type TLSConfig struct {
        Enabled    bool   `yaml:"enabled"`
        CertFile   string `yaml:"cert_file"`
        KeyFile    string `yaml:"key_file"`
        CAFile     string `yaml:"ca_file"`
        MinVersion string `yaml:"min_version"`
        CipherSuites []string `yaml:"cipher_suites"`
}

// AuthConfig holds authentication configuration
type AuthConfig struct {
        Enabled     bool          `yaml:"enabled"`
        Method      string        `yaml:"method"` // jwt, oauth, x509
        TokenExpiry time.Duration `yaml:"token_expiry"`
        SecretKey   string        `yaml:"secret_key"`
        Issuer      string        `yaml:"issuer"`
        Audience    string        `yaml:"audience"`
}

// EncryptionConfig holds encryption configuration
type EncryptionConfig struct {
        Algorithm string `yaml:"algorithm"`
        KeySize   int    `yaml:"key_size"`
        KeyFile   string `yaml:"key_file"`
}

// FirewallConfig holds firewall configuration
type FirewallConfig struct {
        Enabled    bool     `yaml:"enabled"`
        AllowedIPs []string `yaml:"allowed_ips"`
        BlockedIPs []string `yaml:"blocked_ips"`
        Rules      []FirewallRule `yaml:"rules"`
}

// FirewallRule represents a firewall rule
type FirewallRule struct {
        Protocol string `yaml:"protocol"`
        Port     int    `yaml:"port"`
        Action   string `yaml:"action"`
        Source   string `yaml:"source"`
}

// AuditConfig holds audit configuration
type AuditConfig struct {
        Enabled bool   `yaml:"enabled"`
        LogFile string `yaml:"log_file"`
        Format  string `yaml:"format"`
}

// CorsConfig holds CORS configuration
type CorsConfig struct {
        Enabled          bool     `yaml:"enabled"`
        AllowedOrigins   []string `yaml:"allowed_origins"`
        AllowedMethods   []string `yaml:"allowed_methods"`
        AllowedHeaders   []string `yaml:"allowed_headers"`
        ExposedHeaders   []string `yaml:"exposed_headers"`
        AllowCredentials bool     `yaml:"allow_credentials"`
        MaxAge           int      `yaml:"max_age"`
}

// RateLimitConfig holds rate limiting configuration
type RateLimitConfig struct {
        Enabled bool  `yaml:"enabled"`
        RPS     int   `yaml:"rps"`
        Burst   int   `yaml:"burst"`
        Window  time.Duration `yaml:"window"`
}

// WebConfig holds web interface configuration
type WebConfig struct {
        Enabled    bool   `yaml:"enabled"`
        Listen     string `yaml:"listen"`
        StaticDir  string `yaml:"static_dir"`
        TemplateDir string `yaml:"template_dir"`
        TLS        TLSConfig `yaml:"tls"`
}

// MetricsConfig holds metrics configuration
type MetricsConfig struct {
        Enabled    bool   `yaml:"enabled"`
        Listen     string `yaml:"listen"`
        Path       string `yaml:"path"`
        Namespace  string `yaml:"namespace"`
        Subsystem  string `yaml:"subsystem"`
}

// LoggingConfig holds logging configuration
type LoggingConfig struct {
        Level      string `yaml:"level"`
        Format     string `yaml:"format"`
        Output     string `yaml:"output"`
        File       string `yaml:"file"`
        MaxSize    int    `yaml:"max_size"`
        MaxAge     int    `yaml:"max_age"`
        MaxBackups int    `yaml:"max_backups"`
        Compress   bool   `yaml:"compress"`
}

// SyncConfig holds model synchronization configuration
type SyncConfig struct {
        DeltaDir       string        `yaml:"delta_dir"`
        CASDir         string        `yaml:"cas_dir"`
        WorkerCount    int           `yaml:"worker_count"`
        SyncInterval   time.Duration `yaml:"sync_interval"`
        ChunkSize      int64         `yaml:"chunk_size"`
        MaxRetries     int           `yaml:"max_retries"`
        RetryDelay     time.Duration `yaml:"retry_delay"`
}

// ReplicationConfig holds model replication configuration
type ReplicationConfig struct {
        WorkerCount                int           `yaml:"worker_count"`
        DefaultMinReplicas         int           `yaml:"default_min_replicas"`
        DefaultMaxReplicas         int           `yaml:"default_max_replicas"`
        DefaultReplicationFactor   int           `yaml:"default_replication_factor"`
        DefaultSyncInterval        time.Duration `yaml:"default_sync_interval"`
        PolicyEnforcementInterval  time.Duration `yaml:"policy_enforcement_interval"`
        HealthCheckInterval        time.Duration `yaml:"health_check_interval"`
        HealthCheckTimeout         time.Duration `yaml:"health_check_timeout"`
}

// DistributedConfig holds distributed model management configuration
type DistributedConfig struct {
        Storage     *StorageConfig     `yaml:"storage"`
        Sync        *SyncConfig        `yaml:"sync"`
        Replication *ReplicationConfig `yaml:"replication"`
        CASDir      string             `yaml:"cas_dir"`
        DeltaDir    string             `yaml:"delta_dir"`
}

// DefaultConfig returns a default configuration
func DefaultConfig() *Config <span class="cov0" title="0">{
        // Create storage config first
        storageConfig := StorageConfig{
                DataDir:     "./data",
                ModelDir:    "./models",
                CacheDir:    "./cache",
                MaxDiskSize: 100 * 1024 * 1024 * 1024, // 100GB
                CleanupAge:  7 * 24 * time.Hour,       // 7 days
        }
        
        // Create sync config
        syncConfig := SyncConfig{
                DeltaDir:     "./data/deltas",
                CASDir:       "./data/cas",
                WorkerCount:  3,
                SyncInterval: 5 * time.Minute,
                ChunkSize:    1024 * 1024, // 1MB
                MaxRetries:   3,
                RetryDelay:   time.Second,
        }
        
        // Create replication config
        replicationConfig := ReplicationConfig{
                WorkerCount:                3,
                DefaultMinReplicas:         1,
                DefaultMaxReplicas:         3,
                DefaultReplicationFactor:   2,
                DefaultSyncInterval:        10 * time.Minute,
                PolicyEnforcementInterval:  30 * time.Second,
                HealthCheckInterval:        30 * time.Second,
                HealthCheckTimeout:         10 * time.Second,
        }
        
        return &amp;Config{
                Node: NodeConfig{
                        ID:          "",
                        Name:        "ollama-node",
                        Region:      "us-west-2",
                        Zone:        "us-west-2a",
                        Environment: "production",
                        Tags:        make(map[string]string),
                },
                API: APIConfig{
                        Listen:      "0.0.0.0:11434",
                        Timeout:     30 * time.Second,
                        MaxBodySize: 32 * 1024 * 1024, // 32MB
                        TLS: TLSConfig{
                                Enabled:    false,
                                MinVersion: "1.2",
                        },
                        Cors: CorsConfig{
                                Enabled:          true,
                                AllowedOrigins:   []string{"http://localhost:8080", "https://localhost:8080"},
                                AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
                                AllowedHeaders:   []string{"Content-Type", "Authorization", "X-Requested-With"},
                                AllowCredentials: true,
                                MaxAge:           3600,
                        },
                        RateLimit: RateLimitConfig{
                                Enabled: true,
                                RPS:     1000,
                                Burst:   2000,
                                Window:  time.Minute,
                        },
                },
                P2P: P2PConfig{
                        Listen:        "/ip4/0.0.0.0/tcp/4001",
                        Bootstrap:     []string{},
                        EnableDHT:     true,
                        EnablePubSub:  true,
                        ConnMgrLow:    50,
                        ConnMgrHigh:   200,
                        ConnMgrGrace:  "30s",
                        DialTimeout:   30 * time.Second,
                        MaxStreams:    1000,
                },
                Consensus: ConsensusConfig{
                        DataDir:           "./data/consensus",
                        BindAddr:          "0.0.0.0:7000",
                        AdvertiseAddr:     "",
                        Bootstrap:         false,
                        LogLevel:          "INFO",
                        HeartbeatTimeout:  1 * time.Second,
                        ElectionTimeout:   1 * time.Second,
                        CommitTimeout:     50 * time.Millisecond,
                        MaxAppendEntries:  64,
                        SnapshotInterval:  120 * time.Second,
                        SnapshotThreshold: 8192,
                },
                Scheduler: SchedulerConfig{
                        Algorithm:           "round_robin",
                        LoadBalancing:       "least_connections",
                        HealthCheckInterval: 30 * time.Second,
                        MaxRetries:          3,
                        RetryDelay:          1 * time.Second,
                        QueueSize:           10000,
                        WorkerCount:         10,
                },
                Storage: storageConfig,
                Security: SecurityConfig{
                        TLS: TLSConfig{
                                Enabled:    true,
                                MinVersion: "1.3",
                        },
                        Auth: AuthConfig{
                                Enabled:     true,
                                Method:      "jwt",
                                TokenExpiry: 24 * time.Hour,
                        },
                        Encryption: EncryptionConfig{
                                Algorithm: "AES-256-GCM",
                                KeySize:   256,
                        },
                        Firewall: FirewallConfig{
                                Enabled: true,
                                Rules:   []FirewallRule{},
                        },
                        Audit: AuditConfig{
                                Enabled: true,
                                LogFile: "./logs/audit.log",
                                Format:  "json",
                        },
                },
                Web: WebConfig{
                        Enabled:   true,
                        Listen:    "0.0.0.0:8080",
                        StaticDir: "./web/static",
                        TLS: TLSConfig{
                                Enabled: false,
                        },
                },
                Metrics: MetricsConfig{
                        Enabled:   true,
                        Listen:    "0.0.0.0:9090",
                        Path:      "/metrics",
                        Namespace: "ollama",
                        Subsystem: "distributed",
                },
                Logging: LoggingConfig{
                        Level:      "info",
                        Format:     "json",
                        Output:     "stdout",
                        MaxSize:    100,
                        MaxAge:     30,
                        MaxBackups: 10,
                        Compress:   true,
                },
                Sync:        syncConfig,
                Replication: replicationConfig,
                Distributed: DistributedConfig{
                        Storage:     &amp;storageConfig,
                        Sync:        &amp;syncConfig,
                        Replication: &amp;replicationConfig,
                        CASDir:      "./data/cas",
                        DeltaDir:    "./data/deltas",
                },
        }
}</span>

// Load loads configuration from file
func Load(configFile string) (*Config, error) <span class="cov0" title="0">{
        config := DefaultConfig()
        
        if configFile != "" </span><span class="cov0" title="0">{
                viper.SetConfigFile(configFile)
        }</span> else<span class="cov0" title="0"> {
                // Look for config in standard locations
                viper.SetConfigName("config")
                viper.SetConfigType("yaml")
                viper.AddConfigPath(".")
                viper.AddConfigPath("./config")
                viper.AddConfigPath("$HOME/.ollama-distributed")
                viper.AddConfigPath("/etc/ollama-distributed")
        }</span>
        
        // Environment variables
        <span class="cov0" title="0">viper.SetEnvPrefix("OLLAMA")
        viper.AutomaticEnv()
        
        // Read configuration
        if err := viper.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(viper.ConfigFileNotFoundError); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to read config file: %w", err)
                }</span>
        }
        
        // Unmarshal into config struct
        <span class="cov0" title="0">if err := viper.Unmarshal(config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal config: %w", err)
        }</span>
        
        // Validate and set defaults
        <span class="cov0" title="0">if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid configuration: %w", err)
        }</span>
        
        <span class="cov0" title="0">return config, nil</span>
}

// Validate validates the configuration
func (c *Config) Validate() error <span class="cov0" title="0">{
        // Validate directories exist or can be created
        dirs := []string{
                c.Storage.DataDir,
                c.Storage.ModelDir,
                c.Storage.CacheDir,
                c.Consensus.DataDir,
                c.Sync.DeltaDir,
                c.Sync.CASDir,
                c.Distributed.CASDir,
                c.Distributed.DeltaDir,
        }
        
        for _, dir := range dirs </span><span class="cov0" title="0">{
                if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create directory %s: %w", dir, err)
                }</span>
        }
        
        // Validate log directory
        <span class="cov0" title="0">if c.Logging.Output == "file" &amp;&amp; c.Logging.File != "" </span><span class="cov0" title="0">{
                logDir := filepath.Dir(c.Logging.File)
                if err := os.MkdirAll(logDir, 0755); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create log directory %s: %w", logDir, err)
                }</span>
        }
        
        // Validate TLS certificates if enabled
        <span class="cov0" title="0">if c.Security.TLS.Enabled </span><span class="cov0" title="0">{
                if c.Security.TLS.CertFile == "" || c.Security.TLS.KeyFile == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("TLS enabled but cert_file or key_file not specified")
                }</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// Save saves the configuration to a file
func (c *Config) Save(filename string) error <span class="cov0" title="0">{
        viper.Set("config", c)
        return viper.WriteConfigAs(filename)
}</pre>
		
		<pre class="file" id="file8" style="display: none">package metrics

import (
        "context"
        "fmt"
        "net/http"
        "time"

        "github.com/ollama/ollama-distributed/internal/config"
        "github.com/rs/zerolog/log"
)

// Server represents a metrics server
type Server struct {
        config *config.MetricsConfig
        server *http.Server
}

// NewServer creates a new metrics server
func NewServer(config config.MetricsConfig) (*Server, error) <span class="cov0" title="0">{
        mux := http.NewServeMux()
        
        // Add basic metrics endpoint
        mux.HandleFunc("/metrics", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "text/plain")
                w.WriteHeader(http.StatusOK)
                fmt.Fprintf(w, "# Ollamacron Metrics\n")
                fmt.Fprintf(w, "# TYPE ollamacron_info gauge\n")
                fmt.Fprintf(w, "ollamacron_info{version=\"dev\"} 1\n")
                fmt.Fprintf(w, "# TYPE ollamacron_uptime_seconds counter\n")
                fmt.Fprintf(w, "ollamacron_uptime_seconds %d\n", time.Now().Unix())
        }</span>)
        
        // Add health endpoint
        <span class="cov0" title="0">mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusOK)
                fmt.Fprintf(w, `{"status":"healthy","timestamp":"%s"}`, time.Now().Format(time.RFC3339))
        }</span>)
        
        <span class="cov0" title="0">server := &amp;http.Server{
                Addr:         config.Listen,
                Handler:      mux,
                ReadTimeout:  10 * time.Second,
                WriteTimeout: 10 * time.Second,
        }
        
        return &amp;Server{
                config: &amp;config,
                server: server,
        }, nil</span>
}

// Start starts the metrics server
func (s *Server) Start() error <span class="cov0" title="0">{
        log.Info().Str("address", s.config.Listen).Msg("Starting metrics server")
        
        go func() </span><span class="cov0" title="0">{
                if err := s.server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Error().Err(err).Msg("Metrics server error")
                }</span>
        }()
        
        <span class="cov0" title="0">return nil</span>
}

// Shutdown shuts down the metrics server
func (s *Server) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        log.Info().Msg("Shutting down metrics server")
        return s.server.Shutdown(ctx)
}</pre>
		
		<pre class="file" id="file9" style="display: none">package config

import (
        "time"
        "crypto/rand"
        "github.com/libp2p/go-libp2p/core/crypto"
        "github.com/libp2p/go-libp2p/core/peer"
        "github.com/multiformats/go-multiaddr"
)

// NodeConfig holds all configuration for a P2P node
type NodeConfig struct {
        // Network Settings
        Listen              []string            `yaml:"listen"`
        AnnounceAddresses   []string            `yaml:"announce_addresses"`
        NoAnnounceAddresses []string            `yaml:"no_announce_addresses"`
        
        // Security
        PrivateKey          string              `yaml:"private_key"`
        EnableTLS           bool                `yaml:"enable_tls"`
        EnableNoise         bool                `yaml:"enable_noise"`
        
        // NAT Traversal
        EnableNATService    bool                `yaml:"enable_nat_service"`
        EnableHolePunching  bool                `yaml:"enable_hole_punching"`
        EnableAutoRelay     bool                `yaml:"enable_auto_relay"`
        StaticRelays        []string            `yaml:"static_relays"`
        ForceReachability   string              `yaml:"force_reachability"` // public/private
        
        // DHT Settings
        EnableDHT           bool                `yaml:"enable_dht"`
        DHTMode             string              `yaml:"dht_mode"` // client/server/auto
        BootstrapPeers      []string            `yaml:"bootstrap_peers"`
        
        // Connection Management
        ConnMgrLow          int                 `yaml:"conn_mgr_low"`
        ConnMgrHigh         int                 `yaml:"conn_mgr_high"`
        ConnMgrGrace        time.Duration       `yaml:"conn_mgr_grace"`
        
        // Resource Management
        MaxMemory           int64               `yaml:"max_memory"`
        MaxCPU              float64             `yaml:"max_cpu"`
        MaxGPU              int                 `yaml:"max_gpu"`
        
        // Ollamacron Specific
        NodeType            string              `yaml:"node_type"` // edge/standard/super
        ModelCapabilities   []string            `yaml:"model_capabilities"`
        ResourceTags        map[string]string   `yaml:"resource_tags"`
        
        // Discovery Settings
        RendezvousString    string              `yaml:"rendezvous_string"`
        AutoDiscovery       bool                `yaml:"auto_discovery"`
}

// DefaultConfig returns a default configuration for a P2P node
func DefaultConfig() *NodeConfig <span class="cov0" title="0">{
        return &amp;NodeConfig{
                Listen: []string{
                        "/ip4/0.0.0.0/tcp/0",
                        "/ip6/::/tcp/0",
                        "/ip4/0.0.0.0/udp/0/quic",
                        "/ip6/::/udp/0/quic",
                },
                EnableTLS:           true,
                EnableNoise:         true,
                EnableNATService:    true,
                EnableHolePunching:  true,
                EnableAutoRelay:     true,
                EnableDHT:           true,
                DHTMode:             "auto",
                ConnMgrLow:          50,
                ConnMgrHigh:         200,
                ConnMgrGrace:        time.Minute,
                NodeType:            "standard",
                ModelCapabilities:   []string{},
                ResourceTags:        make(map[string]string),
                RendezvousString:    "ollama-distributed",
                AutoDiscovery:       true,
        }
}</span>

// GenerateKey generates a new cryptographic identity for the node
func (c *NodeConfig) GenerateKey() error <span class="cov0" title="0">{
        priv, _, err := crypto.GenerateKeyPairWithReader(crypto.RSA, 2048, rand.Reader)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov0" title="0">keyBytes, err := crypto.MarshalPrivateKey(priv)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov0" title="0">c.PrivateKey = crypto.ConfigEncodeKey(keyBytes)
        return nil</span>
}

// GetPrivateKey retrieves the private key from configuration
func (c *NodeConfig) GetPrivateKey() (crypto.PrivKey, error) <span class="cov0" title="0">{
        if c.PrivateKey == "" </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        
        <span class="cov0" title="0">keyBytes, err := crypto.ConfigDecodeKey(c.PrivateKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">return crypto.UnmarshalPrivateKey(keyBytes)</span>
}

// ParseBootstrapPeers parses bootstrap peer addresses
func (c *NodeConfig) ParseBootstrapPeers() ([]peer.AddrInfo, error) <span class="cov0" title="0">{
        var peers []peer.AddrInfo
        
        for _, addr := range c.BootstrapPeers </span><span class="cov0" title="0">{
                maddr, err := multiaddr.NewMultiaddr(addr)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov0" title="0">peerInfo, err := peer.AddrInfoFromP2pAddr(maddr)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov0" title="0">peers = append(peers, *peerInfo)</span>
        }
        
        <span class="cov0" title="0">return peers, nil</span>
}

// ParseStaticRelays parses static relay addresses
func (c *NodeConfig) ParseStaticRelays() ([]peer.AddrInfo, error) <span class="cov0" title="0">{
        var relays []peer.AddrInfo
        
        for _, addr := range c.StaticRelays </span><span class="cov0" title="0">{
                maddr, err := multiaddr.NewMultiaddr(addr)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov0" title="0">peerInfo, err := peer.AddrInfoFromP2pAddr(maddr)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov0" title="0">relays = append(relays, *peerInfo)</span>
        }
        
        <span class="cov0" title="0">return relays, nil</span>
}

// DiscoveryConfig interface implementation
func (c *NodeConfig) GetBootstrapPeers() []string <span class="cov0" title="0">{
        return c.BootstrapPeers
}</span>

func (c *NodeConfig) GetRendezvousString() string <span class="cov0" title="0">{
        return c.RendezvousString
}</span>

func (c *NodeConfig) IsAutoDiscoveryEnabled() bool <span class="cov0" title="0">{
        return c.AutoDiscovery
}</span>

// NodeCapabilities represents the capabilities of a P2P node
type NodeCapabilities struct {
        // Compute resources
        CPUCores       int              `json:"cpu_cores"`
        Memory         int64            `json:"memory"`
        Storage        int64            `json:"storage"`
        GPUs           []*GPUInfo       `json:"gpus"`
        
        // AI capabilities
        SupportedModels []string         `json:"supported_models"`
        ModelFormats    []string         `json:"model_formats"`
        Quantizations   []string         `json:"quantizations"`
        
        // Network capabilities
        Bandwidth      int64            `json:"bandwidth"`
        Latency        time.Duration    `json:"latency"`
        Reliability    float64          `json:"reliability"`
        PricePerToken  float64          `json:"price_per_token"`
        
        // Node state
        Available      bool             `json:"available"`
        LoadFactor     float64          `json:"load_factor"`
        Priority       int              `json:"priority"`
        LastSeen       time.Time        `json:"last_seen"`
        
        // Version information
        Version        string           `json:"version"`
        ProtocolVersion string          `json:"protocol_version"`
        Features       []string         `json:"features"`
}

// GPUInfo represents information about a GPU
type GPUInfo struct {
        ID          string            `json:"id"`
        Name        string            `json:"name"`
        Memory      int64             `json:"memory"`
        Compute     string            `json:"compute"`
        Available   bool              `json:"available"`
        Utilization float64           `json:"utilization"`
        Properties  map[string]string `json:"properties"`
}

// ResourceMetrics contains real-time resource usage metrics
type ResourceMetrics struct {
        CPUUsage    float64 `json:"cpu_usage" yaml:"cpu_usage"`         // CPU usage percentage (0-100)
        MemoryUsage int64   `json:"memory_usage" yaml:"memory_usage"`   // Memory usage in bytes
        DiskUsage   int64   `json:"disk_usage" yaml:"disk_usage"`       // Disk usage in bytes
        NetworkRx   int64   `json:"network_rx" yaml:"network_rx"`       // Network received bytes/sec
        NetworkTx   int64   `json:"network_tx" yaml:"network_tx"`       // Network transmitted bytes/sec
        
        // GPU metrics
        GPUUsage     []float64 `json:"gpu_usage" yaml:"gpu_usage"`         // GPU usage percentage per GPU
        GPUMemory    []int64   `json:"gpu_memory" yaml:"gpu_memory"`       // GPU memory usage per GPU
        GPUTemp      []float64 `json:"gpu_temp" yaml:"gpu_temp"`           // GPU temperature per GPU
        
        // Performance metrics
        RequestsPerSec  float64 `json:"requests_per_sec" yaml:"requests_per_sec"`
        AvgLatency      time.Duration `json:"avg_latency" yaml:"avg_latency"`
        ErrorRate       float64 `json:"error_rate" yaml:"error_rate"`
        
        Timestamp time.Time `json:"timestamp" yaml:"timestamp"`
}</pre>
		
		<pre class="file" id="file10" style="display: none">package integration

import (
        "context"
        "fmt"
        "net/http"
)

// Registry stub to replace github.com/ollama/ollama/server/internal/client/ollama.Registry
type Registry struct {
        // Stub implementation for compatibility
        models map[string]interface{}
}

// NewRegistry creates a new registry stub
func NewRegistry() *Registry <span class="cov0" title="0">{
        return &amp;Registry{
                models: make(map[string]interface{}),
        }
}</span>

// RegisterModel registers a model in the stub registry
func (r *Registry) RegisterModel(name string, model interface{}) <span class="cov0" title="0">{
        r.models[name] = model
}</span>

// GetModel retrieves a model from the stub registry
func (r *Registry) GetModel(name string) (interface{}, bool) <span class="cov0" title="0">{
        model, exists := r.models[name]
        return model, exists
}</span>

// ListModels returns all registered models
func (r *Registry) ListModels() map[string]interface{} <span class="cov0" title="0">{
        return r.models
}</span>

// ClientInterface provides methods that would be available from ollama client
type ClientInterface interface {
        Generate(ctx context.Context, request GenerateRequest) (*GenerateResponse, error)
        Chat(ctx context.Context, request ChatRequest) (*ChatResponse, error)
        Embed(ctx context.Context, request EmbedRequest) (*EmbedResponse, error)
        List(ctx context.Context) (*ListResponse, error)
        Show(ctx context.Context, request ShowRequest) (*ShowResponse, error)
        Pull(ctx context.Context, request PullRequest) error
        Delete(ctx context.Context, request DeleteRequest) error
        Version(ctx context.Context) (*VersionResponse, error)
}

// Client stub implementation
type Client struct {
        baseURL string
        client  *http.Client
}

// NewClient creates a new ollama client stub
func NewClient(baseURL string) *Client <span class="cov0" title="0">{
        return &amp;Client{
                baseURL: baseURL,
                client:  &amp;http.Client{},
        }
}</span>

// Request/Response types for ollama API

type GenerateRequest struct {
        Model  string `json:"model"`
        Prompt string `json:"prompt"`
        Stream bool   `json:"stream,omitempty"`
}

type GenerateResponse struct {
        Model    string `json:"model"`
        Response string `json:"response"`
        Done     bool   `json:"done"`
}

type ChatRequest struct {
        Model    string        `json:"model"`
        Messages []ChatMessage `json:"messages"`
        Stream   bool          `json:"stream,omitempty"`
}

type ChatMessage struct {
        Role    string `json:"role"`
        Content string `json:"content"`
}

type ChatResponse struct {
        Model   string      `json:"model"`
        Message ChatMessage `json:"message"`
        Done    bool        `json:"done"`
}

type EmbedRequest struct {
        Model string `json:"model"`
        Input string `json:"input"`
}

type EmbedResponse struct {
        Embedding []float64 `json:"embedding"`
}

type ListResponse struct {
        Models []ModelInfo `json:"models"`
}

type ModelInfo struct {
        Name       string `json:"name"`
        Size       int64  `json:"size"`
        Digest     string `json:"digest"`
        ModifiedAt string `json:"modified_at"`
}

type ShowRequest struct {
        Name string `json:"name"`
}

type ShowResponse struct {
        License    string                 `json:"license"`
        Modelfile  string                 `json:"modelfile"`
        Parameters map[string]interface{} `json:"parameters"`
        Template   string                 `json:"template"`
        Details    map[string]interface{} `json:"details"`
}

type PullRequest struct {
        Name   string `json:"name"`
        Stream bool   `json:"stream,omitempty"`
}

type DeleteRequest struct {
        Name string `json:"name"`
}

type VersionResponse struct {
        Version string `json:"version"`
}

// Stub implementations of client methods

func (c *Client) Generate(ctx context.Context, request GenerateRequest) (*GenerateResponse, error) <span class="cov0" title="0">{
        // Stub implementation - would make HTTP request to ollama server
        return &amp;GenerateResponse{
                Model:    request.Model,
                Response: fmt.Sprintf("Generated response for: %s", request.Prompt),
                Done:     true,
        }, nil
}</span>

func (c *Client) Chat(ctx context.Context, request ChatRequest) (*ChatResponse, error) <span class="cov0" title="0">{
        // Stub implementation
        lastMessage := request.Messages[len(request.Messages)-1]
        return &amp;ChatResponse{
                Model: request.Model,
                Message: ChatMessage{
                        Role:    "assistant",
                        Content: fmt.Sprintf("Chat response to: %s", lastMessage.Content),
                },
                Done: true,
        }, nil
}</span>

func (c *Client) Embed(ctx context.Context, request EmbedRequest) (*EmbedResponse, error) <span class="cov0" title="0">{
        // Stub implementation - return dummy embedding
        embedding := make([]float64, 768) // Standard embedding size
        for i := range embedding </span><span class="cov0" title="0">{
                embedding[i] = 0.1 * float64(i%10)
        }</span>
        
        <span class="cov0" title="0">return &amp;EmbedResponse{
                Embedding: embedding,
        }, nil</span>
}

func (c *Client) List(ctx context.Context) (*ListResponse, error) <span class="cov0" title="0">{
        // Stub implementation
        return &amp;ListResponse{
                Models: []ModelInfo{
                        {
                                Name:       "llama2:7b",
                                Size:       3825819519,
                                Digest:     "abc123",
                                ModifiedAt: "2024-01-01T00:00:00Z",
                        },
                },
        }, nil
}</span>

func (c *Client) Show(ctx context.Context, request ShowRequest) (*ShowResponse, error) <span class="cov0" title="0">{
        // Stub implementation
        return &amp;ShowResponse{
                License:    "MIT",
                Modelfile:  fmt.Sprintf("FROM %s", request.Name),
                Parameters: map[string]interface{}{"temperature": 0.7},
                Template:   "{{ .System }} {{ .Prompt }}",
                Details:    map[string]interface{}{"family": "llama"},
        }, nil
}</span>

func (c *Client) Pull(ctx context.Context, request PullRequest) error <span class="cov0" title="0">{
        // Stub implementation
        return nil
}</span>

func (c *Client) Delete(ctx context.Context, request DeleteRequest) error <span class="cov0" title="0">{
        // Stub implementation
        return nil
}</span>

func (c *Client) Version(ctx context.Context) (*VersionResponse, error) <span class="cov0" title="0">{
        // Stub implementation
        return &amp;VersionResponse{
                Version: "0.1.0-distributed",
        }, nil
}</span>

// Server interface stub to replace ollama server interface
type Server interface {
        GenerateRoutes(registry *Registry) (http.Handler, error)
        Start(ctx context.Context) error
        Stop(ctx context.Context) error
}

// ServerStub provides a stub implementation of the Server interface
type ServerStub struct {
        client *Client
}

// NewServerStub creates a new server stub
func NewServerStub(baseURL string) *ServerStub <span class="cov0" title="0">{
        return &amp;ServerStub{
                client: NewClient(baseURL),
        }
}</span>

func (s *ServerStub) GenerateRoutes(registry *Registry) (http.Handler, error) <span class="cov0" title="0">{
        // Stub implementation
        return http.DefaultServeMux, nil
}</span>

func (s *ServerStub) Start(ctx context.Context) error <span class="cov0" title="0">{
        // Stub implementation
        return nil
}</span>

func (s *ServerStub) Stop(ctx context.Context) error <span class="cov0" title="0">{
        // Stub implementation
        return nil
}</span>

// Additional stub types and functions that might be needed

type ModelManifest struct {
        SchemaVersion int                    `json:"schemaVersion"`
        MediaType     string                 `json:"mediaType"`
        Config        ModelConfig            `json:"config"`
        Layers        []ModelLayer           `json:"layers"`
        Annotations   map[string]interface{} `json:"annotations,omitempty"`
}

type ModelConfig struct {
        MediaType string                 `json:"mediaType"`
        Digest    string                 `json:"digest"`
        Size      int64                  `json:"size"`
        Data      map[string]interface{} `json:"data,omitempty"`
}

type ModelLayer struct {
        MediaType   string                 `json:"mediaType"`
        Digest      string                 `json:"digest"`
        Size        int64                  `json:"size"`
        Annotations map[string]interface{} `json:"annotations,omitempty"`
}

// Progress tracking for long-running operations
type ProgressCallback func(status string, current, total int64)

// Additional utility functions
func ParseModelName(name string) (registry, namespace, model, tag string) <span class="cov0" title="0">{
        // Stub implementation for model name parsing
        return "", "", name, "latest"
}</span>

func ValidateModelName(name string) error <span class="cov0" title="0">{
        if name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("model name cannot be empty")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Health check function
func (c *Client) Health(ctx context.Context) error <span class="cov0" title="0">{
        // Stub implementation
        return nil
}</span>

// Error types
type APIError struct {
        Code    int    `json:"code"`
        Message string `json:"message"`
}

func (e APIError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("API error %d: %s", e.Code, e.Message)
}</span>

// Constants
const (
        DefaultBaseURL = "http://localhost:11434"
        DefaultTimeout = 30 // seconds
)</pre>
		
		<pre class="file" id="file11" style="display: none">package models

import (
        "crypto/sha256"
        "encoding/hex"
        "fmt"
        "io"
        "log/slog"
        "os"
        "path/filepath"
        "sync"
        "time"
)

// ContentAddressedStore implements a content-addressed storage system for models
type ContentAddressedStore struct {
        storeDir    string
        logger      *slog.Logger
        
        // Object tracking
        objects     map[string]*StoredObject
        objectsMutex sync.RWMutex
        
        // Reference counting
        refCounts   map[string]int
        refMutex    sync.RWMutex
        
        // Storage configuration
        maxObjects  int
        maxSize     int64
        
        // Cleanup settings
        cleanupInterval time.Duration
        maxAge         time.Duration
        
        // Statistics
        stats       *StoreStats
        statsMutex  sync.RWMutex
}

// StoredObject represents an object in the content-addressed store
type StoredObject struct {
        Hash      string            `json:"hash"`
        Size      int64             `json:"size"`
        Path      string            `json:"path"`
        RefCount  int               `json:"ref_count"`
        CreatedAt time.Time         `json:"created_at"`
        AccessedAt time.Time        `json:"accessed_at"`
        Metadata  map[string]string `json:"metadata"`
}

// StoreStats contains statistics about the store
type StoreStats struct {
        TotalObjects    int64 `json:"total_objects"`
        TotalSize       int64 `json:"total_size"`
        TotalReferences int64 `json:"total_references"`
        HitCount        int64 `json:"hit_count"`
        MissCount       int64 `json:"miss_count"`
        LastCleanup     time.Time `json:"last_cleanup"`
}

// NewContentAddressedStore creates a new content-addressed store
func NewContentAddressedStore(storeDir string, logger *slog.Logger) (*ContentAddressedStore, error) <span class="cov0" title="0">{
        if err := os.MkdirAll(storeDir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create store directory: %w", err)
        }</span>
        
        <span class="cov0" title="0">cas := &amp;ContentAddressedStore{
                storeDir:        storeDir,
                logger:          logger,
                objects:         make(map[string]*StoredObject),
                refCounts:       make(map[string]int),
                maxObjects:      10000,
                maxSize:         100 * 1024 * 1024 * 1024, // 100GB
                cleanupInterval: time.Hour,
                maxAge:          24 * time.Hour * 7, // 1 week
                stats:           &amp;StoreStats{},
        }
        
        // Load existing objects
        if err := cas.loadObjects(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load objects: %w", err)
        }</span>
        
        // Start cleanup routine
        <span class="cov0" title="0">go cas.cleanupRoutine()
        
        return cas, nil</span>
}

// Store stores data in the content-addressed store
func (cas *ContentAddressedStore) Store(hash string, sourcePath string) error <span class="cov0" title="0">{
        cas.logger.Info("storing object", "hash", hash, "source", sourcePath)
        
        // Check if object already exists
        cas.objectsMutex.RLock()
        if obj, exists := cas.objects[hash]; exists </span><span class="cov0" title="0">{
                cas.objectsMutex.RUnlock()
                
                // Update access time and increment reference count
                obj.AccessedAt = time.Now()
                cas.incrementReference(hash)
                
                cas.statsMutex.Lock()
                cas.stats.HitCount++
                cas.statsMutex.Unlock()
                
                cas.logger.Debug("object already exists", "hash", hash, "ref_count", obj.RefCount)
                return nil
        }</span>
        <span class="cov0" title="0">cas.objectsMutex.RUnlock()
        
        // Calculate actual hash to verify
        actualHash, err := cas.calculateHash(sourcePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to calculate hash: %w", err)
        }</span>
        
        <span class="cov0" title="0">if actualHash != hash </span><span class="cov0" title="0">{
                return fmt.Errorf("hash mismatch: expected %s, got %s", hash, actualHash)
        }</span>
        
        // Get file info
        <span class="cov0" title="0">info, err := os.Stat(sourcePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stat source file: %w", err)
        }</span>
        
        // Create storage path
        <span class="cov0" title="0">storagePath := cas.getStoragePath(hash)
        if err := os.MkdirAll(filepath.Dir(storagePath), 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create storage directory: %w", err)
        }</span>
        
        // Copy file to storage
        <span class="cov0" title="0">if err := cas.copyFile(sourcePath, storagePath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy file: %w", err)
        }</span>
        
        // Create object entry
        <span class="cov0" title="0">obj := &amp;StoredObject{
                Hash:       hash,
                Size:       info.Size(),
                Path:       storagePath,
                RefCount:   1,
                CreatedAt:  time.Now(),
                AccessedAt: time.Now(),
                Metadata:   make(map[string]string),
        }
        
        // Store object
        cas.objectsMutex.Lock()
        cas.objects[hash] = obj
        cas.objectsMutex.Unlock()
        
        cas.refMutex.Lock()
        cas.refCounts[hash] = 1
        cas.refMutex.Unlock()
        
        // Update statistics
        cas.statsMutex.Lock()
        cas.stats.TotalObjects++
        cas.stats.TotalSize += info.Size()
        cas.stats.TotalReferences++
        cas.stats.MissCount++
        cas.statsMutex.Unlock()
        
        cas.logger.Info("object stored", "hash", hash, "size", info.Size())
        return nil</span>
}

// Get retrieves an object from the store
func (cas *ContentAddressedStore) Get(hash string) (*StoredObject, error) <span class="cov0" title="0">{
        cas.objectsMutex.RLock()
        obj, exists := cas.objects[hash]
        cas.objectsMutex.RUnlock()
        
        if !exists </span><span class="cov0" title="0">{
                cas.statsMutex.Lock()
                cas.stats.MissCount++
                cas.statsMutex.Unlock()
                
                return nil, fmt.Errorf("object not found: %s", hash)
        }</span>
        
        // Update access time
        <span class="cov0" title="0">obj.AccessedAt = time.Now()
        
        cas.statsMutex.Lock()
        cas.stats.HitCount++
        cas.statsMutex.Unlock()
        
        return obj, nil</span>
}

// GetReader returns a reader for an object
func (cas *ContentAddressedStore) GetReader(hash string) (io.ReadCloser, error) <span class="cov0" title="0">{
        obj, err := cas.Get(hash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">return os.Open(obj.Path)</span>
}

// Exists checks if an object exists in the store
func (cas *ContentAddressedStore) Exists(hash string) bool <span class="cov0" title="0">{
        cas.objectsMutex.RLock()
        defer cas.objectsMutex.RUnlock()
        
        _, exists := cas.objects[hash]
        return exists
}</span>

// IncrementReference increments the reference count for an object
func (cas *ContentAddressedStore) IncrementReference(hash string) error <span class="cov0" title="0">{
        cas.objectsMutex.RLock()
        obj, exists := cas.objects[hash]
        cas.objectsMutex.RUnlock()
        
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("object not found: %s", hash)
        }</span>
        
        <span class="cov0" title="0">cas.incrementReference(hash)
        
        cas.logger.Debug("incremented reference", "hash", hash, "ref_count", obj.RefCount)
        return nil</span>
}

// DecrementReference decrements the reference count for an object
func (cas *ContentAddressedStore) DecrementReference(hash string) error <span class="cov0" title="0">{
        cas.objectsMutex.RLock()
        obj, exists := cas.objects[hash]
        cas.objectsMutex.RUnlock()
        
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("object not found: %s", hash)
        }</span>
        
        <span class="cov0" title="0">cas.decrementReference(hash)
        
        cas.logger.Debug("decremented reference", "hash", hash, "ref_count", obj.RefCount)
        return nil</span>
}

// incrementReference increments the reference count
func (cas *ContentAddressedStore) incrementReference(hash string) <span class="cov0" title="0">{
        cas.refMutex.Lock()
        cas.refCounts[hash]++
        cas.refMutex.Unlock()
        
        cas.objectsMutex.Lock()
        if obj, exists := cas.objects[hash]; exists </span><span class="cov0" title="0">{
                obj.RefCount++
        }</span>
        <span class="cov0" title="0">cas.objectsMutex.Unlock()
        
        cas.statsMutex.Lock()
        cas.stats.TotalReferences++
        cas.statsMutex.Unlock()</span>
}

// decrementReference decrements the reference count
func (cas *ContentAddressedStore) decrementReference(hash string) <span class="cov0" title="0">{
        cas.refMutex.Lock()
        if cas.refCounts[hash] &gt; 0 </span><span class="cov0" title="0">{
                cas.refCounts[hash]--
        }</span>
        <span class="cov0" title="0">refCount := cas.refCounts[hash]
        cas.refMutex.Unlock()
        
        cas.objectsMutex.Lock()
        if obj, exists := cas.objects[hash]; exists </span><span class="cov0" title="0">{
                obj.RefCount = refCount
        }</span>
        <span class="cov0" title="0">cas.objectsMutex.Unlock()
        
        cas.statsMutex.Lock()
        if cas.stats.TotalReferences &gt; 0 </span><span class="cov0" title="0">{
                cas.stats.TotalReferences--
        }</span>
        <span class="cov0" title="0">cas.statsMutex.Unlock()</span>
}

// ListObjects returns all objects in the store
func (cas *ContentAddressedStore) ListObjects() []*StoredObject <span class="cov0" title="0">{
        cas.objectsMutex.RLock()
        defer cas.objectsMutex.RUnlock()
        
        objects := make([]*StoredObject, 0, len(cas.objects))
        for _, obj := range cas.objects </span><span class="cov0" title="0">{
                objects = append(objects, obj)
        }</span>
        
        <span class="cov0" title="0">return objects</span>
}

// GetStats returns store statistics
func (cas *ContentAddressedStore) GetStats() *StoreStats <span class="cov0" title="0">{
        cas.statsMutex.RLock()
        defer cas.statsMutex.RUnlock()
        
        stats := *cas.stats
        return &amp;stats
}</span>

// calculateHash calculates the SHA256 hash of a file
func (cas *ContentAddressedStore) calculateHash(filePath string) (string, error) <span class="cov0" title="0">{
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer file.Close()
        
        hash := sha256.New()
        if _, err := io.Copy(hash, file); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        
        <span class="cov0" title="0">return hex.EncodeToString(hash.Sum(nil)), nil</span>
}

// getStoragePath returns the storage path for a hash
func (cas *ContentAddressedStore) getStoragePath(hash string) string <span class="cov0" title="0">{
        // Create a directory structure like: store/ab/cd/abcd...
        dir1 := hash[:2]
        dir2 := hash[2:4]
        return filepath.Join(cas.storeDir, dir1, dir2, hash)
}</span>

// copyFile copies a file from source to destination
func (cas *ContentAddressedStore) copyFile(src, dst string) error <span class="cov0" title="0">{
        srcFile, err := os.Open(src)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer srcFile.Close()
        
        dstFile, err := os.Create(dst)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer dstFile.Close()
        
        if _, err := io.Copy(dstFile, srcFile); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov0" title="0">return dstFile.Sync()</span>
}

// loadObjects loads existing objects from the store
func (cas *ContentAddressedStore) loadObjects() error <span class="cov0" title="0">{
        return filepath.Walk(cas.storeDir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>
                
                // Extract hash from filename
                <span class="cov0" title="0">hash := filepath.Base(path)
                if len(hash) != 64 </span><span class="cov0" title="0">{ // SHA256 hash length
                        return nil
                }</span>
                
                // Verify hash
                <span class="cov0" title="0">actualHash, err := cas.calculateHash(path)
                if err != nil </span><span class="cov0" title="0">{
                        cas.logger.Error("failed to verify object hash", "path", path, "error", err)
                        return nil
                }</span>
                
                <span class="cov0" title="0">if actualHash != hash </span><span class="cov0" title="0">{
                        cas.logger.Error("hash mismatch for stored object", "path", path, "expected", hash, "actual", actualHash)
                        return nil
                }</span>
                
                // Create object entry
                <span class="cov0" title="0">obj := &amp;StoredObject{
                        Hash:       hash,
                        Size:       info.Size(),
                        Path:       path,
                        RefCount:   1, // Default reference count
                        CreatedAt:  info.ModTime(),
                        AccessedAt: info.ModTime(),
                        Metadata:   make(map[string]string),
                }
                
                cas.objectsMutex.Lock()
                cas.objects[hash] = obj
                cas.objectsMutex.Unlock()
                
                cas.refMutex.Lock()
                cas.refCounts[hash] = 1
                cas.refMutex.Unlock()
                
                // Update statistics
                cas.statsMutex.Lock()
                cas.stats.TotalObjects++
                cas.stats.TotalSize += info.Size()
                cas.stats.TotalReferences++
                cas.statsMutex.Unlock()
                
                return nil</span>
        })
}

// cleanupRoutine runs periodic cleanup
func (cas *ContentAddressedStore) cleanupRoutine() <span class="cov0" title="0">{
        ticker := time.NewTicker(cas.cleanupInterval)
        defer ticker.Stop()
        
        for range ticker.C </span><span class="cov0" title="0">{
                if err := cas.cleanup(); err != nil </span><span class="cov0" title="0">{
                        cas.logger.Error("cleanup failed", "error", err)
                }</span>
        }
}

// cleanup removes unreferenced and old objects
func (cas *ContentAddressedStore) cleanup() error <span class="cov0" title="0">{
        cas.logger.Info("starting cleanup")
        
        var removed int
        var freedSize int64
        
        cas.objectsMutex.Lock()
        defer cas.objectsMutex.Unlock()
        
        cas.refMutex.Lock()
        defer cas.refMutex.Unlock()
        
        cutoff := time.Now().Add(-cas.maxAge)
        
        for hash, obj := range cas.objects </span><span class="cov0" title="0">{
                shouldRemove := false
                
                // Remove if no references
                if obj.RefCount == 0 </span><span class="cov0" title="0">{
                        shouldRemove = true
                }</span>
                
                // Remove if too old and not recently accessed
                <span class="cov0" title="0">if obj.AccessedAt.Before(cutoff) &amp;&amp; obj.RefCount &lt;= 1 </span><span class="cov0" title="0">{
                        shouldRemove = true
                }</span>
                
                <span class="cov0" title="0">if shouldRemove </span><span class="cov0" title="0">{
                        // Remove file
                        if err := os.Remove(obj.Path); err != nil </span><span class="cov0" title="0">{
                                cas.logger.Error("failed to remove object file", "hash", hash, "path", obj.Path, "error", err)
                                continue</span>
                        }
                        
                        // Remove from maps
                        <span class="cov0" title="0">delete(cas.objects, hash)
                        delete(cas.refCounts, hash)
                        
                        removed++
                        freedSize += obj.Size
                        
                        cas.logger.Debug("removed object", "hash", hash, "size", obj.Size)</span>
                }
        }
        
        // Update statistics
        <span class="cov0" title="0">cas.statsMutex.Lock()
        cas.stats.TotalObjects -= int64(removed)
        cas.stats.TotalSize -= freedSize
        cas.stats.LastCleanup = time.Now()
        cas.statsMutex.Unlock()
        
        cas.logger.Info("cleanup completed", "removed", removed, "freed_size", freedSize)
        
        return nil</span>
}

// Verify verifies the integrity of all objects in the store
func (cas *ContentAddressedStore) Verify() error <span class="cov0" title="0">{
        cas.logger.Info("starting verification")
        
        var errors []string
        
        cas.objectsMutex.RLock()
        objects := make([]*StoredObject, 0, len(cas.objects))
        for _, obj := range cas.objects </span><span class="cov0" title="0">{
                objects = append(objects, obj)
        }</span>
        <span class="cov0" title="0">cas.objectsMutex.RUnlock()
        
        for _, obj := range objects </span><span class="cov0" title="0">{
                // Check if file exists
                if _, err := os.Stat(obj.Path); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Sprintf("object file missing: %s (%s)", obj.Hash, obj.Path))
                        continue</span>
                }
                
                // Verify hash
                <span class="cov0" title="0">actualHash, err := cas.calculateHash(obj.Path)
                if err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Sprintf("failed to calculate hash for %s: %v", obj.Hash, err))
                        continue</span>
                }
                
                <span class="cov0" title="0">if actualHash != obj.Hash </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Sprintf("hash mismatch for %s: expected %s, got %s", obj.Path, obj.Hash, actualHash))
                }</span>
        }
        
        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                cas.logger.Error("verification failed", "errors", len(errors))
                for _, err := range errors </span><span class="cov0" title="0">{
                        cas.logger.Error("verification error", "error", err)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("verification failed with %d errors", len(errors))</span>
        }
        
        <span class="cov0" title="0">cas.logger.Info("verification completed successfully")
        return nil</span>
}

// Close closes the content-addressed store
func (cas *ContentAddressedStore) Close() error <span class="cov0" title="0">{
        cas.logger.Info("closing content-addressed store")
        return nil
}</pre>
		
		<pre class="file" id="file12" style="display: none">package models

import (
        "context"
        "crypto/sha256"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "io"
        "log/slog"
        "os"
        "path/filepath"
        "sort"
        "sync"
        "time"
)

// DeltaTracker manages delta operations for incremental model synchronization
type DeltaTracker struct {
        deltaDir   string
        logger     *slog.Logger
        
        // Delta storage
        deltas     map[string][]*Delta
        deltaMutex sync.RWMutex
        
        // Delta operations
        pendingOps map[string]*DeltaOperation
        opsMutex   sync.RWMutex
        
        // Compression settings
        compressionEnabled bool
        compressionLevel   int
        
        ctx    context.Context
        cancel context.CancelFunc
}

// Delta represents a single delta operation
type Delta struct {
        ID         string     `json:"id"`
        ModelName  string     `json:"model_name"`
        Type       DeltaType  `json:"type"`
        Offset     int64      `json:"offset"`
        Size       int64      `json:"size"`
        Hash       string     `json:"hash"`
        Data       []byte     `json:"data,omitempty"`
        Timestamp  time.Time  `json:"timestamp"`
        Compressed bool       `json:"compressed"`
}

// DeltaType represents the type of delta operation
type DeltaType string

const (
        DeltaTypeInsert DeltaType = "insert"
        DeltaTypeUpdate DeltaType = "update"
        DeltaTypeDelete DeltaType = "delete"
)

// DeltaOperation represents a complete delta operation
type DeltaOperation struct {
        ID          string        `json:"id"`
        ModelName   string        `json:"model_name"`
        SourceHash  string        `json:"source_hash"`
        TargetHash  string        `json:"target_hash"`
        Deltas      []*Delta      `json:"deltas"`
        Status      OperationStatus `json:"status"`
        CreatedAt   time.Time     `json:"created_at"`
        CompletedAt time.Time     `json:"completed_at"`
        Size        int64         `json:"size"`
        Error       string        `json:"error,omitempty"`
}

// OperationStatus represents the status of a delta operation
type OperationStatus string

const (
        OperationStatusPending   OperationStatus = "pending"
        OperationStatusInProgress OperationStatus = "in_progress"
        OperationStatusCompleted  OperationStatus = "completed"
        OperationStatusFailed     OperationStatus = "failed"
)

// DeltaMetadata contains metadata about a delta set
type DeltaMetadata struct {
        ModelName     string    `json:"model_name"`
        FromVersion   string    `json:"from_version"`
        ToVersion     string    `json:"to_version"`
        DeltaCount    int       `json:"delta_count"`
        TotalSize     int64     `json:"total_size"`
        CompressedSize int64    `json:"compressed_size"`
        CreatedAt     time.Time `json:"created_at"`
        CompressionRatio float64 `json:"compression_ratio"`
}

// NewDeltaTracker creates a new delta tracker
func NewDeltaTracker(deltaDir string, logger *slog.Logger) (*DeltaTracker, error) <span class="cov0" title="0">{
        if err := os.MkdirAll(deltaDir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create delta directory: %w", err)
        }</span>
        
        <span class="cov0" title="0">ctx, cancel := context.WithCancel(context.Background())
        
        dt := &amp;DeltaTracker{
                deltaDir:           deltaDir,
                logger:             logger,
                deltas:             make(map[string][]*Delta),
                pendingOps:         make(map[string]*DeltaOperation),
                compressionEnabled: true,
                compressionLevel:   6,
                ctx:                ctx,
                cancel:             cancel,
        }
        
        // Load existing deltas
        if err := dt.loadDeltas(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load deltas: %w", err)
        }</span>
        
        <span class="cov0" title="0">return dt, nil</span>
}

// CreateDelta creates a delta between two model versions
func (dt *DeltaTracker) CreateDelta(modelName, sourceFile, targetFile string) (*DeltaOperation, error) <span class="cov0" title="0">{
        dt.logger.Info("creating delta", "model", modelName, "source", sourceFile, "target", targetFile)
        
        // Calculate hashes
        sourceHash, err := dt.calculateFileHash(sourceFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to calculate source hash: %w", err)
        }</span>
        
        <span class="cov0" title="0">targetHash, err := dt.calculateFileHash(targetFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to calculate target hash: %w", err)
        }</span>
        
        // Create operation
        <span class="cov0" title="0">opID := fmt.Sprintf("%s_%s_%s", modelName, sourceHash[:8], targetHash[:8])
        op := &amp;DeltaOperation{
                ID:         opID,
                ModelName:  modelName,
                SourceHash: sourceHash,
                TargetHash: targetHash,
                Status:     OperationStatusPending,
                CreatedAt:  time.Now(),
        }
        
        // Store pending operation
        dt.opsMutex.Lock()
        dt.pendingOps[opID] = op
        dt.opsMutex.Unlock()
        
        // Generate deltas
        deltas, err := dt.generateDeltas(sourceFile, targetFile)
        if err != nil </span><span class="cov0" title="0">{
                op.Status = OperationStatusFailed
                op.Error = err.Error()
                return op, fmt.Errorf("failed to generate deltas: %w", err)
        }</span>
        
        <span class="cov0" title="0">op.Deltas = deltas
        op.Status = OperationStatusCompleted
        op.CompletedAt = time.Now()
        
        // Calculate total size
        var totalSize int64
        for _, delta := range deltas </span><span class="cov0" title="0">{
                totalSize += delta.Size
        }</span>
        <span class="cov0" title="0">op.Size = totalSize
        
        // Store deltas
        dt.deltaMutex.Lock()
        dt.deltas[modelName] = append(dt.deltas[modelName], deltas...)
        dt.deltaMutex.Unlock()
        
        // Save to disk
        if err := dt.saveDelta(op); err != nil </span><span class="cov0" title="0">{
                dt.logger.Error("failed to save delta", "operation", opID, "error", err)
        }</span>
        
        <span class="cov0" title="0">dt.logger.Info("delta created", "operation", opID, "deltas", len(deltas), "size", totalSize)
        
        return op, nil</span>
}

// ApplyDelta applies a delta operation to a model file
func (dt *DeltaTracker) ApplyDelta(targetFile string, op *DeltaOperation) error <span class="cov0" title="0">{
        dt.logger.Info("applying delta", "operation", op.ID, "target", targetFile)
        
        // Open target file
        file, err := os.OpenFile(targetFile, os.O_RDWR|os.O_CREATE, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open target file: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()
        
        // Apply deltas in order
        sort.Slice(op.Deltas, func(i, j int) bool </span><span class="cov0" title="0">{
                return op.Deltas[i].Offset &lt; op.Deltas[j].Offset
        }</span>)
        
        <span class="cov0" title="0">for _, delta := range op.Deltas </span><span class="cov0" title="0">{
                if err := dt.applyDelta(file, delta); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to apply delta %s: %w", delta.ID, err)
                }</span>
        }
        
        // Verify result
        <span class="cov0" title="0">resultHash, err := dt.calculateFileHash(targetFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to calculate result hash: %w", err)
        }</span>
        
        <span class="cov0" title="0">if resultHash != op.TargetHash </span><span class="cov0" title="0">{
                return fmt.Errorf("delta application failed: hash mismatch (expected %s, got %s)", op.TargetHash, resultHash)
        }</span>
        
        <span class="cov0" title="0">dt.logger.Info("delta applied successfully", "operation", op.ID)
        return nil</span>
}

// GetDeltas returns all deltas for a model
func (dt *DeltaTracker) GetDeltas(modelName string) []*Delta <span class="cov0" title="0">{
        dt.deltaMutex.RLock()
        defer dt.deltaMutex.RUnlock()
        
        deltas := dt.deltas[modelName]
        result := make([]*Delta, len(deltas))
        copy(result, deltas)
        
        return result
}</span>

// GetDeltaOperation returns a delta operation by ID
func (dt *DeltaTracker) GetDeltaOperation(opID string) (*DeltaOperation, bool) <span class="cov0" title="0">{
        dt.opsMutex.RLock()
        defer dt.opsMutex.RUnlock()
        
        op, exists := dt.pendingOps[opID]
        return op, exists
}</span>

// generateDeltas generates deltas between two files
func (dt *DeltaTracker) generateDeltas(sourceFile, targetFile string) ([]*Delta, error) <span class="cov0" title="0">{
        sourceData, err := os.ReadFile(sourceFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read source file: %w", err)
        }</span>
        
        <span class="cov0" title="0">targetData, err := os.ReadFile(targetFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read target file: %w", err)
        }</span>
        
        <span class="cov0" title="0">return dt.generateDeltasFromData(sourceData, targetData)</span>
}

// generateDeltasFromData generates deltas from byte data
func (dt *DeltaTracker) generateDeltasFromData(sourceData, targetData []byte) ([]*Delta, error) <span class="cov0" title="0">{
        var deltas []*Delta
        
        // Simple delta generation algorithm
        // In a real implementation, this would use a more sophisticated algorithm
        // like rsync's rolling hash or binary diff algorithms
        
        chunkSize := 1024 * 4 // 4KB chunks
        
        sourceOffset := 0
        targetOffset := 0
        
        for targetOffset &lt; len(targetData) </span><span class="cov0" title="0">{
                chunkEnd := targetOffset + chunkSize
                if chunkEnd &gt; len(targetData) </span><span class="cov0" title="0">{
                        chunkEnd = len(targetData)
                }</span>
                
                <span class="cov0" title="0">targetChunk := targetData[targetOffset:chunkEnd]
                
                // Check if this chunk exists in source
                found := false
                for i := sourceOffset; i &lt; len(sourceData)-len(targetChunk); i++ </span><span class="cov0" title="0">{
                        if dt.compareChunks(sourceData[i:i+len(targetChunk)], targetChunk) </span><span class="cov0" title="0">{
                                // Chunk exists, no delta needed
                                found = true
                                sourceOffset = i + len(targetChunk)
                                break</span>
                        }
                }
                
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        // Chunk is new or modified, create delta
                        deltaID := fmt.Sprintf("delta_%d_%d", time.Now().UnixNano(), targetOffset)
                        hash := sha256.Sum256(targetChunk)
                        
                        delta := &amp;Delta{
                                ID:        deltaID,
                                Type:      DeltaTypeInsert,
                                Offset:    int64(targetOffset),
                                Size:      int64(len(targetChunk)),
                                Hash:      hex.EncodeToString(hash[:]),
                                Data:      targetChunk,
                                Timestamp: time.Now(),
                        }
                        
                        // Apply compression if enabled
                        if dt.compressionEnabled </span><span class="cov0" title="0">{
                                compressed, err := dt.compressData(targetChunk)
                                if err == nil &amp;&amp; len(compressed) &lt; len(targetChunk) </span><span class="cov0" title="0">{
                                        delta.Data = compressed
                                        delta.Compressed = true
                                }</span>
                        }
                        
                        <span class="cov0" title="0">deltas = append(deltas, delta)</span>
                }
                
                <span class="cov0" title="0">targetOffset = chunkEnd</span>
        }
        
        <span class="cov0" title="0">return deltas, nil</span>
}

// applyDelta applies a single delta to a file
func (dt *DeltaTracker) applyDelta(file *os.File, delta *Delta) error <span class="cov0" title="0">{
        // Seek to position
        if _, err := file.Seek(delta.Offset, io.SeekStart); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to seek to position: %w", err)
        }</span>
        
        <span class="cov0" title="0">data := delta.Data
        
        // Decompress if needed
        if delta.Compressed </span><span class="cov0" title="0">{
                decompressed, err := dt.decompressData(data)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to decompress data: %w", err)
                }</span>
                <span class="cov0" title="0">data = decompressed</span>
        }
        
        // Apply delta based on type
        <span class="cov0" title="0">switch delta.Type </span>{
        case DeltaTypeInsert, DeltaTypeUpdate:<span class="cov0" title="0">
                if _, err := file.Write(data); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write data: %w", err)
                }</span>
        case DeltaTypeDelete:<span class="cov0" title="0">
                // For delete operations, we would need to handle file truncation
                // This is simplified for demonstration
                return fmt.Errorf("delete operations not fully implemented")</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// compareChunks compares two byte slices
func (dt *DeltaTracker) compareChunks(a, b []byte) bool <span class="cov0" title="0">{
        if len(a) != len(b) </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">for i := range a </span><span class="cov0" title="0">{
                if a[i] != b[i] </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        
        <span class="cov0" title="0">return true</span>
}

// calculateFileHash calculates SHA256 hash of a file
func (dt *DeltaTracker) calculateFileHash(filePath string) (string, error) <span class="cov0" title="0">{
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer file.Close()
        
        hash := sha256.New()
        if _, err := io.Copy(hash, file); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        
        <span class="cov0" title="0">return hex.EncodeToString(hash.Sum(nil)), nil</span>
}

// compressData compresses data using a simple compression algorithm
func (dt *DeltaTracker) compressData(data []byte) ([]byte, error) <span class="cov0" title="0">{
        // In a real implementation, this would use a proper compression library
        // like gzip, lz4, or zstd
        // For demonstration, we'll return the original data
        return data, nil
}</span>

// decompressData decompresses data
func (dt *DeltaTracker) decompressData(data []byte) ([]byte, error) <span class="cov0" title="0">{
        // In a real implementation, this would use a proper decompression library
        // For demonstration, we'll return the original data
        return data, nil
}</span>

// loadDeltas loads existing deltas from disk
func (dt *DeltaTracker) loadDeltas() error <span class="cov0" title="0">{
        return filepath.Walk(dt.deltaDir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>
                
                <span class="cov0" title="0">if filepath.Ext(path) == ".delta" </span><span class="cov0" title="0">{
                        if err := dt.loadDeltaFile(path); err != nil </span><span class="cov0" title="0">{
                                dt.logger.Error("failed to load delta file", "path", path, "error", err)
                        }</span>
                }
                
                <span class="cov0" title="0">return nil</span>
        })
}

// loadDeltaFile loads a single delta file
func (dt *DeltaTracker) loadDeltaFile(path string) error <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read delta file: %w", err)
        }</span>
        
        <span class="cov0" title="0">var op DeltaOperation
        if err := json.Unmarshal(data, &amp;op); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal delta operation: %w", err)
        }</span>
        
        // Store operation
        <span class="cov0" title="0">dt.opsMutex.Lock()
        dt.pendingOps[op.ID] = &amp;op
        dt.opsMutex.Unlock()
        
        // Store deltas
        dt.deltaMutex.Lock()
        dt.deltas[op.ModelName] = append(dt.deltas[op.ModelName], op.Deltas...)
        dt.deltaMutex.Unlock()
        
        return nil</span>
}

// saveDelta saves a delta operation to disk
func (dt *DeltaTracker) saveDelta(op *DeltaOperation) error <span class="cov0" title="0">{
        filename := fmt.Sprintf("%s.delta", op.ID)
        path := filepath.Join(dt.deltaDir, filename)
        
        data, err := json.MarshalIndent(op, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal delta operation: %w", err)
        }</span>
        
        <span class="cov0" title="0">return os.WriteFile(path, data, 0644)</span>
}

// GetDeltaMetadata returns metadata about deltas for a model
func (dt *DeltaTracker) GetDeltaMetadata(modelName string) *DeltaMetadata <span class="cov0" title="0">{
        dt.deltaMutex.RLock()
        defer dt.deltaMutex.RUnlock()
        
        deltas := dt.deltas[modelName]
        if len(deltas) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">var totalSize, compressedSize int64
        for _, delta := range deltas </span><span class="cov0" title="0">{
                totalSize += delta.Size
                if delta.Compressed </span><span class="cov0" title="0">{
                        compressedSize += int64(len(delta.Data))
                }</span> else<span class="cov0" title="0"> {
                        compressedSize += delta.Size
                }</span>
        }
        
        <span class="cov0" title="0">compressionRatio := 1.0
        if totalSize &gt; 0 </span><span class="cov0" title="0">{
                compressionRatio = float64(compressedSize) / float64(totalSize)
        }</span>
        
        <span class="cov0" title="0">return &amp;DeltaMetadata{
                ModelName:        modelName,
                DeltaCount:       len(deltas),
                TotalSize:        totalSize,
                CompressedSize:   compressedSize,
                CompressionRatio: compressionRatio,
        }</span>
}

// Cleanup removes old delta files
func (dt *DeltaTracker) Cleanup(maxAge time.Duration) error <span class="cov0" title="0">{
        dt.deltaMutex.Lock()
        defer dt.deltaMutex.Unlock()
        
        cutoff := time.Now().Add(-maxAge)
        
        for modelName, deltas := range dt.deltas </span><span class="cov0" title="0">{
                var remaining []*Delta
                
                for _, delta := range deltas </span><span class="cov0" title="0">{
                        if delta.Timestamp.After(cutoff) </span><span class="cov0" title="0">{
                                remaining = append(remaining, delta)
                        }</span>
                }
                
                <span class="cov0" title="0">dt.deltas[modelName] = remaining</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// Close closes the delta tracker
func (dt *DeltaTracker) Close() error <span class="cov0" title="0">{
        dt.cancel()
        return nil
}</pre>
		
		<pre class="file" id="file13" style="display: none">package models

import (
        "context"
        "fmt"
        "log/slog"
        "sync"
        "time"

        "github.com/libp2p/go-libp2p/core/peer"
        "github.com/ollama/ollama-distributed/internal/config"
        "github.com/ollama/ollama-distributed/pkg/p2p"
        "github.com/ollama/ollama/server"
)

// DistributedModelManager extends Ollama's model management with distributed capabilities
type DistributedModelManager struct {
        // Core components
        localManager       *Manager
        syncManager        *SyncManager
        replicationManager *ReplicationManager
        casStore           *ContentAddressedStore
        deltaTracker       *DeltaTracker
        
        // Configuration
        config *config.DistributedConfig
        p2p    *p2p.Node
        logger *slog.Logger
        
        // Ollama integration
        ollamaServer *server.Server
        
        // Distributed model registry
        registry       *DistributedRegistry
        registryMutex  sync.RWMutex
        
        // Model lifecycle management
        lifecycle      *ModelLifecycle
        lifecycleMutex sync.RWMutex
        
        // Performance monitoring
        monitor *PerformanceMonitor
        
        // Context management
        ctx     context.Context
        cancel  context.CancelFunc
        started bool
        mu      sync.RWMutex
}

// DistributedRegistry maintains a registry of all models across the network
type DistributedRegistry struct {
        models       map[string]*DistributedModel
        modelsMutex  sync.RWMutex
        
        // Peer model tracking
        peerModels   map[string]map[string]*DistributedModel // peerID -&gt; modelName -&gt; model
        peerMutex    sync.RWMutex
        
        // Network topology
        topology     *NetworkTopology
        
        // Discovery service
        discovery    *ModelDiscovery
}

// DistributedModel represents a model in the distributed network
type DistributedModel struct {
        // Base model information
        Name        string                 `json:"name"`
        Version     string                 `json:"version"`
        Hash        string                 `json:"hash"`
        Size        int64                  `json:"size"`
        Type        string                 `json:"type"`
        
        // Distributed information
        Replicas    []*ReplicaInfo         `json:"replicas"`
        Availability float64               `json:"availability"`
        
        // Version tracking
        Versions    []*ModelVersion        `json:"versions"`
        CurrentVersion string              `json:"current_version"`
        
        // Metadata
        Metadata    map[string]interface{} `json:"metadata"`
        Tags        []string               `json:"tags"`
        
        // Lifecycle
        CreatedAt   time.Time              `json:"created_at"`
        UpdatedAt   time.Time              `json:"updated_at"`
        AccessedAt  time.Time              `json:"accessed_at"`
        
        // Performance metrics
        AccessCount int64                  `json:"access_count"`
        DownloadCount int64                `json:"download_count"`
        
        // Replication policy
        Policy      *ReplicationPolicy     `json:"policy"`
        
        // Sync state
        SyncState   *SyncState             `json:"sync_state"`
}

// ModelLifecycle manages the lifecycle of distributed models
type ModelLifecycle struct {
        events      chan *LifecycleEvent
        eventsMutex sync.RWMutex
        
        // Lifecycle stages
        stages      map[string]*LifecycleStage
        stagesMutex sync.RWMutex
        
        // Hooks
        hooks       map[LifecycleEventType][]LifecycleHook
        hooksMutex  sync.RWMutex
}

// LifecycleEvent represents a model lifecycle event
type LifecycleEvent struct {
        Type      LifecycleEventType     `json:"type"`
        ModelName string                 `json:"model_name"`
        PeerID    string                 `json:"peer_id"`
        Timestamp time.Time              `json:"timestamp"`
        Data      map[string]interface{} `json:"data"`
}

// LifecycleEventType represents the type of lifecycle event
type LifecycleEventType string

const (
        EventModelCreated     LifecycleEventType = "model_created"
        EventModelUpdated     LifecycleEventType = "model_updated"
        EventModelDeleted     LifecycleEventType = "model_deleted"
        EventModelAccessed    LifecycleEventType = "model_accessed"
        EventModelReplicated  LifecycleEventType = "model_replicated"
        EventModelSynced      LifecycleEventType = "model_synced"
        EventModelCorrupted   LifecycleEventType = "model_corrupted"
        EventModelHealed      LifecycleEventType = "model_healed"
)

// LifecycleStage represents a stage in the model lifecycle
type LifecycleStage struct {
        Name        string                 `json:"name"`
        ModelName   string                 `json:"model_name"`
        Status      StageStatus            `json:"status"`
        StartTime   time.Time              `json:"start_time"`
        EndTime     time.Time              `json:"end_time"`
        Progress    float64                `json:"progress"`
        Metadata    map[string]interface{} `json:"metadata"`
        Error       string                 `json:"error,omitempty"`
}

// StageStatus represents the status of a lifecycle stage
type StageStatus string

const (
        StageStatusPending    StageStatus = "pending"
        StageStatusInProgress StageStatus = "in_progress"
        StageStatusCompleted  StageStatus = "completed"
        StageStatusFailed     StageStatus = "failed"
)

// LifecycleHook represents a hook function for lifecycle events
type LifecycleHook func(event *LifecycleEvent) error

// NetworkTopology represents the network topology for model distribution
type NetworkTopology struct {
        nodes       map[string]*TopologyNode
        nodesMutex  sync.RWMutex
        
        // Topology metadata
        Type        TopologyType           `json:"type"`
        Depth       int                    `json:"depth"`
        Diameter    int                    `json:"diameter"`
        Connectivity float64               `json:"connectivity"`
        
        // Performance metrics
        avgLatency  time.Duration
        avgBandwidth int64
}

// TopologyNode represents a node in the network topology
type TopologyNode struct {
        ID          string                 `json:"id"`
        Address     string                 `json:"address"`
        Capabilities []string              `json:"capabilities"`
        Connections []*TopologyConnection  `json:"connections"`
        Metadata    map[string]interface{} `json:"metadata"`
        
        // Performance metrics
        Latency     time.Duration          `json:"latency"`
        Bandwidth   int64                  `json:"bandwidth"`
        Reliability float64                `json:"reliability"`
}

// TopologyConnection represents a connection between nodes
type TopologyConnection struct {
        TargetID    string        `json:"target_id"`
        Weight      float64       `json:"weight"`
        Latency     time.Duration `json:"latency"`
        Bandwidth   int64         `json:"bandwidth"`
        Quality     float64       `json:"quality"`
}

// TopologyType represents the type of network topology
type TopologyType string

const (
        TopologyMesh         TopologyType = "mesh"
        TopologyHierarchical TopologyType = "hierarchical"
        TopologyRing         TopologyType = "ring"
        TopologyStar         TopologyType = "star"
        TopologyHybrid       TopologyType = "hybrid"
)

// ModelDiscovery handles model discovery across the network
type ModelDiscovery struct {
        manager     *DistributedModelManager
        
        // Discovery cache
        cache       map[string]*DiscoveryEntry
        cacheMutex  sync.RWMutex
        
        // Discovery workers
        workers     []*DiscoveryWorker
        workQueue   chan *DiscoveryRequest
        
        // Broadcast settings
        broadcastInterval time.Duration
        discoveryTimeout  time.Duration
}

// DiscoveryEntry represents a discovered model
type DiscoveryEntry struct {
        ModelName   string                 `json:"model_name"`
        PeerID      string                 `json:"peer_id"`
        Metadata    map[string]interface{} `json:"metadata"`
        Timestamp   time.Time              `json:"timestamp"`
        TTL         time.Duration          `json:"ttl"`
}

// DiscoveryRequest represents a model discovery request
type DiscoveryRequest struct {
        ModelName    string                 `json:"model_name"`
        Criteria     map[string]interface{} `json:"criteria"`
        Timeout      time.Duration          `json:"timeout"`
        ResponseChan chan *DiscoveryResponse `json:"-"`
}

// DiscoveryResponse represents a model discovery response
type DiscoveryResponse struct {
        Models    []*DistributedModel `json:"models"`
        Peers     []string            `json:"peers"`
        Error     string              `json:"error,omitempty"`
        Duration  time.Duration       `json:"duration"`
}

// DiscoveryWorker handles model discovery tasks
type DiscoveryWorker struct {
        ID         int
        discovery  *ModelDiscovery
        stopChan   chan struct{}
}

// PerformanceMonitor monitors the performance of the distributed system
type PerformanceMonitor struct {
        metrics     map[string]*PerformanceMetric
        metricsMutex sync.RWMutex
        
        // Monitoring settings
        interval    time.Duration
        retention   time.Duration
        
        // Alerting
        alerts      []*PerformanceAlert
        alertsMutex sync.RWMutex
}

// PerformanceMetric represents a performance metric
type PerformanceMetric struct {
        Name        string                 `json:"name"`
        Value       float64                `json:"value"`
        Unit        string                 `json:"unit"`
        Timestamp   time.Time              `json:"timestamp"`
        Labels      map[string]string      `json:"labels"`
        History     []MetricPoint          `json:"history"`
}

// MetricPoint represents a point in a metric's history
type MetricPoint struct {
        Timestamp time.Time `json:"timestamp"`
        Value     float64   `json:"value"`
}

// PerformanceAlert represents a performance alert
type PerformanceAlert struct {
        ID          string                 `json:"id"`
        Type        AlertType              `json:"type"`
        Severity    AlertSeverity          `json:"severity"`
        Message     string                 `json:"message"`
        Metadata    map[string]interface{} `json:"metadata"`
        Timestamp   time.Time              `json:"timestamp"`
        Resolved    bool                   `json:"resolved"`
        ResolvedAt  time.Time              `json:"resolved_at"`
}

// AlertType represents the type of alert
type AlertType string

const (
        AlertTypeLatency      AlertType = "latency"
        AlertTypeBandwidth    AlertType = "bandwidth"
        AlertTypeReplication  AlertType = "replication"
        AlertTypeSync         AlertType = "sync"
        AlertTypeStorage      AlertType = "storage"
        AlertTypeHealth       AlertType = "health"
)

// AlertSeverity represents the severity of an alert
type AlertSeverity string

const (
        SeverityInfo     AlertSeverity = "info"
        SeverityWarning  AlertSeverity = "warning"
        SeverityError    AlertSeverity = "error"
        SeverityCritical AlertSeverity = "critical"
)

// NewDistributedModelManager creates a new distributed model manager
func NewDistributedModelManager(
        config *config.DistributedConfig,
        p2pNode *p2p.Node,
        logger *slog.Logger,
) (*DistributedModelManager, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())
        
        // Create local manager
        localManager, err := NewManager(config.Storage, p2pNode)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create local manager: %w", err)
        }</span>
        
        // Create sync manager
        <span class="cov0" title="0">syncManager, err := NewSyncManager(config.Sync, p2pNode, localManager, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create sync manager: %w", err)
        }</span>
        
        // Create replication manager
        <span class="cov0" title="0">replicationManager, err := NewReplicationManager(config.Replication, p2pNode, localManager, syncManager, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create replication manager: %w", err)
        }</span>
        
        // Create content-addressed store
        <span class="cov0" title="0">casStore, err := NewContentAddressedStore(config.CASDir, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create CAS store: %w", err)
        }</span>
        
        // Create delta tracker
        <span class="cov0" title="0">deltaTracker, err := NewDeltaTracker(config.DeltaDir, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create delta tracker: %w", err)
        }</span>
        
        <span class="cov0" title="0">dmm := &amp;DistributedModelManager{
                localManager:       localManager,
                syncManager:        syncManager,
                replicationManager: replicationManager,
                casStore:           casStore,
                deltaTracker:       deltaTracker,
                config:             config,
                p2p:                p2pNode,
                logger:             logger,
                ctx:                ctx,
                cancel:             cancel,
        }
        
        // Initialize registry
        dmm.registry = &amp;DistributedRegistry{
                models:     make(map[string]*DistributedModel),
                peerModels: make(map[string]map[string]*DistributedModel),
                topology:   &amp;NetworkTopology{
                        nodes: make(map[string]*TopologyNode),
                },
        }
        
        // Initialize lifecycle manager
        dmm.lifecycle = &amp;ModelLifecycle{
                events: make(chan *LifecycleEvent, 100),
                stages: make(map[string]*LifecycleStage),
                hooks:  make(map[LifecycleEventType][]LifecycleHook),
        }
        
        // Initialize performance monitor
        dmm.monitor = &amp;PerformanceMonitor{
                metrics:  make(map[string]*PerformanceMetric),
                interval: time.Minute,
                retention: 24 * time.Hour,
        }
        
        // Initialize model discovery
        dmm.registry.discovery = &amp;ModelDiscovery{
                manager:           dmm,
                cache:             make(map[string]*DiscoveryEntry),
                workQueue:         make(chan *DiscoveryRequest, 100),
                broadcastInterval: 30 * time.Second,
                discoveryTimeout:  10 * time.Second,
        }
        
        return dmm, nil</span>
}

// Start starts the distributed model manager
func (dmm *DistributedModelManager) Start() error <span class="cov0" title="0">{
        dmm.mu.Lock()
        defer dmm.mu.Unlock()
        
        if dmm.started </span><span class="cov0" title="0">{
                return fmt.Errorf("distributed model manager already started")
        }</span>
        
        // Start local manager
        <span class="cov0" title="0">if err := dmm.localManager.Start(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start local manager: %w", err)
        }</span>
        
        // Start sync manager
        <span class="cov0" title="0">if err := dmm.syncManager.Start(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start sync manager: %w", err)
        }</span>
        
        // Start replication manager
        <span class="cov0" title="0">if err := dmm.replicationManager.Start(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start replication manager: %w", err)
        }</span>
        
        // Start lifecycle manager
        <span class="cov0" title="0">go dmm.lifecycle.start()
        
        // Start performance monitor
        go dmm.monitor.start()
        
        // Start model discovery
        go dmm.registry.discovery.start()
        
        // Start registry synchronization
        go dmm.registrySyncRoutine()
        
        dmm.started = true
        dmm.logger.Info("distributed model manager started")
        
        return nil</span>
}

// GetModel retrieves a model, either locally or from the network
func (dmm *DistributedModelManager) GetModel(modelName string) (*DistributedModel, error) <span class="cov0" title="0">{
        // Check local registry first
        dmm.registryMutex.RLock()
        if model, exists := dmm.registry.models[modelName]; exists </span><span class="cov0" title="0">{
                dmm.registryMutex.RUnlock()
                
                // Update access statistics
                model.AccessedAt = time.Now()
                model.AccessCount++
                
                // Emit lifecycle event
                dmm.emitLifecycleEvent(EventModelAccessed, modelName, dmm.p2p.ID().String(), map[string]interface{}{
                        "access_count": model.AccessCount,
                })
                
                return model, nil
        }</span>
        <span class="cov0" title="0">dmm.registryMutex.RUnlock()
        
        // Discover model on network
        return dmm.discoverAndFetchModel(modelName)</span>
}

// AddModel adds a model to the distributed system
func (dmm *DistributedModelManager) AddModel(modelName, modelPath string) (*DistributedModel, error) <span class="cov0" title="0">{
        // Create model version
        version, err := dmm.syncManager.CreateModelVersion(modelName, modelPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create model version: %w", err)
        }</span>
        
        // Create distributed model
        <span class="cov0" title="0">model := &amp;DistributedModel{
                Name:           modelName,
                Version:        version.Version,
                Hash:           version.Hash,
                Size:           version.Size,
                Type:           "gguf", // Default type
                Replicas:       []*ReplicaInfo{},
                Availability:   1.0,
                Versions:       []*ModelVersion{version},
                CurrentVersion: version.Version,
                Metadata:       make(map[string]interface{}),
                Tags:           []string{},
                CreatedAt:      time.Now(),
                UpdatedAt:      time.Now(),
                AccessedAt:     time.Now(),
                AccessCount:    0,
                DownloadCount:  0,
        }
        
        // Add to registry
        dmm.registryMutex.Lock()
        dmm.registry.models[modelName] = model
        dmm.registryMutex.Unlock()
        
        // Set default replication policy
        policy := &amp;ReplicationPolicy{
                ModelName:         modelName,
                MinReplicas:       dmm.config.Replication.DefaultMinReplicas,
                MaxReplicas:       dmm.config.Replication.DefaultMaxReplicas,
                ReplicationFactor: dmm.config.Replication.DefaultReplicationFactor,
                SyncInterval:      dmm.config.Replication.DefaultSyncInterval,
                Priority:          1,
                Constraints:       make(map[string]string),
                CreatedAt:         time.Now(),
                UpdatedAt:         time.Now(),
        }
        
        model.Policy = policy
        dmm.replicationManager.SetReplicationPolicy(modelName, policy)
        
        // Emit lifecycle event
        dmm.emitLifecycleEvent(EventModelCreated, modelName, dmm.p2p.ID().String(), map[string]interface{}{
                "version": version.Version,
                "hash":    version.Hash,
                "size":    version.Size,
        })
        
        dmm.logger.Info("model added to distributed system", "model", modelName, "version", version.Version)
        
        return model, nil</span>
}

// discoverAndFetchModel discovers a model on the network and fetches it
func (dmm *DistributedModelManager) discoverAndFetchModel(modelName string) (*DistributedModel, error) <span class="cov0" title="0">{
        // Create discovery request
        req := &amp;DiscoveryRequest{
                ModelName:    modelName,
                Criteria:     make(map[string]interface{}),
                Timeout:      dmm.registry.discovery.discoveryTimeout,
                ResponseChan: make(chan *DiscoveryResponse, 1),
        }
        
        // Submit discovery request
        select </span>{
        case dmm.registry.discovery.workQueue &lt;- req:<span class="cov0" title="0"></span>
        case &lt;-time.After(5 * time.Second):<span class="cov0" title="0">
                return nil, fmt.Errorf("discovery queue full")</span>
        }
        
        // Wait for response
        <span class="cov0" title="0">select </span>{
        case resp := &lt;-req.ResponseChan:<span class="cov0" title="0">
                if resp.Error != "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("discovery failed: %s", resp.Error)
                }</span>
                
                <span class="cov0" title="0">if len(resp.Models) == 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("model not found: %s", modelName)
                }</span>
                
                // Use the first available model
                <span class="cov0" title="0">model := resp.Models[0]
                
                // Download model from a peer
                if len(resp.Peers) &gt; 0 </span><span class="cov0" title="0">{
                        if err := dmm.downloadModelFromPeer(modelName, resp.Peers[0]); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to download model: %w", err)
                        }</span>
                }
                
                // Add to local registry
                <span class="cov0" title="0">dmm.registryMutex.Lock()
                dmm.registry.models[modelName] = model
                dmm.registryMutex.Unlock()
                
                return model, nil</span>
                
        case &lt;-time.After(dmm.registry.discovery.discoveryTimeout):<span class="cov0" title="0">
                return nil, fmt.Errorf("discovery timeout")</span>
        }
}

// downloadModelFromPeer downloads a model from a specific peer
func (dmm *DistributedModelManager) downloadModelFromPeer(modelName, peerID string) error <span class="cov0" title="0">{
        // Use the local manager to download the model
        _, err := dmm.localManager.DownloadModel(modelName, peerID)
        return err
}</span>

// emitLifecycleEvent emits a lifecycle event
func (dmm *DistributedModelManager) emitLifecycleEvent(eventType LifecycleEventType, modelName, peerID string, data map[string]interface{}) <span class="cov0" title="0">{
        event := &amp;LifecycleEvent{
                Type:      eventType,
                ModelName: modelName,
                PeerID:    peerID,
                Timestamp: time.Now(),
                Data:      data,
        }
        
        select </span>{
        case dmm.lifecycle.events &lt;- event:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                // Event queue full, log warning
                dmm.logger.Warn("lifecycle event queue full", "event", eventType, "model", modelName)</span>
        }
}

// registrySyncRoutine periodically synchronizes the registry
func (dmm *DistributedModelManager) registrySyncRoutine() <span class="cov0" title="0">{
        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-dmm.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        dmm.syncRegistry()</span>
                }
        }
}

// syncRegistry synchronizes the registry with peers  
func (dmm *DistributedModelManager) syncRegistry() <span class="cov0" title="0">{
        // Get connected peers
        peerIDs := dmm.p2p.GetConnectedPeers()
        if len(peerIDs) == 0 </span><span class="cov0" title="0">{
                return // No peers to sync with
        }</span>
        
        <span class="cov0" title="0">var peers []string
        for _, peerID := range peerIDs </span><span class="cov0" title="0">{
                peers = append(peers, peerID.String())
        }</span>

        // Prepare local registry for broadcasting
        <span class="cov0" title="0">dmm.registryMutex.RLock()
        localModels := make(map[string]*DistributedModel)
        for k, v := range dmm.registry.models </span><span class="cov0" title="0">{
                localModels[k] = v
        }</span>
        <span class="cov0" title="0">dmm.registryMutex.RUnlock()

        // Broadcast local models to peers
        for _, peerStr := range peers </span><span class="cov0" title="0">{
                go dmm.syncWithPeer(peerStr, localModels)
        }</span>

        // Request model information from peers
        <span class="cov0" title="0">for _, peerStr := range peers </span><span class="cov0" title="0">{
                go dmm.requestPeerModels(peerStr)
        }</span>

        // Clean up stale peer entries
        <span class="cov0" title="0">dmm.cleanupStalePeers()</span>
}

// GetDistributedModels returns all distributed models
func (dmm *DistributedModelManager) GetDistributedModels() []*DistributedModel <span class="cov0" title="0">{
        dmm.registryMutex.RLock()
        defer dmm.registryMutex.RUnlock()
        
        models := make([]*DistributedModel, 0, len(dmm.registry.models))
        for _, model := range dmm.registry.models </span><span class="cov0" title="0">{
                models = append(models, model)
        }</span>
        
        <span class="cov0" title="0">return models</span>
}

// GetPerformanceMetrics returns performance metrics
func (dmm *DistributedModelManager) GetPerformanceMetrics() []*PerformanceMetric <span class="cov0" title="0">{
        dmm.monitor.metricsMutex.RLock()
        defer dmm.monitor.metricsMutex.RUnlock()
        
        metrics := make([]*PerformanceMetric, 0, len(dmm.monitor.metrics))
        for _, metric := range dmm.monitor.metrics </span><span class="cov0" title="0">{
                metrics = append(metrics, metric)
        }</span>
        
        <span class="cov0" title="0">return metrics</span>
}

// Shutdown gracefully shuts down the distributed model manager
func (dmm *DistributedModelManager) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        dmm.mu.Lock()
        defer dmm.mu.Unlock()
        
        if !dmm.started </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        // Shutdown components
        <span class="cov0" title="0">if err := dmm.replicationManager.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                dmm.logger.Error("failed to shutdown replication manager", "error", err)
        }</span>
        
        <span class="cov0" title="0">if err := dmm.syncManager.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                dmm.logger.Error("failed to shutdown sync manager", "error", err)
        }</span>
        
        <span class="cov0" title="0">if err := dmm.localManager.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                dmm.logger.Error("failed to shutdown local manager", "error", err)
        }</span>
        
        <span class="cov0" title="0">if err := dmm.casStore.Close(); err != nil </span><span class="cov0" title="0">{
                dmm.logger.Error("failed to close CAS store", "error", err)
        }</span>
        
        <span class="cov0" title="0">if err := dmm.deltaTracker.Close(); err != nil </span><span class="cov0" title="0">{
                dmm.logger.Error("failed to close delta tracker", "error", err)
        }</span>
        
        <span class="cov0" title="0">dmm.cancel()
        dmm.started = false
        
        dmm.logger.Info("distributed model manager shutdown complete")
        return nil</span>
}

// ModelLifecycle methods

// start starts the lifecycle manager
func (ml *ModelLifecycle) start() <span class="cov0" title="0">{
        for event := range ml.events </span><span class="cov0" title="0">{
                ml.processEvent(event)
        }</span>
}

// processEvent processes a lifecycle event
func (ml *ModelLifecycle) processEvent(event *LifecycleEvent) <span class="cov0" title="0">{
        // Execute hooks
        ml.hooksMutex.RLock()
        hooks := ml.hooks[event.Type]
        ml.hooksMutex.RUnlock()
        
        for _, hook := range hooks </span><span class="cov0" title="0">{
                if err := hook(event); err != nil </span><span class="cov0" title="0">{
                        // Log hook error but continue
                        fmt.Printf("Lifecycle hook error: %v\n", err)
                }</span>
        }
}

// PerformanceMonitor methods

// start starts the performance monitor
func (pm *PerformanceMonitor) start() <span class="cov0" title="0">{
        ticker := time.NewTicker(pm.interval)
        defer ticker.Stop()
        
        for range ticker.C </span><span class="cov0" title="0">{
                pm.collectMetrics()
        }</span>
}

// collectMetrics collects performance metrics
func (pm *PerformanceMonitor) collectMetrics() <span class="cov0" title="0">{
        now := time.Now()

        // Collect model access latency
        pm.collectModelAccessMetrics(now)

        // Collect replication bandwidth
        pm.collectReplicationMetrics(now)

        // Collect sync success rate
        pm.collectSyncMetrics(now)

        // Collect storage utilization
        pm.collectStorageMetrics(now)

        // Collect network connectivity
        pm.collectNetworkMetrics(now)

        // Clean up old metrics
        pm.cleanupOldMetrics(now)
}</span>

// ModelDiscovery methods

// start starts the model discovery service
func (md *ModelDiscovery) start() <span class="cov0" title="0">{
        // Start discovery workers
        md.workers = make([]*DiscoveryWorker, 3)
        for i := 0; i &lt; 3; i++ </span><span class="cov0" title="0">{
                md.workers[i] = &amp;DiscoveryWorker{
                        ID:        i,
                        discovery: md,
                        stopChan:  make(chan struct{}),
                }
                go md.workers[i].start()
        }</span>
        
        // Start broadcast routine
        <span class="cov0" title="0">go md.broadcastRoutine()</span>
}

// broadcastRoutine periodically broadcasts model information
func (md *ModelDiscovery) broadcastRoutine() <span class="cov0" title="0">{
        ticker := time.NewTicker(md.broadcastInterval)
        defer ticker.Stop()
        
        for range ticker.C </span><span class="cov0" title="0">{
                md.broadcastModels()
        }</span>
}

// broadcastModels broadcasts local model information to peers
func (md *ModelDiscovery) broadcastModels() <span class="cov0" title="0">{
        // Get local models from manager
        models := md.manager.GetDistributedModels()
        if len(models) == 0 </span><span class="cov0" title="0">{
                return // No models to broadcast
        }</span>

        // Prepare broadcast message
        <span class="cov0" title="0">broadcast := map[string]interface{}{
                "type":      "model_broadcast",
                "peer_id":   md.manager.p2p.ID().String(),
                "timestamp": time.Now().Unix(),
                "models":    md.prepareModelBroadcast(models),
        }

        // Send to all connected peers
        peerIDs := md.manager.p2p.GetConnectedPeers()
        for _, peerID := range peerIDs </span><span class="cov0" title="0">{
                go md.sendBroadcastToPeer(peerID, broadcast)
        }</span>

        // Update broadcast metrics
        <span class="cov0" title="0">md.updateBroadcastMetrics(len(peerIDs), len(models))</span>
}

// DiscoveryWorker methods

// start starts the discovery worker
func (dw *DiscoveryWorker) start() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-dw.stopChan:<span class="cov0" title="0">
                        return</span>
                case req := &lt;-dw.discovery.workQueue:<span class="cov0" title="0">
                        dw.processRequest(req)</span>
                }
        }
}

// processRequest processes a discovery request
func (dw *DiscoveryWorker) processRequest(req *DiscoveryRequest) <span class="cov0" title="0">{
        start := time.Now()

        // Search local cache first
        foundModels, foundPeers := dw.searchLocalCache(req.ModelName, req.Criteria)

        // If not found locally, search network
        if len(foundModels) == 0 </span><span class="cov0" title="0">{
                networkModels, networkPeers := dw.searchNetwork(req.ModelName, req.Criteria, req.Timeout)
                foundModels = append(foundModels, networkModels...)
                foundPeers = append(foundPeers, networkPeers...)
        }</span>

        // Filter and rank results
        <span class="cov0" title="0">filteredModels := dw.filterResults(foundModels, req.Criteria)
        rankedModels := dw.rankResults(filteredModels)

        // Prepare response
        resp := &amp;DiscoveryResponse{
                Models:   rankedModels,
                Peers:    foundPeers,
                Duration: time.Since(start),
        }

        // Send response
        select </span>{
        case req.ResponseChan &lt;- resp:<span class="cov0" title="0"></span>
        case &lt;-time.After(time.Second):<span class="cov0" title="0">
                // Response channel blocked, log warning
                dw.discovery.manager.logger.Warn("discovery response channel blocked")</span>
        }
}

// Helper methods for registry synchronization

// syncWithPeer synchronizes models with a specific peer
func (dmm *DistributedModelManager) syncWithPeer(peerIDStr string, localModels map[string]*DistributedModel) <span class="cov0" title="0">{
        // Prepare sync message
        syncMessage := map[string]interface{}{
                "type":      "registry_sync",
                "peer_id":   dmm.p2p.ID().String(),
                "timestamp": time.Now().Unix(),
                "models":    localModels,
        }

        // Send via P2P (simplified implementation)
        // In practice, this would use libp2p streams
        dmm.logger.Info("syncing models with peer", "peer", peerIDStr, "models", len(localModels), "sync_message", syncMessage)
}</span>

// requestPeerModels requests model information from a peer
func (dmm *DistributedModelManager) requestPeerModels(peerIDStr string) <span class="cov0" title="0">{
        // Create request message
        request := map[string]interface{}{
                "type":      "model_request",
                "peer_id":   dmm.p2p.ID().String(),
                "timestamp": time.Now().Unix(),
        }

        // Send request via P2P (simplified implementation)
        dmm.logger.Info("requesting models from peer", "peer", peerIDStr, "request", request)
}</span>

// cleanupStalePeers removes stale peer entries
func (dmm *DistributedModelManager) cleanupStalePeers() <span class="cov0" title="0">{
        dmm.registry.peerMutex.Lock()
        defer dmm.registry.peerMutex.Unlock()

        connectedPeerIDs := dmm.p2p.GetConnectedPeers()
        connectedMap := make(map[string]bool)
        for _, peerID := range connectedPeerIDs </span><span class="cov0" title="0">{
                connectedMap[peerID.String()] = true
        }</span>

        // Remove disconnected peers
        <span class="cov0" title="0">for peerID := range dmm.registry.peerModels </span><span class="cov0" title="0">{
                if !connectedMap[peerID] </span><span class="cov0" title="0">{
                        delete(dmm.registry.peerModels, peerID)
                }</span>
        }
}

// Helper methods for performance monitoring

// collectModelAccessMetrics collects model access latency metrics
func (pm *PerformanceMonitor) collectModelAccessMetrics(now time.Time) <span class="cov0" title="0">{
        pm.metricsMutex.Lock()
        defer pm.metricsMutex.Unlock()

        // Simulate collecting access latency
        latencyMetric := &amp;PerformanceMetric{
                Name:      "model_access_latency",
                Value:     float64(50 + (now.UnixNano() % 100)), // Simulate 50-150ms
                Unit:      "milliseconds",
                Timestamp: now,
                Labels:    map[string]string{"type": "access"},
                History:   []MetricPoint{{Timestamp: now, Value: 75.5}},
        }

        pm.metrics["model_access_latency"] = latencyMetric
}</span>

// collectReplicationMetrics collects replication bandwidth metrics
func (pm *PerformanceMonitor) collectReplicationMetrics(now time.Time) <span class="cov0" title="0">{
        pm.metricsMutex.Lock()
        defer pm.metricsMutex.Unlock()

        // Simulate bandwidth metrics
        bandwidthMetric := &amp;PerformanceMetric{
                Name:      "replication_bandwidth",
                Value:     float64(1024 * 1024 * 10), // 10 MB/s
                Unit:      "bytes_per_second",
                Timestamp: now,
                Labels:    map[string]string{"type": "replication"},
                History:   []MetricPoint{{Timestamp: now, Value: 1024 * 1024 * 10}},
        }

        pm.metrics["replication_bandwidth"] = bandwidthMetric
}</span>

// collectSyncMetrics collects synchronization success rate metrics
func (pm *PerformanceMonitor) collectSyncMetrics(now time.Time) <span class="cov0" title="0">{
        pm.metricsMutex.Lock()
        defer pm.metricsMutex.Unlock()

        // Simulate sync success rate
        syncMetric := &amp;PerformanceMetric{
                Name:      "sync_success_rate",
                Value:     95.5, // 95.5% success rate
                Unit:      "percentage",
                Timestamp: now,
                Labels:    map[string]string{"type": "sync"},
                History:   []MetricPoint{{Timestamp: now, Value: 95.5}},
        }

        pm.metrics["sync_success_rate"] = syncMetric
}</span>

// collectStorageMetrics collects storage utilization metrics
func (pm *PerformanceMonitor) collectStorageMetrics(now time.Time) <span class="cov0" title="0">{
        pm.metricsMutex.Lock()
        defer pm.metricsMutex.Unlock()

        // Simulate storage usage
        storageMetric := &amp;PerformanceMetric{
                Name:      "storage_utilization",
                Value:     65.2, // 65.2% storage used
                Unit:      "percentage",
                Timestamp: now,
                Labels:    map[string]string{"type": "storage"},
                History:   []MetricPoint{{Timestamp: now, Value: 65.2}},
        }

        pm.metrics["storage_utilization"] = storageMetric
}</span>

// collectNetworkMetrics collects network connectivity metrics
func (pm *PerformanceMonitor) collectNetworkMetrics(now time.Time) <span class="cov0" title="0">{
        pm.metricsMutex.Lock()
        defer pm.metricsMutex.Unlock()

        // Simulate network connectivity
        networkMetric := &amp;PerformanceMetric{
                Name:      "network_connectivity",
                Value:     98.7, // 98.7% uptime
                Unit:      "percentage",
                Timestamp: now,
                Labels:    map[string]string{"type": "network"},
                History:   []MetricPoint{{Timestamp: now, Value: 98.7}},
        }

        pm.metrics["network_connectivity"] = networkMetric
}</span>

// cleanupOldMetrics removes old metric history points
func (pm *PerformanceMonitor) cleanupOldMetrics(now time.Time) <span class="cov0" title="0">{
        pm.metricsMutex.Lock()
        defer pm.metricsMutex.Unlock()

        cutoff := now.Add(-pm.retention)
        for _, metric := range pm.metrics </span><span class="cov0" title="0">{
                var newHistory []MetricPoint
                for _, point := range metric.History </span><span class="cov0" title="0">{
                        if point.Timestamp.After(cutoff) </span><span class="cov0" title="0">{
                                newHistory = append(newHistory, point)
                        }</span>
                }
                <span class="cov0" title="0">metric.History = newHistory</span>
        }
}

// Helper methods for model discovery

// prepareModelBroadcast prepares models for broadcasting
func (md *ModelDiscovery) prepareModelBroadcast(models []*DistributedModel) []map[string]interface{} <span class="cov0" title="0">{
        var broadcast []map[string]interface{}
        for _, model := range models </span><span class="cov0" title="0">{
                broadcast = append(broadcast, map[string]interface{}{
                        "name":         model.Name,
                        "version":      model.Version,
                        "hash":         model.Hash,
                        "size":         model.Size,
                        "availability": model.Availability,
                        "replicas":     len(model.Replicas),
                })
        }</span>
        <span class="cov0" title="0">return broadcast</span>
}

// sendBroadcastToPeer sends broadcast message to a specific peer
func (md *ModelDiscovery) sendBroadcastToPeer(peerID peer.ID, broadcast map[string]interface{}) <span class="cov0" title="0">{
        // Send via P2P (simplified implementation)
        // In practice, this would use libp2p streams
        fmt.Printf("Broadcasting models to peer %s\n", peerID.String())
}</span>

// updateBroadcastMetrics updates broadcast metrics
func (md *ModelDiscovery) updateBroadcastMetrics(peerCount, modelCount int) <span class="cov0" title="0">{
        // Update internal metrics (simplified)
        fmt.Printf("Broadcast sent to %d peers with %d models\n", peerCount, modelCount)
}</span>

// Helper methods for discovery worker

// searchLocalCache searches for models in local cache
func (dw *DiscoveryWorker) searchLocalCache(modelName string, criteria map[string]interface{}) ([]*DistributedModel, []string) <span class="cov0" title="0">{
        dw.discovery.cacheMutex.RLock()
        defer dw.discovery.cacheMutex.RUnlock()

        var foundModels []*DistributedModel
        var foundPeers []string

        for _, entry := range dw.discovery.cache </span><span class="cov0" title="0">{
                if entry.ModelName == modelName || modelName == "" </span><span class="cov0" title="0">{
                        // Create model from cache entry
                        model := &amp;DistributedModel{
                                Name:      entry.ModelName,
                                Version:   "1.0",
                                Hash:      "unknown",
                                Size:      1024,
                                Type:      "gguf",
                                Metadata:  entry.Metadata,
                                CreatedAt: entry.Timestamp,
                        }
                        foundModels = append(foundModels, model)
                        foundPeers = append(foundPeers, entry.PeerID)
                }</span>
        }

        <span class="cov0" title="0">return foundModels, foundPeers</span>
}

// searchNetwork searches for models across the network
func (dw *DiscoveryWorker) searchNetwork(modelName string, criteria map[string]interface{}, timeout time.Duration) ([]*DistributedModel, []string) <span class="cov0" title="0">{
        // Simulate network search
        // In practice, this would query connected peers
        var foundModels []*DistributedModel
        var foundPeers []string

        // Mock finding a model on the network
        if modelName != "" </span><span class="cov0" title="0">{
                model := &amp;DistributedModel{
                        Name:      modelName,
                        Version:   "1.0",
                        Hash:      "network_hash",
                        Size:      2048,
                        Type:      "gguf",
                        Metadata:  make(map[string]interface{}),
                        CreatedAt: time.Now(),
                }
                foundModels = append(foundModels, model)
                foundPeers = append(foundPeers, "network_peer_123")
        }</span>

        <span class="cov0" title="0">return foundModels, foundPeers</span>
}

// filterResults filters models based on criteria
func (dw *DiscoveryWorker) filterResults(models []*DistributedModel, criteria map[string]interface{}) []*DistributedModel <span class="cov0" title="0">{
        if len(criteria) == 0 </span><span class="cov0" title="0">{
                return models
        }</span>

        <span class="cov0" title="0">var filtered []*DistributedModel
        for _, model := range models </span><span class="cov0" title="0">{
                if dw.matchesCriteria(model, criteria) </span><span class="cov0" title="0">{
                        filtered = append(filtered, model)
                }</span>
        }
        <span class="cov0" title="0">return filtered</span>
}

// rankResults ranks models by relevance
func (dw *DiscoveryWorker) rankResults(models []*DistributedModel) []*DistributedModel <span class="cov0" title="0">{
        // Simple ranking by size (smaller first)
        for i := 0; i &lt; len(models)-1; i++ </span><span class="cov0" title="0">{
                for j := i + 1; j &lt; len(models); j++ </span><span class="cov0" title="0">{
                        if models[i].Size &gt; models[j].Size </span><span class="cov0" title="0">{
                                models[i], models[j] = models[j], models[i]
                        }</span>
                }
        }
        <span class="cov0" title="0">return models</span>
}

// matchesCriteria checks if a model matches search criteria
func (dw *DiscoveryWorker) matchesCriteria(model *DistributedModel, criteria map[string]interface{}) bool <span class="cov0" title="0">{
        // Simple criteria matching
        if minSize, exists := criteria["min_size"]; exists </span><span class="cov0" title="0">{
                if size, ok := minSize.(int64); ok &amp;&amp; model.Size &lt; size </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">if maxSize, exists := criteria["max_size"]; exists </span><span class="cov0" title="0">{
                if size, ok := maxSize.(int64); ok &amp;&amp; model.Size &gt; size </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}</pre>
		
		<pre class="file" id="file14" style="display: none">package models

import (
        "context"
        "crypto/sha256"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "sync"
        "time"

        "github.com/ollama/ollama-distributed/internal/config"
        "github.com/ollama/ollama-distributed/pkg/p2p"
)

// Manager manages model distribution across the network
type Manager struct {
        config *config.StorageConfig
        p2p    *p2p.Node
        
        // Local model storage
        models    map[string]*Model
        modelsMu  sync.RWMutex
        
        // Transfer management
        transfers map[string]*Transfer
        transfersMu sync.RWMutex
        
        // Download queue
        downloadQueue chan *DownloadRequest
        uploadQueue   chan *UploadRequest
        
        // Workers
        downloadWorkers []*DownloadWorker
        uploadWorkers   []*UploadWorker
        
        started bool
        mu      sync.RWMutex
        
        ctx    context.Context
        cancel context.CancelFunc
}

// Model represents a model in the distributed system
type Model struct {
        Name        string            `json:"name"`
        Version     string            `json:"version"`
        Size        int64             `json:"size"`
        Checksum    string            `json:"checksum"`
        Path        string            `json:"path"`
        Status      ModelStatus       `json:"status"`
        Replicas    []string          `json:"replicas"`    // Node IDs that have this model
        Metadata    map[string]string `json:"metadata"`
        CreatedAt   time.Time         `json:"created_at"`
        UpdatedAt   time.Time         `json:"updated_at"`
        AccessCount int64             `json:"access_count"`
        LastAccessed time.Time        `json:"last_accessed"`
}

// ModelStatus represents the status of a model
type ModelStatus string

const (
        ModelStatusDownloading ModelStatus = "downloading"
        ModelStatusAvailable   ModelStatus = "available"
        ModelStatusCorrupted   ModelStatus = "corrupted"
        ModelStatusDeleted     ModelStatus = "deleted"
)

// Transfer represents a model transfer operation
type Transfer struct {
        ID          string          `json:"id"`
        ModelName   string          `json:"model_name"`
        Type        TransferType    `json:"type"`
        Status      TransferStatus  `json:"status"`
        Progress    float64         `json:"progress"`
        BytesTotal  int64           `json:"bytes_total"`
        BytesDone   int64           `json:"bytes_done"`
        Speed       int64           `json:"speed"`       // bytes per second
        PeerID      string          `json:"peer_id"`
        StartedAt   time.Time       `json:"started_at"`
        CompletedAt time.Time       `json:"completed_at"`
        Error       string          `json:"error,omitempty"`
        
        // Internal fields
        ctx    context.Context
        cancel context.CancelFunc
}

// TransferType represents the type of transfer
type TransferType string

const (
        TransferTypeDownload TransferType = "download"
        TransferTypeUpload   TransferType = "upload"
)

// TransferStatus represents the status of a transfer
type TransferStatus string

const (
        TransferStatusPending    TransferStatus = "pending"
        TransferStatusActive     TransferStatus = "active"
        TransferStatusCompleted  TransferStatus = "completed"
        TransferStatusFailed     TransferStatus = "failed"
        TransferStatusCancelled  TransferStatus = "cancelled"
)

// DownloadRequest represents a request to download a model
type DownloadRequest struct {
        ModelName string
        PeerID    string
        Priority  int
        ResponseCh chan *DownloadResponse
}

// DownloadResponse represents a response to a download request
type DownloadResponse struct {
        Success   bool
        Model     *Model
        Error     string
        Duration  time.Duration
}

// UploadRequest represents a request to upload a model
type UploadRequest struct {
        ModelName string
        PeerID    string
        ResponseCh chan *UploadResponse
}

// UploadResponse represents a response to an upload request
type UploadResponse struct {
        Success  bool
        Error    string
        Duration time.Duration
}

// DownloadWorker handles download operations
type DownloadWorker struct {
        ID      int
        manager *Manager
        stopCh  chan struct{}
}

// UploadWorker handles upload operations
type UploadWorker struct {
        ID      int
        manager *Manager
        stopCh  chan struct{}
}

// NewManager creates a new model distribution manager
func NewManager(config *config.StorageConfig, p2pNode *p2p.Node) (*Manager, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())
        
        manager := &amp;Manager{
                config:        config,
                p2p:           p2pNode,
                models:        make(map[string]*Model),
                transfers:     make(map[string]*Transfer),
                downloadQueue: make(chan *DownloadRequest, 100),
                uploadQueue:   make(chan *UploadRequest, 100),
                ctx:           ctx,
                cancel:        cancel,
        }
        
        // Create download workers
        manager.downloadWorkers = make([]*DownloadWorker, 3)
        for i := 0; i &lt; 3; i++ </span><span class="cov0" title="0">{
                manager.downloadWorkers[i] = &amp;DownloadWorker{
                        ID:      i,
                        manager: manager,
                        stopCh:  make(chan struct{}),
                }
        }</span>
        
        // Create upload workers
        <span class="cov0" title="0">manager.uploadWorkers = make([]*UploadWorker, 3)
        for i := 0; i &lt; 3; i++ </span><span class="cov0" title="0">{
                manager.uploadWorkers[i] = &amp;UploadWorker{
                        ID:      i,
                        manager: manager,
                        stopCh:  make(chan struct{}),
                }
        }</span>
        
        <span class="cov0" title="0">return manager, nil</span>
}

// Start starts the model distribution manager
func (m *Manager) Start() error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        if m.started </span><span class="cov0" title="0">{
                return fmt.Errorf("model manager already started")
        }</span>
        
        // Create storage directories
        <span class="cov0" title="0">if err := os.MkdirAll(m.config.ModelDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create model directory: %w", err)
        }</span>
        
        // Load existing models
        <span class="cov0" title="0">if err := m.loadModels(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load models: %w", err)
        }</span>
        
        // Start workers
        <span class="cov0" title="0">for _, worker := range m.downloadWorkers </span><span class="cov0" title="0">{
                go worker.start()
        }</span>
        
        <span class="cov0" title="0">for _, worker := range m.uploadWorkers </span><span class="cov0" title="0">{
                go worker.start()
        }</span>
        
        // Start cleanup routine
        <span class="cov0" title="0">go m.cleanupRoutine()
        
        m.started = true
        return nil</span>
}

// loadModels loads existing models from disk
func (m *Manager) loadModels() error <span class="cov0" title="0">{
        return filepath.Walk(m.config.ModelDir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>
                
                // Check if it's a model file (you might want to add more sophisticated detection)
                <span class="cov0" title="0">if filepath.Ext(path) == ".gguf" || filepath.Ext(path) == ".bin" </span><span class="cov0" title="0">{
                        if err := m.registerLocalModel(path); err != nil </span><span class="cov0" title="0">{
                                // Log error but continue
                                fmt.Printf("Failed to register model %s: %v\n", path, err)
                        }</span>
                }
                
                <span class="cov0" title="0">return nil</span>
        })
}

// registerLocalModel registers a local model file
func (m *Manager) registerLocalModel(path string) error <span class="cov0" title="0">{
        // Get file info
        info, err := os.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stat model file: %w", err)
        }</span>
        
        // Calculate checksum
        <span class="cov0" title="0">checksum, err := m.calculateChecksum(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to calculate checksum: %w", err)
        }</span>
        
        // Extract model name from path
        <span class="cov0" title="0">name := filepath.Base(path)
        name = name[:len(name)-len(filepath.Ext(name))]
        
        // Create model entry
        model := &amp;Model{
                Name:         name,
                Version:      "1.0.0", // TODO: Extract version from filename or metadata
                Size:         info.Size(),
                Checksum:     checksum,
                Path:         path,
                Status:       ModelStatusAvailable,
                Replicas:     []string{m.p2p.ID().String()},
                Metadata:     make(map[string]string),
                CreatedAt:    info.ModTime(),
                UpdatedAt:    info.ModTime(),
                AccessCount:  0,
                LastAccessed: time.Now(),
        }
        
        m.modelsMu.Lock()
        m.models[name] = model
        m.modelsMu.Unlock()
        
        return nil</span>
}

// calculateChecksum calculates SHA256 checksum of a file
func (m *Manager) calculateChecksum(path string) (string, error) <span class="cov0" title="0">{
        file, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer file.Close()
        
        hash := sha256.New()
        if _, err := io.Copy(hash, file); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        
        <span class="cov0" title="0">return fmt.Sprintf("%x", hash.Sum(nil)), nil</span>
}

// cleanupRoutine runs periodic cleanup tasks
func (m *Manager) cleanupRoutine() <span class="cov0" title="0">{
        ticker := time.NewTicker(time.Hour)
        defer ticker.Stop()
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-m.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        m.cleanup()</span>
                }
        }
}

// cleanup performs cleanup tasks
func (m *Manager) cleanup() <span class="cov0" title="0">{
        // Remove old transfers
        m.transfersMu.Lock()
        for id, transfer := range m.transfers </span><span class="cov0" title="0">{
                if transfer.Status == TransferStatusCompleted || transfer.Status == TransferStatusFailed </span><span class="cov0" title="0">{
                        if time.Since(transfer.CompletedAt) &gt; time.Hour </span><span class="cov0" title="0">{
                                delete(m.transfers, id)
                        }</span>
                }
        }
        <span class="cov0" title="0">m.transfersMu.Unlock()
        
        // Clean up old model files based on cleanup age
        m.modelsMu.Lock()
        for name, model := range m.models </span><span class="cov0" title="0">{
                if time.Since(model.LastAccessed) &gt; m.config.CleanupAge </span><span class="cov0" title="0">{
                        // Remove model file
                        if err := os.Remove(model.Path); err == nil </span><span class="cov0" title="0">{
                                delete(m.models, name)
                        }</span>
                }
        }
        <span class="cov0" title="0">m.modelsMu.Unlock()</span>
}

// DownloadModel downloads a model from peers
func (m *Manager) DownloadModel(modelName string, peerID string) (*Model, error) <span class="cov0" title="0">{
        responseCh := make(chan *DownloadResponse, 1)
        
        req := &amp;DownloadRequest{
                ModelName:  modelName,
                PeerID:     peerID,
                Priority:   1,
                ResponseCh: responseCh,
        }
        
        select </span>{
        case m.downloadQueue &lt;- req:<span class="cov0" title="0"></span>
        case &lt;-time.After(5 * time.Second):<span class="cov0" title="0">
                return nil, fmt.Errorf("download queue full")</span>
        }
        
        <span class="cov0" title="0">select </span>{
        case response := &lt;-responseCh:<span class="cov0" title="0">
                if response.Success </span><span class="cov0" title="0">{
                        return response.Model, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("download failed: %s", response.Error)</span>
        case &lt;-time.After(10 * time.Minute):<span class="cov0" title="0">
                return nil, fmt.Errorf("download timeout")</span>
        }
}

// GetModel returns a model by name
func (m *Manager) GetModel(name string) (*Model, bool) <span class="cov0" title="0">{
        m.modelsMu.RLock()
        defer m.modelsMu.RUnlock()
        
        model, exists := m.models[name]
        if exists </span><span class="cov0" title="0">{
                // Update access statistics
                model.AccessCount++
                model.LastAccessed = time.Now()
        }</span>
        
        <span class="cov0" title="0">return model, exists</span>
}

// GetAllModels returns all models
func (m *Manager) GetAllModels() map[string]*Model <span class="cov0" title="0">{
        m.modelsMu.RLock()
        defer m.modelsMu.RUnlock()
        
        models := make(map[string]*Model)
        for k, v := range m.models </span><span class="cov0" title="0">{
                models[k] = v
        }</span>
        
        <span class="cov0" title="0">return models</span>
}

// GetTransfer returns a transfer by ID
func (m *Manager) GetTransfer(id string) (*Transfer, bool) <span class="cov0" title="0">{
        m.transfersMu.RLock()
        defer m.transfersMu.RUnlock()
        
        transfer, exists := m.transfers[id]
        return transfer, exists
}</span>

// GetAllTransfers returns all transfers
func (m *Manager) GetAllTransfers() map[string]*Transfer <span class="cov0" title="0">{
        m.transfersMu.RLock()
        defer m.transfersMu.RUnlock()
        
        transfers := make(map[string]*Transfer)
        for k, v := range m.transfers </span><span class="cov0" title="0">{
                transfers[k] = v
        }</span>
        
        <span class="cov0" title="0">return transfers</span>
}

// Shutdown gracefully shuts down the model manager
func (m *Manager) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        if !m.started </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        // Stop workers
        <span class="cov0" title="0">for _, worker := range m.downloadWorkers </span><span class="cov0" title="0">{
                close(worker.stopCh)
        }</span>
        
        <span class="cov0" title="0">for _, worker := range m.uploadWorkers </span><span class="cov0" title="0">{
                close(worker.stopCh)
        }</span>
        
        // Cancel ongoing transfers
        <span class="cov0" title="0">m.transfersMu.Lock()
        for _, transfer := range m.transfers </span><span class="cov0" title="0">{
                if transfer.Status == TransferStatusActive </span><span class="cov0" title="0">{
                        transfer.cancel()
                }</span>
        }
        <span class="cov0" title="0">m.transfersMu.Unlock()
        
        // Cancel context
        m.cancel()
        
        m.started = false
        return nil</span>
}

// DownloadWorker methods

// start starts the download worker
func (w *DownloadWorker) start() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-w.stopCh:<span class="cov0" title="0">
                        return</span>
                case req := &lt;-w.manager.downloadQueue:<span class="cov0" title="0">
                        w.processDownload(req)</span>
                }
        }
}

// processDownload processes a download request
func (w *DownloadWorker) processDownload(req *DownloadRequest) <span class="cov0" title="0">{
        start := time.Now()
        
        // Create transfer entry
        transferID := fmt.Sprintf("download_%s_%d", req.ModelName, time.Now().UnixNano())
        ctx, cancel := context.WithCancel(w.manager.ctx)
        
        transfer := &amp;Transfer{
                ID:        transferID,
                ModelName: req.ModelName,
                Type:      TransferTypeDownload,
                Status:    TransferStatusPending,
                Progress:  0,
                PeerID:    req.PeerID,
                StartedAt: start,
                ctx:       ctx,
                cancel:    cancel,
        }
        
        w.manager.transfersMu.Lock()
        w.manager.transfers[transferID] = transfer
        w.manager.transfersMu.Unlock()
        
        // TODO: Implement actual download from peer
        // For now, simulate download
        model, err := w.simulateDownload(transfer)
        
        response := &amp;DownloadResponse{
                Success:  err == nil,
                Model:    model,
                Duration: time.Since(start),
        }
        
        if err != nil </span><span class="cov0" title="0">{
                response.Error = err.Error()
                transfer.Status = TransferStatusFailed
                transfer.Error = err.Error()
        }</span> else<span class="cov0" title="0"> {
                transfer.Status = TransferStatusCompleted
        }</span>
        
        <span class="cov0" title="0">transfer.CompletedAt = time.Now()
        
        select </span>{
        case req.ResponseCh &lt;- response:<span class="cov0" title="0"></span>
        case &lt;-time.After(5 * time.Second):<span class="cov0" title="0"></span>
                // Response channel blocked
        }
}

// simulateDownload simulates downloading a model
func (w *DownloadWorker) simulateDownload(transfer *Transfer) (*Model, error) <span class="cov0" title="0">{
        // Update transfer status
        transfer.Status = TransferStatusActive
        transfer.BytesTotal = 1024 * 1024 * 100 // 100MB
        
        // Simulate download progress
        for i := 0; i &lt; 10; i++ </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-transfer.ctx.Done():<span class="cov0" title="0">
                        return nil, fmt.Errorf("download cancelled")</span>
                default:<span class="cov0" title="0"></span>
                }
                
                <span class="cov0" title="0">transfer.BytesDone = int64(i+1) * (transfer.BytesTotal / 10)
                transfer.Progress = float64(transfer.BytesDone) / float64(transfer.BytesTotal) * 100
                
                time.Sleep(100 * time.Millisecond)</span>
        }
        
        // Create model file path
        <span class="cov0" title="0">modelPath := filepath.Join(w.manager.config.ModelDir, transfer.ModelName+".gguf")
        
        // Create dummy model file
        file, err := os.Create(modelPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create model file: %w", err)
        }</span>
        
        // Write some dummy data
        <span class="cov0" title="0">if _, err := file.WriteString("dummy model data"); err != nil </span><span class="cov0" title="0">{
                file.Close()
                return nil, fmt.Errorf("failed to write model file: %w", err)
        }</span>
        <span class="cov0" title="0">file.Close()
        
        // Calculate checksum
        checksum, err := w.manager.calculateChecksum(modelPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to calculate checksum: %w", err)
        }</span>
        
        // Create model entry
        <span class="cov0" title="0">model := &amp;Model{
                Name:         transfer.ModelName,
                Version:      "1.0.0",
                Size:         transfer.BytesTotal,
                Checksum:     checksum,
                Path:         modelPath,
                Status:       ModelStatusAvailable,
                Replicas:     []string{w.manager.p2p.ID().String()},
                Metadata:     make(map[string]string),
                CreatedAt:    time.Now(),
                UpdatedAt:    time.Now(),
                AccessCount:  0,
                LastAccessed: time.Now(),
        }
        
        // Store model
        w.manager.modelsMu.Lock()
        w.manager.models[transfer.ModelName] = model
        w.manager.modelsMu.Unlock()
        
        return model, nil</span>
}

// UploadWorker methods

// start starts the upload worker
func (w *UploadWorker) start() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-w.stopCh:<span class="cov0" title="0">
                        return</span>
                case req := &lt;-w.manager.uploadQueue:<span class="cov0" title="0">
                        w.processUpload(req)</span>
                }
        }
}

// processUpload processes an upload request
func (w *UploadWorker) processUpload(req *UploadRequest) <span class="cov0" title="0">{
        start := time.Now()
        
        // TODO: Implement actual upload to peer
        // For now, simulate upload
        err := w.simulateUpload(req)
        
        response := &amp;UploadResponse{
                Success:  err == nil,
                Duration: time.Since(start),
        }
        
        if err != nil </span><span class="cov0" title="0">{
                response.Error = err.Error()
        }</span>
        
        <span class="cov0" title="0">select </span>{
        case req.ResponseCh &lt;- response:<span class="cov0" title="0"></span>
        case &lt;-time.After(5 * time.Second):<span class="cov0" title="0"></span>
                // Response channel blocked
        }
}

// simulateUpload simulates uploading a model
func (w *UploadWorker) simulateUpload(req *UploadRequest) error <span class="cov0" title="0">{
        // Check if model exists
        model, exists := w.manager.GetModel(req.ModelName)
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("model %s not found", req.ModelName)
        }</span>
        
        // Simulate upload time
        <span class="cov0" title="0">time.Sleep(time.Duration(model.Size/1024/1024) * time.Millisecond)
        
        return nil</span>
}

// ShouldDistribute determines if a model should be distributed
func (m *Manager) ShouldDistribute(modelName string) bool <span class="cov0" title="0">{
        // Check if model exists and is suitable for distribution
        _, exists := m.GetModel(modelName)
        return exists
}</span>

// IsDistributed checks if a model is already distributed
func (m *Manager) IsDistributed(modelName string) bool <span class="cov0" title="0">{
        // Check if model exists in the distributed network
        _, exists := m.GetModel(modelName)
        return exists
}</span>

// GetModelInfo returns information about a model
func (m *Manager) GetModelInfo(modelName string) map[string]interface{} <span class="cov0" title="0">{
        if model, exists := m.GetModel(modelName); exists </span><span class="cov0" title="0">{
                return map[string]interface{}{
                        "name":     model.Name,
                        "version":  model.Version,
                        "size":     model.Size,
                        "checksum": model.Checksum,
                        "path":     model.Path,
                        "created":  model.CreatedAt,
                        "accessed": model.LastAccessed,
                }
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetDistributedModels returns all distributed models as API responses
func (m *Manager) GetDistributedModels() []interface{} <span class="cov0" title="0">{
        m.modelsMu.RLock()
        defer m.modelsMu.RUnlock()
        
        var models []interface{}
        for _, model := range m.models </span><span class="cov0" title="0">{
                models = append(models, map[string]interface{}{
                        "name":     model.Name,
                        "version":  model.Version,
                        "size":     model.Size,
                        "checksum": model.Checksum,
                        "path":     model.Path,
                        "created":  model.CreatedAt,
                        "accessed": model.LastAccessed,
                })
        }</span>
        <span class="cov0" title="0">return models</span>
}

// DeleteModel deletes a model from the distributed system
func (m *Manager) DeleteModel(modelName string) error <span class="cov0" title="0">{
        m.modelsMu.Lock()
        defer m.modelsMu.Unlock()
        
        if _, exists := m.models[modelName]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("model %s not found", modelName)
        }</span>
        
        <span class="cov0" title="0">delete(m.models, modelName)
        return nil</span>
}

// GetDistributedModelCount returns the count of distributed models
func (m *Manager) GetDistributedModelCount() int <span class="cov0" title="0">{
        m.modelsMu.RLock()
        defer m.modelsMu.RUnlock()
        return len(m.models)
}</span>

// DownloadFromPeer downloads a model from a peer
func (m *Manager) DownloadFromPeer(modelName, peerID string) error <span class="cov0" title="0">{
        // This is a wrapper around the existing DownloadModel method
        _, err := m.DownloadModel(modelName, peerID)
        return err
}</span>

// RegisterModel registers a model in the distributed system
func (m *Manager) RegisterModel(modelName, modelPath string) error <span class="cov0" title="0">{
        return m.registerLocalModel(modelPath)
}</span>

// Rebalance rebalances models across the distributed network
func (m *Manager) Rebalance() error <span class="cov0" title="0">{
        // Stub implementation for rebalancing logic
        return nil
}</span>

// MigrateModel migrates a model to a different node
func (m *Manager) MigrateModel(modelName, targetNodeID string) error <span class="cov0" title="0">{
        // Stub implementation for model migration
        return nil
}</span>

// GetStats returns statistics about the distributed system
func (m *Manager) GetStats() map[string]interface{} <span class="cov0" title="0">{
        m.modelsMu.RLock()
        defer m.modelsMu.RUnlock()
        
        return map[string]interface{}{
                "total_models": len(m.models),
                "total_transfers": len(m.transfers),
                "active_downloads": len(m.downloadQueue),
                "active_uploads": len(m.uploadQueue),
        }
}</span>

// ForceRebalance forces a rebalancing operation
func (m *Manager) ForceRebalance() error <span class="cov0" title="0">{
        // Stub implementation for forced rebalancing
        return m.Rebalance()
}</span>

// GetTotalModels returns the total number of models in the system
func (m *Manager) GetTotalModels() int <span class="cov0" title="0">{
        return m.GetDistributedModelCount()
}</pre>
		
		<pre class="file" id="file15" style="display: none">package models

import (
        "context"
        "fmt"
        "io"
        "log/slog"
        "path/filepath"
        "sync"
        "time"

        "github.com/ollama/ollama/api"
        "github.com/ollama/ollama/types/model"
)

// OllamaIntegration provides integration with Ollama's existing model management
type OllamaIntegration struct {
        distributedManager *DistributedModelManager
        logger             *slog.Logger
        
        // Ollama server integration
        modelHooks    map[string][]ModelHook
        hooksMutex    sync.RWMutex
        
        // Model interception
        interceptor   *ModelInterceptor
        
        // Compatibility layer
        compatibility *CompatibilityLayer
}

// ModelHook represents a hook for model operations
type ModelHook func(operation string, modelName string, data map[string]interface{}) error

// ModelInterceptor intercepts Ollama model operations
type ModelInterceptor struct {
        integration *OllamaIntegration
        
        // Operation tracking
        operations    map[string]*ModelOperation
        operationsMutex sync.RWMutex
}

// ModelOperation represents an intercepted model operation
type ModelOperation struct {
        ID        string                 `json:"id"`
        Type      string                 `json:"type"`
        ModelName string                 `json:"model_name"`
        Status    string                 `json:"status"`
        StartTime time.Time              `json:"start_time"`
        EndTime   time.Time              `json:"end_time"`
        Metadata  map[string]interface{} `json:"metadata"`
        Error     string                 `json:"error,omitempty"`
}

// CompatibilityLayer provides compatibility with existing Ollama APIs
type CompatibilityLayer struct {
        integration *OllamaIntegration
        
        // API translation
        apiTranslator *APITranslator
        
        // Legacy support
        legacySupport *LegacySupport
}

// APITranslator translates between Ollama APIs and distributed APIs
type APITranslator struct {
        // Request/response mapping
        requestMappings  map[string]RequestMapping
        responseMappings map[string]ResponseMapping
}

// RequestMapping maps Ollama requests to distributed requests
type RequestMapping struct {
        SourceType   string                 `json:"source_type"`
        TargetType   string                 `json:"target_type"`
        FieldMapping map[string]string      `json:"field_mapping"`
        Transform    func(interface{}) interface{} `json:"-"`
}

// ResponseMapping maps distributed responses to Ollama responses
type ResponseMapping struct {
        SourceType   string                 `json:"source_type"`
        TargetType   string                 `json:"target_type"`
        FieldMapping map[string]string      `json:"field_mapping"`
        Transform    func(interface{}) interface{} `json:"-"`
}

// LegacySupport provides support for legacy Ollama functionality
type LegacySupport struct {
        // Legacy model paths
        legacyPaths map[string]string
        pathsMutex  sync.RWMutex
        
        // Legacy metadata
        legacyMetadata map[string]map[string]interface{}
        metadataMutex  sync.RWMutex
}

// NewOllamaIntegration creates a new Ollama integration
func NewOllamaIntegration(distributedManager *DistributedModelManager, logger *slog.Logger) *OllamaIntegration <span class="cov0" title="0">{
        integration := &amp;OllamaIntegration{
                distributedManager: distributedManager,
                logger:             logger,
                modelHooks:         make(map[string][]ModelHook),
        }
        
        // Initialize interceptor
        integration.interceptor = &amp;ModelInterceptor{
                integration: integration,
                operations:  make(map[string]*ModelOperation),
        }
        
        // Initialize compatibility layer
        integration.compatibility = &amp;CompatibilityLayer{
                integration: integration,
                apiTranslator: &amp;APITranslator{
                        requestMappings:  make(map[string]RequestMapping),
                        responseMappings: make(map[string]ResponseMapping),
                },
                legacySupport: &amp;LegacySupport{
                        legacyPaths:    make(map[string]string),
                        legacyMetadata: make(map[string]map[string]interface{}),
                },
        }
        
        // Setup API mappings
        integration.setupAPIMappings()
        
        return integration
}</span>

// setupAPIMappings sets up API mappings between Ollama and distributed APIs
func (oi *OllamaIntegration) setupAPIMappings() <span class="cov0" title="0">{
        // Map Ollama model requests to distributed model requests
        oi.compatibility.apiTranslator.requestMappings["model.Name"] = RequestMapping{
                SourceType: "model.Name",
                TargetType: "DistributedModel",
                FieldMapping: map[string]string{
                        "name":    "Name",
                        "tag":     "Version",
                        "digest":  "Hash",
                },
                Transform: func(src interface{}) interface{} </span><span class="cov0" title="0">{
                        if name, ok := src.(model.Name); ok </span><span class="cov0" title="0">{
                                return &amp;DistributedModel{
                                        Name:    name.String(),
                                        Version: name.Tag,
                                        Hash:    "", // Note: model.Name doesn't have Digest field
                                }
                        }</span>
                        <span class="cov0" title="0">return src</span>
                },
        }
        
        // Map distributed model responses to Ollama responses
        <span class="cov0" title="0">oi.compatibility.apiTranslator.responseMappings["DistributedModel"] = ResponseMapping{
                SourceType: "DistributedModel",
                TargetType: "api.ListModelResponse",
                FieldMapping: map[string]string{
                        "Name":      "name",
                        "Version":   "model",
                        "Hash":      "digest",
                        "Size":      "size",
                        "CreatedAt": "created_at",
                        "UpdatedAt": "modified_at",
                },
                Transform: func(src interface{}) interface{} </span><span class="cov0" title="0">{
                        if dm, ok := src.(*DistributedModel); ok </span><span class="cov0" title="0">{
                                return &amp;api.ListModelResponse{
                                        Name:       dm.Name,
                                        Model:      dm.Name,
                                        Size:       dm.Size,
                                        Digest:     dm.Hash,
                                        ModifiedAt: dm.UpdatedAt,
                                }
                        }</span>
                        <span class="cov0" title="0">return src</span>
                },
        }
}

// InterceptModelPull intercepts Ollama model pull operations
func (oi *OllamaIntegration) InterceptModelPull(ctx context.Context, name model.Name, fn func(api.ProgressResponse)) error <span class="cov0" title="0">{
        oi.logger.Info("intercepting model pull", "model", name.String())
        
        // Create operation record
        op := &amp;ModelOperation{
                ID:        fmt.Sprintf("pull_%s_%d", name.String(), time.Now().UnixNano()),
                Type:      "pull",
                ModelName: name.String(),
                Status:    "starting",
                StartTime: time.Now(),
                Metadata:  make(map[string]interface{}),
        }
        
        oi.interceptor.operationsMutex.Lock()
        oi.interceptor.operations[op.ID] = op
        oi.interceptor.operationsMutex.Unlock()
        
        // Execute pre-pull hooks
        if err := oi.executeHooks("pre-pull", name.String(), map[string]interface{}{
                "operation_id": op.ID,
                "model_name":   name.String(),
        }); err != nil </span><span class="cov0" title="0">{
                op.Status = "failed"
                op.Error = err.Error()
                op.EndTime = time.Now()
                return fmt.Errorf("pre-pull hook failed: %w", err)
        }</span>
        
        // Check if model exists in distributed system
        <span class="cov0" title="0">if distributedModel, err := oi.distributedManager.GetModel(name.String()); err == nil </span><span class="cov0" title="0">{
                oi.logger.Info("model found in distributed system", "model", name.String())
                
                // Report progress
                if fn != nil </span><span class="cov0" title="0">{
                        fn(api.ProgressResponse{
                                Status:    "pulling model",
                                Digest:    distributedModel.Hash,
                                Total:     distributedModel.Size,
                                Completed: 0,
                        })
                }</span>
                
                // Simulate download progress
                <span class="cov0" title="0">chunkSize := distributedModel.Size / 10
                for i := int64(0); i &lt; 10; i++ </span><span class="cov0" title="0">{
                        if fn != nil </span><span class="cov0" title="0">{
                                fn(api.ProgressResponse{
                                        Status:    "downloading",
                                        Digest:    distributedModel.Hash,
                                        Total:     distributedModel.Size,
                                        Completed: (i + 1) * chunkSize,
                                })
                        }</span>
                        <span class="cov0" title="0">time.Sleep(100 * time.Millisecond)</span>
                }
                
                <span class="cov0" title="0">if fn != nil </span><span class="cov0" title="0">{
                        fn(api.ProgressResponse{
                                Status:    "verifying sha256 digest",
                                Digest:    distributedModel.Hash,
                                Total:     distributedModel.Size,
                                Completed: distributedModel.Size,
                        })
                }</span>
                
                <span class="cov0" title="0">op.Status = "completed"
                op.EndTime = time.Now()
                
                // Execute post-pull hooks
                oi.executeHooks("post-pull", name.String(), map[string]interface{}{
                        "operation_id": op.ID,
                        "model_name":   name.String(),
                        "success":      true,
                })
                
                return nil</span>
        }
        
        // Model not found in distributed system, fall back to original pull
        <span class="cov0" title="0">oi.logger.Info("model not found in distributed system, falling back to original pull", "model", name.String())
        
        // Use original Ollama pull mechanism
        // Note: server.PullModel and server.RegistryOptions are not available in current API
        // Creating compatibility stub
        if err := oi.fallbackPullModel(ctx, name.String(), fn); err != nil </span><span class="cov0" title="0">{
                op.Status = "failed"
                op.Error = err.Error()
                op.EndTime = time.Now()
                
                // Execute post-pull hooks
                oi.executeHooks("post-pull", name.String(), map[string]interface{}{
                        "operation_id": op.ID,
                        "model_name":   name.String(),
                        "success":      false,
                        "error":        err.Error(),
                })
                
                return err
        }</span>
        
        // Add pulled model to distributed system
        <span class="cov0" title="0">if err := oi.addPulledModelToDistributedSystem(name.String()); err != nil </span><span class="cov0" title="0">{
                oi.logger.Error("failed to add pulled model to distributed system", "model", name.String(), "error", err)
        }</span>
        
        <span class="cov0" title="0">op.Status = "completed"
        op.EndTime = time.Now()
        
        // Execute post-pull hooks
        oi.executeHooks("post-pull", name.String(), map[string]interface{}{
                "operation_id": op.ID,
                "model_name":   name.String(),
                "success":      true,
        })
        
        return nil</span>
}

// InterceptModelList intercepts Ollama model list operations
func (oi *OllamaIntegration) InterceptModelList() ([]api.ListModelResponse, error) <span class="cov0" title="0">{
        oi.logger.Info("intercepting model list")
        
        // Get distributed models
        distributedModels := oi.distributedManager.GetDistributedModels()
        
        // Convert to Ollama API responses
        var responses []api.ListModelResponse
        for _, dm := range distributedModels </span><span class="cov0" title="0">{
                response := api.ListModelResponse{
                        Name:       dm.Name,
                        Model:      dm.Name,
                        Size:       dm.Size,
                        Digest:     dm.Hash,
                        ModifiedAt: dm.UpdatedAt,
                }
                responses = append(responses, response)
        }</span>
        
        // Also get local models that might not be in distributed system
        <span class="cov0" title="0">localModels, err := oi.getLocalModels()
        if err != nil </span><span class="cov0" title="0">{
                oi.logger.Error("failed to get local models", "error", err)
        }</span> else<span class="cov0" title="0"> {
                // Merge local models that aren't already in distributed system
                for _, local := range localModels </span><span class="cov0" title="0">{
                        found := false
                        for _, distributed := range responses </span><span class="cov0" title="0">{
                                if distributed.Name == local.Name </span><span class="cov0" title="0">{
                                        found = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                responses = append(responses, local)
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return responses, nil</span>
}

// InterceptModelShow intercepts Ollama model show operations
func (oi *OllamaIntegration) InterceptModelShow(name model.Name) (*api.ShowResponse, error) <span class="cov0" title="0">{
        oi.logger.Info("intercepting model show", "model", name.String())
        
        // Try to get from distributed system first
        if distributedModel, err := oi.distributedManager.GetModel(name.String()); err == nil </span><span class="cov0" title="0">{
                // Create ModelInfo from map[string]interface{}
                modelInfo := map[string]interface{}{
                        "name":        distributedModel.Name,
                        "size":        distributedModel.Size,
                        "digest":      distributedModel.Hash,
                        "created_at":  distributedModel.CreatedAt,
                        "modified_at": distributedModel.UpdatedAt,
                }
                
                return &amp;api.ShowResponse{
                        ModelInfo: modelInfo,
                        Details: api.ModelDetails{
                                Format:   "gguf",
                                Family:   "llama",
                                Families: []string{"llama"},
                        },
                }, nil
        }</span>
        
        // Fall back to original show
        <span class="cov0" title="0">return oi.getOriginalModelShow(name)</span>
}

// InterceptModelDelete intercepts Ollama model delete operations
func (oi *OllamaIntegration) InterceptModelDelete(name model.Name) error <span class="cov0" title="0">{
        oi.logger.Info("intercepting model delete", "model", name.String())
        
        // Execute pre-delete hooks
        if err := oi.executeHooks("pre-delete", name.String(), map[string]interface{}{
                "model_name": name.String(),
        }); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("pre-delete hook failed: %w", err)
        }</span>
        
        // Remove from distributed system
        <span class="cov0" title="0">if err := oi.removeFromDistributedSystem(name.String()); err != nil </span><span class="cov0" title="0">{
                oi.logger.Error("failed to remove from distributed system", "model", name.String(), "error", err)
        }</span>
        
        // Execute original delete
        <span class="cov0" title="0">if err := oi.executeOriginalDelete(name); err != nil </span><span class="cov0" title="0">{
                // Execute post-delete hooks
                oi.executeHooks("post-delete", name.String(), map[string]interface{}{
                        "model_name": name.String(),
                        "success":    false,
                        "error":      err.Error(),
                })
                return err
        }</span>
        
        // Execute post-delete hooks
        <span class="cov0" title="0">oi.executeHooks("post-delete", name.String(), map[string]interface{}{
                "model_name": name.String(),
                "success":    true,
        })
        
        return nil</span>
}

// AddModelHook adds a hook for model operations
func (oi *OllamaIntegration) AddModelHook(operation string, hook ModelHook) <span class="cov0" title="0">{
        oi.hooksMutex.Lock()
        defer oi.hooksMutex.Unlock()
        
        oi.modelHooks[operation] = append(oi.modelHooks[operation], hook)
}</span>

// executeHooks executes hooks for a given operation
func (oi *OllamaIntegration) executeHooks(operation string, modelName string, data map[string]interface{}) error <span class="cov0" title="0">{
        oi.hooksMutex.RLock()
        hooks := oi.modelHooks[operation]
        oi.hooksMutex.RUnlock()
        
        for _, hook := range hooks </span><span class="cov0" title="0">{
                if err := hook(operation, modelName, data); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// addPulledModelToDistributedSystem adds a pulled model to the distributed system
func (oi *OllamaIntegration) addPulledModelToDistributedSystem(modelName string) error <span class="cov0" title="0">{
        // Get model path from Ollama
        modelPath, err := oi.getModelPath(modelName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get model path: %w", err)
        }</span>
        
        // Add to distributed system
        <span class="cov0" title="0">_, err = oi.distributedManager.AddModel(modelName, modelPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add model to distributed system: %w", err)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// getModelPath gets the local path for a model
func (oi *OllamaIntegration) getModelPath(modelName string) (string, error) <span class="cov0" title="0">{
        // This would need to integrate with Ollama's model path resolution
        // For now, return a placeholder path
        return filepath.Join("/tmp/models", modelName+".gguf"), nil
}</span>

// getLocalModels gets models from local Ollama installation
func (oi *OllamaIntegration) getLocalModels() ([]api.ListModelResponse, error) <span class="cov0" title="0">{
        // This would need to integrate with Ollama's model listing
        // For now, return empty list
        return []api.ListModelResponse{}, nil
}</span>

// getOriginalModelShow gets model show from original Ollama
func (oi *OllamaIntegration) getOriginalModelShow(name model.Name) (*api.ShowResponse, error) <span class="cov0" title="0">{
        // This would need to integrate with Ollama's model show
        // For now, return a placeholder response
        return &amp;api.ShowResponse{
                ModelInfo: map[string]interface{}{
                        "name":   name.String(),
                        "size":   int64(0),
                        "digest": "",
                },
                Details: api.ModelDetails{
                        Format:   "gguf",
                        Family:   "llama",
                        Families: []string{"llama"},
                },
        }, nil
}</span>

// executeOriginalDelete executes the original model delete
func (oi *OllamaIntegration) executeOriginalDelete(name model.Name) error <span class="cov0" title="0">{
        // This would need to integrate with Ollama's model deletion
        // For now, return success
        return nil
}</span>

// removeFromDistributedSystem removes a model from the distributed system
func (oi *OllamaIntegration) removeFromDistributedSystem(modelName string) error <span class="cov0" title="0">{
        // This would need to be implemented in the distributed manager
        // For now, just log the operation
        oi.logger.Info("removing model from distributed system", "model", modelName)
        return nil
}</span>

// fallbackPullModel provides a fallback implementation for pulling models
// since server.PullModel is not available in the current Ollama API
func (oi *OllamaIntegration) fallbackPullModel(ctx context.Context, modelName string, fn func(api.ProgressResponse)) error <span class="cov0" title="0">{
        oi.logger.Info("fallback pull model implementation", "model", modelName)
        
        // Simulate progress reporting
        if fn != nil </span><span class="cov0" title="0">{
                fn(api.ProgressResponse{
                        Status: "pulling model",
                        Total:  100,
                        Completed: 0,
                })
                
                // Simulate download progress
                for i := 0; i &lt;= 100; i += 10 </span><span class="cov0" title="0">{
                        fn(api.ProgressResponse{
                                Status: "downloading",
                                Total:  100,
                                Completed: int64(i),
                        })
                }</span>
                
                <span class="cov0" title="0">fn(api.ProgressResponse{
                        Status: "verifying sha256 digest",
                        Total:  100,
                        Completed: 100,
                })</span>
        }
        
        // TODO: Implement actual model pulling logic
        // This is a stub implementation
        <span class="cov0" title="0">return nil</span>
}

// GetOperationStatus returns the status of a model operation
func (oi *OllamaIntegration) GetOperationStatus(operationID string) (*ModelOperation, bool) <span class="cov0" title="0">{
        oi.interceptor.operationsMutex.RLock()
        defer oi.interceptor.operationsMutex.RUnlock()
        
        op, exists := oi.interceptor.operations[operationID]
        return op, exists
}</span>

// GetAllOperations returns all model operations
func (oi *OllamaIntegration) GetAllOperations() []*ModelOperation <span class="cov0" title="0">{
        oi.interceptor.operationsMutex.RLock()
        defer oi.interceptor.operationsMutex.RUnlock()
        
        operations := make([]*ModelOperation, 0, len(oi.interceptor.operations))
        for _, op := range oi.interceptor.operations </span><span class="cov0" title="0">{
                operations = append(operations, op)
        }</span>
        
        <span class="cov0" title="0">return operations</span>
}

// CreateFromModelfile creates a model from a Modelfile with distributed support
func (oi *OllamaIntegration) CreateFromModelfile(ctx context.Context, name model.Name, modelfile io.Reader, fn func(api.ProgressResponse)) error <span class="cov0" title="0">{
        oi.logger.Info("creating model from Modelfile with distributed support", "model", name.String())
        
        // Create operation record
        op := &amp;ModelOperation{
                ID:        fmt.Sprintf("create_%s_%d", name.String(), time.Now().UnixNano()),
                Type:      "create",
                ModelName: name.String(),
                Status:    "starting",
                StartTime: time.Now(),
                Metadata:  make(map[string]interface{}),
        }
        
        oi.interceptor.operationsMutex.Lock()
        oi.interceptor.operations[op.ID] = op
        oi.interceptor.operationsMutex.Unlock()
        
        // Execute pre-create hooks
        if err := oi.executeHooks("pre-create", name.String(), map[string]interface{}{
                "operation_id": op.ID,
                "model_name":   name.String(),
        }); err != nil </span><span class="cov0" title="0">{
                op.Status = "failed"
                op.Error = err.Error()
                op.EndTime = time.Now()
                return fmt.Errorf("pre-create hook failed: %w", err)
        }</span>
        
        // TODO: Implement actual model creation with distributed support
        // This would involve:
        // 1. Processing the Modelfile
        // 2. Creating the model locally
        // 3. Adding to distributed system
        // 4. Setting up replication
        
        // For now, simulate creation
        <span class="cov0" title="0">time.Sleep(1 * time.Second)
        
        op.Status = "completed"
        op.EndTime = time.Now()
        
        // Execute post-create hooks
        oi.executeHooks("post-create", name.String(), map[string]interface{}{
                "operation_id": op.ID,
                "model_name":   name.String(),
                "success":      true,
        })
        
        return nil</span>
}

// SetupDefaultHooks sets up default hooks for common operations
func (oi *OllamaIntegration) SetupDefaultHooks() <span class="cov0" title="0">{
        // Pre-pull hook to check distributed availability
        oi.AddModelHook("pre-pull", func(operation string, modelName string, data map[string]interface{}) error </span><span class="cov0" title="0">{
                oi.logger.Info("pre-pull hook: checking distributed availability", "model", modelName)
                return nil
        }</span>)
        
        // Post-pull hook to add to distributed system
        <span class="cov0" title="0">oi.AddModelHook("post-pull", func(operation string, modelName string, data map[string]interface{}) error </span><span class="cov0" title="0">{
                if success, ok := data["success"].(bool); ok &amp;&amp; success </span><span class="cov0" title="0">{
                        oi.logger.Info("post-pull hook: adding to distributed system", "model", modelName)
                        // Add to distributed system
                        if err := oi.addPulledModelToDistributedSystem(modelName); err != nil </span><span class="cov0" title="0">{
                                oi.logger.Error("failed to add pulled model to distributed system", "model", modelName, "error", err)
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        })
        
        // Pre-delete hook to check replication requirements
        <span class="cov0" title="0">oi.AddModelHook("pre-delete", func(operation string, modelName string, data map[string]interface{}) error </span><span class="cov0" title="0">{
                oi.logger.Info("pre-delete hook: checking replication requirements", "model", modelName)
                
                // Check if this is the last replica
                if dm, err := oi.distributedManager.GetModel(modelName); err == nil </span><span class="cov0" title="0">{
                        if len(dm.Replicas) &lt;= 1 </span><span class="cov0" title="0">{
                                oi.logger.Warn("deleting last replica of model", "model", modelName)
                                // Could add confirmation logic here
                        }</span>
                }
                
                <span class="cov0" title="0">return nil</span>
        })
        
        // Post-delete hook to update distributed system
        <span class="cov0" title="0">oi.AddModelHook("post-delete", func(operation string, modelName string, data map[string]interface{}) error </span><span class="cov0" title="0">{
                if success, ok := data["success"].(bool); ok &amp;&amp; success </span><span class="cov0" title="0">{
                        oi.logger.Info("post-delete hook: updating distributed system", "model", modelName)
                        // Update distributed system
                        if err := oi.removeFromDistributedSystem(modelName); err != nil </span><span class="cov0" title="0">{
                                oi.logger.Error("failed to remove from distributed system", "model", modelName, "error", err)
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        })
}</pre>
		
		<pre class="file" id="file16" style="display: none">package models

import (
        "context"
        "fmt"
        "log/slog"
        "sync"
        "time"

        "github.com/ollama/ollama-distributed/internal/config"
        "github.com/ollama/ollama-distributed/pkg/p2p"
)

// ReplicationManager manages model replication across peers
type ReplicationManager struct {
        config     *config.ReplicationConfig
        p2p        *p2p.Node
        manager    *Manager
        syncMgr    *SyncManager
        logger     *slog.Logger
        
        // Replication state
        replicas      map[string]*ReplicaInfo
        replicasMutex sync.RWMutex
        
        // Replication policies
        policies      map[string]*ReplicationPolicy
        policiesMutex sync.RWMutex
        
        // Replication workers
        workers     []*ReplicationWorker
        workQueue   chan *ReplicationTask
        
        // Health monitoring
        healthChecker *HealthChecker
        
        ctx     context.Context
        cancel  context.CancelFunc
        started bool
        mu      sync.RWMutex
}

// ReplicaInfo contains information about a model replica
type ReplicaInfo struct {
        ModelName    string            `json:"model_name"`
        PeerID       string            `json:"peer_id"`
        Status       ReplicaStatus     `json:"status"`
        LastSync     time.Time         `json:"last_sync"`
        SyncAttempts int               `json:"sync_attempts"`
        Health       ReplicaHealth     `json:"health"`
        Metadata     map[string]string `json:"metadata"`
        CreatedAt    time.Time         `json:"created_at"`
        UpdatedAt    time.Time         `json:"updated_at"`
}

// ReplicaStatus represents the status of a replica
type ReplicaStatus string

const (
        ReplicaStatusHealthy     ReplicaStatus = "healthy"
        ReplicaStatusSyncing     ReplicaStatus = "syncing"
        ReplicaStatusOutOfSync   ReplicaStatus = "out_of_sync"
        ReplicaStatusUnhealthy   ReplicaStatus = "unhealthy"
        ReplicaStatusUnreachable ReplicaStatus = "unreachable"
)

// ReplicaHealth represents the health status of a replica
type ReplicaHealth string

const (
        HealthGood    ReplicaHealth = "good"
        HealthWarning ReplicaHealth = "warning"
        HealthError   ReplicaHealth = "error"
)

// ReplicationPolicy defines how a model should be replicated
type ReplicationPolicy struct {
        ModelName         string            `json:"model_name"`
        MinReplicas       int               `json:"min_replicas"`
        MaxReplicas       int               `json:"max_replicas"`
        PreferredPeers    []string          `json:"preferred_peers"`
        ExcludedPeers     []string          `json:"excluded_peers"`
        ReplicationFactor int               `json:"replication_factor"`
        SyncInterval      time.Duration     `json:"sync_interval"`
        Priority          int               `json:"priority"`
        Constraints       map[string]string `json:"constraints"`
        CreatedAt         time.Time         `json:"created_at"`
        UpdatedAt         time.Time         `json:"updated_at"`
}

// ReplicationTask represents a replication task
type ReplicationTask struct {
        Type         TaskType    `json:"type"`
        ModelName    string      `json:"model_name"`
        SourcePeer   string      `json:"source_peer"`
        TargetPeer   string      `json:"target_peer"`
        Priority     int         `json:"priority"`
        Retries      int         `json:"retries"`
        MaxRetries   int         `json:"max_retries"`
        CreatedAt    time.Time   `json:"created_at"`
        ResponseChan chan error  `json:"-"`
}

// TaskType represents the type of replication task
type TaskType string

const (
        TaskTypeReplicate TaskType = "replicate"
        TaskTypeSync      TaskType = "sync"
        TaskTypeRemove    TaskType = "remove"
        TaskTypeVerify    TaskType = "verify"
)

// ReplicationWorker handles replication tasks
type ReplicationWorker struct {
        ID         int
        manager    *ReplicationManager
        stopChan   chan struct{}
}

// HealthChecker monitors replica health
type HealthChecker struct {
        manager       *ReplicationManager
        checkInterval time.Duration
        timeout       time.Duration
        stopChan      chan struct{}
}

// NewReplicationManager creates a new replication manager
func NewReplicationManager(
        config *config.ReplicationConfig,
        p2pNode *p2p.Node,
        manager *Manager,
        syncMgr *SyncManager,
        logger *slog.Logger,
) (*ReplicationManager, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())
        
        rm := &amp;ReplicationManager{
                config:    config,
                p2p:       p2pNode,
                manager:   manager,
                syncMgr:   syncMgr,
                logger:    logger,
                replicas:  make(map[string]*ReplicaInfo),
                policies:  make(map[string]*ReplicationPolicy),
                workQueue: make(chan *ReplicationTask, 100),
                ctx:       ctx,
                cancel:    cancel,
        }
        
        // Create workers
        rm.workers = make([]*ReplicationWorker, config.WorkerCount)
        for i := 0; i &lt; config.WorkerCount; i++ </span><span class="cov0" title="0">{
                rm.workers[i] = &amp;ReplicationWorker{
                        ID:       i,
                        manager:  rm,
                        stopChan: make(chan struct{}),
                }
        }</span>
        
        // Create health checker
        <span class="cov0" title="0">rm.healthChecker = &amp;HealthChecker{
                manager:       rm,
                checkInterval: config.HealthCheckInterval,
                timeout:       config.HealthCheckTimeout,
                stopChan:      make(chan struct{}),
        }
        
        return rm, nil</span>
}

// Start starts the replication manager
func (rm *ReplicationManager) Start() error <span class="cov0" title="0">{
        rm.mu.Lock()
        defer rm.mu.Unlock()
        
        if rm.started </span><span class="cov0" title="0">{
                return fmt.Errorf("replication manager already started")
        }</span>
        
        // Load existing policies
        <span class="cov0" title="0">if err := rm.loadPolicies(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load policies: %w", err)
        }</span>
        
        // Start workers
        <span class="cov0" title="0">for _, worker := range rm.workers </span><span class="cov0" title="0">{
                go worker.start()
        }</span>
        
        // Start health checker
        <span class="cov0" title="0">go rm.healthChecker.start()
        
        // Start policy enforcement routine
        go rm.policyEnforcementRoutine()
        
        rm.started = true
        rm.logger.Info("replication manager started", "workers", len(rm.workers))
        
        return nil</span>
}

// SetReplicationPolicy sets a replication policy for a model
func (rm *ReplicationManager) SetReplicationPolicy(modelName string, policy *ReplicationPolicy) error <span class="cov0" title="0">{
        policy.ModelName = modelName
        policy.UpdatedAt = time.Now()
        if policy.CreatedAt.IsZero() </span><span class="cov0" title="0">{
                policy.CreatedAt = time.Now()
        }</span>
        
        <span class="cov0" title="0">rm.policiesMutex.Lock()
        rm.policies[modelName] = policy
        rm.policiesMutex.Unlock()
        
        // Trigger policy enforcement
        go rm.enforcePolicy(modelName)
        
        rm.logger.Info("replication policy set", "model", modelName, "min_replicas", policy.MinReplicas, "max_replicas", policy.MaxReplicas)
        
        return nil</span>
}

// GetReplicationPolicy gets the replication policy for a model
func (rm *ReplicationManager) GetReplicationPolicy(modelName string) (*ReplicationPolicy, bool) <span class="cov0" title="0">{
        rm.policiesMutex.RLock()
        defer rm.policiesMutex.RUnlock()
        
        policy, exists := rm.policies[modelName]
        return policy, exists
}</span>

// ReplicateModel replicates a model to a specific peer
func (rm *ReplicationManager) ReplicateModel(modelName, targetPeer string) error <span class="cov0" title="0">{
        task := &amp;ReplicationTask{
                Type:         TaskTypeReplicate,
                ModelName:    modelName,
                TargetPeer:   targetPeer,
                Priority:     1,
                MaxRetries:   3,
                CreatedAt:    time.Now(),
                ResponseChan: make(chan error, 1),
        }
        
        select </span>{
        case rm.workQueue &lt;- task:<span class="cov0" title="0"></span>
        case &lt;-time.After(5 * time.Second):<span class="cov0" title="0">
                return fmt.Errorf("replication queue full")</span>
        }
        
        <span class="cov0" title="0">select </span>{
        case err := &lt;-task.ResponseChan:<span class="cov0" title="0">
                return err</span>
        case &lt;-time.After(10 * time.Minute):<span class="cov0" title="0">
                return fmt.Errorf("replication timeout")</span>
        }
}

// GetReplicas returns all replicas for a model
func (rm *ReplicationManager) GetReplicas(modelName string) []*ReplicaInfo <span class="cov0" title="0">{
        rm.replicasMutex.RLock()
        defer rm.replicasMutex.RUnlock()
        
        var replicas []*ReplicaInfo
        for _, replica := range rm.replicas </span><span class="cov0" title="0">{
                if replica.ModelName == modelName </span><span class="cov0" title="0">{
                        replicas = append(replicas, replica)
                }</span>
        }
        
        <span class="cov0" title="0">return replicas</span>
}

// GetAllReplicas returns all replicas
func (rm *ReplicationManager) GetAllReplicas() []*ReplicaInfo <span class="cov0" title="0">{
        rm.replicasMutex.RLock()
        defer rm.replicasMutex.RUnlock()
        
        replicas := make([]*ReplicaInfo, 0, len(rm.replicas))
        for _, replica := range rm.replicas </span><span class="cov0" title="0">{
                replicas = append(replicas, replica)
        }</span>
        
        <span class="cov0" title="0">return replicas</span>
}

// enforcePolicy enforces the replication policy for a model
func (rm *ReplicationManager) enforcePolicy(modelName string) <span class="cov0" title="0">{
        policy, exists := rm.GetReplicationPolicy(modelName)
        if !exists </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov0" title="0">replicas := rm.GetReplicas(modelName)
        currentReplicas := len(replicas)
        
        rm.logger.Info("enforcing policy", "model", modelName, "current_replicas", currentReplicas, "min_replicas", policy.MinReplicas)
        
        if currentReplicas &lt; policy.MinReplicas </span><span class="cov0" title="0">{
                // Need to create more replicas
                needed := policy.MinReplicas - currentReplicas
                rm.logger.Info("need more replicas", "model", modelName, "needed", needed)
                
                // Find suitable peers
                peers := rm.findSuitablePeers(modelName, policy, needed)
                
                for _, peer := range peers </span><span class="cov0" title="0">{
                        task := &amp;ReplicationTask{
                                Type:         TaskTypeReplicate,
                                ModelName:    modelName,
                                TargetPeer:   peer,
                                Priority:     policy.Priority,
                                MaxRetries:   3,
                                CreatedAt:    time.Now(),
                                ResponseChan: make(chan error, 1),
                        }
                        
                        select </span>{
                        case rm.workQueue &lt;- task:<span class="cov0" title="0"></span>
                        default:<span class="cov0" title="0">
                                rm.logger.Error("replication queue full", "model", modelName, "peer", peer)</span>
                        }
                }
        } else<span class="cov0" title="0"> if currentReplicas &gt; policy.MaxReplicas </span><span class="cov0" title="0">{
                // Need to remove some replicas
                excess := currentReplicas - policy.MaxReplicas
                rm.logger.Info("need fewer replicas", "model", modelName, "excess", excess)
                
                // Find replicas to remove (prefer unhealthy ones)
                toRemove := rm.selectReplicasToRemove(modelName, excess)
                
                for _, replica := range toRemove </span><span class="cov0" title="0">{
                        task := &amp;ReplicationTask{
                                Type:         TaskTypeRemove,
                                ModelName:    modelName,
                                TargetPeer:   replica.PeerID,
                                Priority:     policy.Priority,
                                MaxRetries:   3,
                                CreatedAt:    time.Now(),
                                ResponseChan: make(chan error, 1),
                        }
                        
                        select </span>{
                        case rm.workQueue &lt;- task:<span class="cov0" title="0"></span>
                        default:<span class="cov0" title="0">
                                rm.logger.Error("replication queue full", "model", modelName, "peer", replica.PeerID)</span>
                        }
                }
        }
}

// findSuitablePeers finds suitable peers for replication
func (rm *ReplicationManager) findSuitablePeers(modelName string, policy *ReplicationPolicy, count int) []string <span class="cov0" title="0">{
        // Get all connected peers
        connectedPeerIDs := rm.p2p.GetConnectedPeers()
        var connectedPeers []string
        for _, peerID := range connectedPeerIDs </span><span class="cov0" title="0">{
                connectedPeers = append(connectedPeers, peerID.String())
        }</span>
        
        // Filter based on policy
        <span class="cov0" title="0">var suitable []string
        existing := make(map[string]bool)
        
        // Get existing replicas
        replicas := rm.GetReplicas(modelName)
        for _, replica := range replicas </span><span class="cov0" title="0">{
                existing[replica.PeerID] = true
        }</span>
        
        // Check preferred peers first
        <span class="cov0" title="0">for _, peer := range policy.PreferredPeers </span><span class="cov0" title="0">{
                if len(suitable) &gt;= count </span><span class="cov0" title="0">{
                        break</span>
                }
                
                <span class="cov0" title="0">if existing[peer] </span><span class="cov0" title="0">{
                        continue</span> // Already has replica
                }
                
                <span class="cov0" title="0">if rm.isPeerConnected(peer, connectedPeers) </span><span class="cov0" title="0">{
                        suitable = append(suitable, peer)
                }</span>
        }
        
        // Add other suitable peers if needed
        <span class="cov0" title="0">for _, peer := range connectedPeers </span><span class="cov0" title="0">{
                if len(suitable) &gt;= count </span><span class="cov0" title="0">{
                        break</span>
                }
                
                <span class="cov0" title="0">if existing[peer] </span><span class="cov0" title="0">{
                        continue</span> // Already has replica
                }
                
                <span class="cov0" title="0">if rm.isPeerExcluded(peer, policy.ExcludedPeers) </span><span class="cov0" title="0">{
                        continue</span> // Excluded
                }
                
                <span class="cov0" title="0">if rm.isPeerSuitable(peer, policy.Constraints) </span><span class="cov0" title="0">{
                        suitable = append(suitable, peer)
                }</span>
        }
        
        <span class="cov0" title="0">return suitable</span>
}

// selectReplicasToRemove selects replicas to remove
func (rm *ReplicationManager) selectReplicasToRemove(modelName string, count int) []*ReplicaInfo <span class="cov0" title="0">{
        replicas := rm.GetReplicas(modelName)
        
        // Sort by health and last sync time (prefer to remove unhealthy ones)
        // This is a simplified selection logic
        var toRemove []*ReplicaInfo
        
        for _, replica := range replicas </span><span class="cov0" title="0">{
                if len(toRemove) &gt;= count </span><span class="cov0" title="0">{
                        break</span>
                }
                
                <span class="cov0" title="0">if replica.Health == HealthError || replica.Status == ReplicaStatusUnhealthy </span><span class="cov0" title="0">{
                        toRemove = append(toRemove, replica)
                }</span>
        }
        
        // If still need more, remove based on last sync time
        <span class="cov0" title="0">if len(toRemove) &lt; count </span><span class="cov0" title="0">{
                for _, replica := range replicas </span><span class="cov0" title="0">{
                        if len(toRemove) &gt;= count </span><span class="cov0" title="0">{
                                break</span>
                        }
                        
                        <span class="cov0" title="0">alreadySelected := false
                        for _, selected := range toRemove </span><span class="cov0" title="0">{
                                if selected.PeerID == replica.PeerID </span><span class="cov0" title="0">{
                                        alreadySelected = true
                                        break</span>
                                }
                        }
                        
                        <span class="cov0" title="0">if !alreadySelected </span><span class="cov0" title="0">{
                                toRemove = append(toRemove, replica)
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return toRemove</span>
}

// isPeerConnected checks if a peer is connected
func (rm *ReplicationManager) isPeerConnected(peer string, connectedPeers []string) bool <span class="cov0" title="0">{
        for _, connected := range connectedPeers </span><span class="cov0" title="0">{
                if connected == peer </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// isPeerExcluded checks if a peer is excluded
func (rm *ReplicationManager) isPeerExcluded(peer string, excludedPeers []string) bool <span class="cov0" title="0">{
        for _, excluded := range excludedPeers </span><span class="cov0" title="0">{
                if excluded == peer </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// isPeerSuitable checks if a peer meets the constraints
func (rm *ReplicationManager) isPeerSuitable(peer string, constraints map[string]string) bool <span class="cov0" title="0">{
        // TODO: Implement constraint checking
        // This would check things like:
        // - Available storage space
        // - Network bandwidth
        // - Geographic location
        // - Hardware capabilities
        return true
}</span>

// loadPolicies loads existing replication policies
func (rm *ReplicationManager) loadPolicies() error <span class="cov0" title="0">{
        // TODO: Load policies from persistent storage
        // For now, create default policies for existing models
        
        models := rm.manager.GetAllModels()
        for modelName := range models </span><span class="cov0" title="0">{
                if _, exists := rm.GetReplicationPolicy(modelName); !exists </span><span class="cov0" title="0">{
                        // Create default policy
                        policy := &amp;ReplicationPolicy{
                                ModelName:         modelName,
                                MinReplicas:       rm.config.DefaultMinReplicas,
                                MaxReplicas:       rm.config.DefaultMaxReplicas,
                                ReplicationFactor: rm.config.DefaultReplicationFactor,
                                SyncInterval:      rm.config.DefaultSyncInterval,
                                Priority:          1,
                                Constraints:       make(map[string]string),
                                CreatedAt:         time.Now(),
                                UpdatedAt:         time.Now(),
                        }
                        
                        rm.policiesMutex.Lock()
                        rm.policies[modelName] = policy
                        rm.policiesMutex.Unlock()
                }</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// policyEnforcementRoutine runs periodic policy enforcement
func (rm *ReplicationManager) policyEnforcementRoutine() <span class="cov0" title="0">{
        ticker := time.NewTicker(rm.config.PolicyEnforcementInterval)
        defer ticker.Stop()
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-rm.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        rm.enforceAllPolicies()</span>
                }
        }
}

// enforceAllPolicies enforces all replication policies
func (rm *ReplicationManager) enforceAllPolicies() <span class="cov0" title="0">{
        rm.policiesMutex.RLock()
        policies := make(map[string]*ReplicationPolicy)
        for k, v := range rm.policies </span><span class="cov0" title="0">{
                policies[k] = v
        }</span>
        <span class="cov0" title="0">rm.policiesMutex.RUnlock()
        
        for modelName := range policies </span><span class="cov0" title="0">{
                rm.enforcePolicy(modelName)
        }</span>
}

// Shutdown gracefully shuts down the replication manager
func (rm *ReplicationManager) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        rm.mu.Lock()
        defer rm.mu.Unlock()
        
        if !rm.started </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        // Stop workers
        <span class="cov0" title="0">for _, worker := range rm.workers </span><span class="cov0" title="0">{
                close(worker.stopChan)
        }</span>
        
        // Stop health checker
        <span class="cov0" title="0">close(rm.healthChecker.stopChan)
        
        rm.cancel()
        rm.started = false
        
        rm.logger.Info("replication manager shutdown complete")
        return nil</span>
}

// ReplicationWorker methods

// start starts the replication worker
func (w *ReplicationWorker) start() <span class="cov0" title="0">{
        w.manager.logger.Info("replication worker started", "worker_id", w.ID)
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-w.stopChan:<span class="cov0" title="0">
                        w.manager.logger.Info("replication worker stopped", "worker_id", w.ID)
                        return</span>
                case task := &lt;-w.manager.workQueue:<span class="cov0" title="0">
                        w.processTask(task)</span>
                }
        }
}

// processTask processes a replication task
func (w *ReplicationWorker) processTask(task *ReplicationTask) <span class="cov0" title="0">{
        w.manager.logger.Info("processing replication task", "worker_id", w.ID, "type", task.Type, "model", task.ModelName, "peer", task.TargetPeer)
        
        var err error
        
        switch task.Type </span>{
        case TaskTypeReplicate:<span class="cov0" title="0">
                err = w.processReplicate(task)</span>
        case TaskTypeSync:<span class="cov0" title="0">
                err = w.processSync(task)</span>
        case TaskTypeRemove:<span class="cov0" title="0">
                err = w.processRemove(task)</span>
        case TaskTypeVerify:<span class="cov0" title="0">
                err = w.processVerify(task)</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("unknown task type: %s", task.Type)</span>
        }
        
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                w.manager.logger.Error("replication task failed", "worker_id", w.ID, "type", task.Type, "model", task.ModelName, "error", err)
                
                // Retry if possible
                if task.Retries &lt; task.MaxRetries </span><span class="cov0" title="0">{
                        task.Retries++
                        go func() </span><span class="cov0" title="0">{
                                time.Sleep(time.Duration(task.Retries) * time.Second)
                                select </span>{
                                case w.manager.workQueue &lt;- task:<span class="cov0" title="0"></span>
                                default:<span class="cov0" title="0">
                                        // Queue full, send error
                                        select </span>{
                                        case task.ResponseChan &lt;- fmt.Errorf("retry failed: queue full"):<span class="cov0" title="0"></span>
                                        default:<span class="cov0" title="0"></span>
                                        }
                                }
                        }()
                        <span class="cov0" title="0">return</span>
                }
        } else<span class="cov0" title="0"> {
                w.manager.logger.Info("replication task completed", "worker_id", w.ID, "type", task.Type, "model", task.ModelName)
        }</span>
        
        // Send response
        <span class="cov0" title="0">select </span>{
        case task.ResponseChan &lt;- err:<span class="cov0" title="0"></span>
        case &lt;-time.After(time.Second):<span class="cov0" title="0"></span>
                // Response channel blocked
        }
}

// processReplicate processes a replicate task
func (w *ReplicationWorker) processReplicate(task *ReplicationTask) error <span class="cov0" title="0">{
        // TODO: Implement actual replication logic
        // This would involve:
        // 1. Checking if model exists locally
        // 2. Initiating transfer to target peer
        // 3. Monitoring transfer progress
        // 4. Updating replica information
        
        time.Sleep(100 * time.Millisecond) // Simulate work
        
        // Create replica info
        replica := &amp;ReplicaInfo{
                ModelName:    task.ModelName,
                PeerID:       task.TargetPeer,
                Status:       ReplicaStatusHealthy,
                LastSync:     time.Now(),
                SyncAttempts: 1,
                Health:       HealthGood,
                Metadata:     make(map[string]string),
                CreatedAt:    time.Now(),
                UpdatedAt:    time.Now(),
        }
        
        // Store replica info
        replicaKey := fmt.Sprintf("%s:%s", task.ModelName, task.TargetPeer)
        w.manager.replicasMutex.Lock()
        w.manager.replicas[replicaKey] = replica
        w.manager.replicasMutex.Unlock()
        
        return nil
}</span>

// processSync processes a sync task
func (w *ReplicationWorker) processSync(task *ReplicationTask) error <span class="cov0" title="0">{
        // Use sync manager to synchronize the model
        return w.manager.syncMgr.SynchronizeModel(task.ModelName, task.TargetPeer, SyncTypeIncremental)
}</span>

// processRemove processes a remove task
func (w *ReplicationWorker) processRemove(task *ReplicationTask) error <span class="cov0" title="0">{
        // TODO: Implement replica removal logic
        // This would involve:
        // 1. Sending remove request to target peer
        // 2. Waiting for confirmation
        // 3. Updating replica information
        
        time.Sleep(50 * time.Millisecond) // Simulate work
        
        // Remove replica info
        replicaKey := fmt.Sprintf("%s:%s", task.ModelName, task.TargetPeer)
        w.manager.replicasMutex.Lock()
        delete(w.manager.replicas, replicaKey)
        w.manager.replicasMutex.Unlock()
        
        return nil
}</span>

// processVerify processes a verify task
func (w *ReplicationWorker) processVerify(task *ReplicationTask) error <span class="cov0" title="0">{
        // TODO: Implement replica verification logic
        // This would involve:
        // 1. Getting replica hash from target peer
        // 2. Comparing with local hash
        // 3. Updating replica health status
        
        time.Sleep(25 * time.Millisecond) // Simulate work
        return nil
}</span>

// HealthChecker methods

// start starts the health checker
func (hc *HealthChecker) start() <span class="cov0" title="0">{
        hc.manager.logger.Info("health checker started")
        
        ticker := time.NewTicker(hc.checkInterval)
        defer ticker.Stop()
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-hc.stopChan:<span class="cov0" title="0">
                        hc.manager.logger.Info("health checker stopped")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        hc.checkAllReplicas()</span>
                }
        }
}

// checkAllReplicas checks the health of all replicas
func (hc *HealthChecker) checkAllReplicas() <span class="cov0" title="0">{
        replicas := hc.manager.GetAllReplicas()
        
        for _, replica := range replicas </span><span class="cov0" title="0">{
                go hc.checkReplica(replica)
        }</span>
}

// checkReplica checks the health of a single replica
func (hc *HealthChecker) checkReplica(replica *ReplicaInfo) <span class="cov0" title="0">{
        // TODO: Implement actual health checking
        // This would involve:
        // 1. Pinging the peer
        // 2. Checking model availability
        // 3. Verifying model integrity
        // 4. Updating health status
        
        // For now, simulate health check
        healthy := true // Assume healthy for simulation
        
        hc.manager.replicasMutex.Lock()
        defer hc.manager.replicasMutex.Unlock()
        
        replicaKey := fmt.Sprintf("%s:%s", replica.ModelName, replica.PeerID)
        if storedReplica, exists := hc.manager.replicas[replicaKey]; exists </span><span class="cov0" title="0">{
                if healthy </span><span class="cov0" title="0">{
                        storedReplica.Health = HealthGood
                        storedReplica.Status = ReplicaStatusHealthy
                }</span> else<span class="cov0" title="0"> {
                        storedReplica.Health = HealthError
                        storedReplica.Status = ReplicaStatusUnhealthy
                }</span>
                <span class="cov0" title="0">storedReplica.UpdatedAt = time.Now()</span>
        }
}</pre>
		
		<pre class="file" id="file17" style="display: none">package models

import (
        "context"
        "crypto/sha256"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "io"
        "log/slog"
        "os"
        "path/filepath"
        "sync"
        "time"

        "github.com/ollama/ollama-distributed/internal/config"
        "github.com/ollama/ollama-distributed/pkg/p2p"
)

// SyncManager manages model synchronization across the distributed network
type SyncManager struct {
        config      *config.SyncConfig
        p2p         *p2p.Node
        manager     *Manager
        logger      *slog.Logger
        
        // Sync state
        syncStates  map[string]*SyncState
        syncMutex   sync.RWMutex
        
        // Version tracking
        modelVersions map[string]*ModelVersion
        versionMutex  sync.RWMutex
        
        // Sync workers
        syncWorkers    []*SyncWorker
        syncQueue      chan *SyncRequest
        
        // Delta tracking
        deltaTracker   *DeltaTracker
        
        // Content-addressed storage
        casStore       *ContentAddressedStore
        
        ctx     context.Context
        cancel  context.CancelFunc
        started bool
        mu      sync.RWMutex
}

// SyncState represents the synchronization state of a model
type SyncState struct {
        ModelName      string                 `json:"model_name"`
        LocalVersion   string                 `json:"local_version"`
        RemoteVersions map[string]string      `json:"remote_versions"` // peerID -&gt; version
        Status         SyncStatus             `json:"status"`
        LastSyncTime   time.Time              `json:"last_sync_time"`
        PendingDeltas  []string               `json:"pending_deltas"`
        Conflicts      []SyncConflict         `json:"conflicts"`
        Metadata       map[string]interface{} `json:"metadata"`
}

// SyncStatus represents the status of model synchronization
type SyncStatus string

const (
        SyncStatusInSync     SyncStatus = "in_sync"
        SyncStatusOutOfSync  SyncStatus = "out_of_sync"
        SyncStatusSyncing    SyncStatus = "syncing"
        SyncStatusConflict   SyncStatus = "conflict"
        SyncStatusError      SyncStatus = "error"
)

// SyncConflict represents a synchronization conflict
type SyncConflict struct {
        Type        ConflictType `json:"type"`
        LocalHash   string       `json:"local_hash"`
        RemoteHash  string       `json:"remote_hash"`
        PeerID      string       `json:"peer_id"`
        Description string       `json:"description"`
        Timestamp   time.Time    `json:"timestamp"`
}

// ConflictType represents the type of synchronization conflict
type ConflictType string

const (
        ConflictTypeVersion    ConflictType = "version"
        ConflictTypeChecksum   ConflictType = "checksum"
        ConflictTypeTimestamp  ConflictType = "timestamp"
        ConflictTypeMetadata   ConflictType = "metadata"
)

// ModelVersion represents a versioned model with content addressing
type ModelVersion struct {
        Name        string            `json:"name"`
        Version     string            `json:"version"`
        Hash        string            `json:"hash"`        // Content-addressed hash
        ParentHash  string            `json:"parent_hash"` // Previous version hash
        Size        int64             `json:"size"`
        Chunks      []ChunkInfo       `json:"chunks"`
        Metadata    map[string]string `json:"metadata"`
        Timestamp   time.Time         `json:"timestamp"`
        Author      string            `json:"author"`      // Node ID that created this version
        Signature   string            `json:"signature"`   // Cryptographic signature
}

// ChunkInfo represents a chunk of a model file
type ChunkInfo struct {
        Hash   string `json:"hash"`
        Size   int64  `json:"size"`
        Offset int64  `json:"offset"`
}

// SyncRequest represents a request to synchronize a model
type SyncRequest struct {
        ModelName    string      `json:"model_name"`
        PeerID       string      `json:"peer_id"`
        SyncType     SyncType    `json:"sync_type"`
        Priority     int         `json:"priority"`
        ResponseChan chan error  `json:"-"`
}

// SyncType represents the type of synchronization
type SyncType string

const (
        SyncTypeFull        SyncType = "full"
        SyncTypeIncremental SyncType = "incremental"
        SyncTypeDelta       SyncType = "delta"
)

// SyncWorker handles synchronization operations
type SyncWorker struct {
        ID         int
        manager    *SyncManager
        stopChan   chan struct{}
}

// NewSyncManager creates a new model synchronization manager
func NewSyncManager(config *config.SyncConfig, p2pNode *p2p.Node, manager *Manager, logger *slog.Logger) (*SyncManager, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())
        
        sm := &amp;SyncManager{
                config:        config,
                p2p:           p2pNode,
                manager:       manager,
                logger:        logger,
                syncStates:    make(map[string]*SyncState),
                modelVersions: make(map[string]*ModelVersion),
                syncQueue:     make(chan *SyncRequest, 100),
                ctx:           ctx,
                cancel:        cancel,
        }
        
        // Initialize delta tracker
        deltaTracker, err := NewDeltaTracker(config.DeltaDir, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create delta tracker: %w", err)
        }</span>
        <span class="cov0" title="0">sm.deltaTracker = deltaTracker
        
        // Initialize content-addressed store
        casStore, err := NewContentAddressedStore(config.CASDir, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create CAS store: %w", err)
        }</span>
        <span class="cov0" title="0">sm.casStore = casStore
        
        // Create sync workers
        sm.syncWorkers = make([]*SyncWorker, config.WorkerCount)
        for i := 0; i &lt; config.WorkerCount; i++ </span><span class="cov0" title="0">{
                sm.syncWorkers[i] = &amp;SyncWorker{
                        ID:       i,
                        manager:  sm,
                        stopChan: make(chan struct{}),
                }
        }</span>
        
        <span class="cov0" title="0">return sm, nil</span>
}

// Start starts the synchronization manager
func (sm *SyncManager) Start() error <span class="cov0" title="0">{
        sm.mu.Lock()
        defer sm.mu.Unlock()
        
        if sm.started </span><span class="cov0" title="0">{
                return fmt.Errorf("sync manager already started")
        }</span>
        
        // Create necessary directories
        <span class="cov0" title="0">if err := os.MkdirAll(sm.config.DeltaDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create delta directory: %w", err)
        }</span>
        
        <span class="cov0" title="0">if err := os.MkdirAll(sm.config.CASDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create CAS directory: %w", err)
        }</span>
        
        // Load existing sync states
        <span class="cov0" title="0">if err := sm.loadSyncStates(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load sync states: %w", err)
        }</span>
        
        // Start sync workers
        <span class="cov0" title="0">for _, worker := range sm.syncWorkers </span><span class="cov0" title="0">{
                go worker.start()
        }</span>
        
        // Start periodic sync routine
        <span class="cov0" title="0">go sm.periodicSyncRoutine()
        
        // Start version tracking routine
        go sm.versionTrackingRoutine()
        
        sm.started = true
        sm.logger.Info("sync manager started", "workers", len(sm.syncWorkers))
        
        return nil</span>
}

// SynchronizeModel synchronizes a model with a specific peer
func (sm *SyncManager) SynchronizeModel(modelName, peerID string, syncType SyncType) error <span class="cov0" title="0">{
        req := &amp;SyncRequest{
                ModelName:    modelName,
                PeerID:       peerID,
                SyncType:     syncType,
                Priority:     1,
                ResponseChan: make(chan error, 1),
        }
        
        select </span>{
        case sm.syncQueue &lt;- req:<span class="cov0" title="0"></span>
        case &lt;-time.After(5 * time.Second):<span class="cov0" title="0">
                return fmt.Errorf("sync queue full")</span>
        }
        
        <span class="cov0" title="0">select </span>{
        case err := &lt;-req.ResponseChan:<span class="cov0" title="0">
                return err</span>
        case &lt;-time.After(10 * time.Minute):<span class="cov0" title="0">
                return fmt.Errorf("sync timeout")</span>
        }
}

// GetSyncState returns the synchronization state of a model
func (sm *SyncManager) GetSyncState(modelName string) (*SyncState, bool) <span class="cov0" title="0">{
        sm.syncMutex.RLock()
        defer sm.syncMutex.RUnlock()
        
        state, exists := sm.syncStates[modelName]
        return state, exists
}</span>

// GetModelVersion returns the version information for a model
func (sm *SyncManager) GetModelVersion(modelName string) (*ModelVersion, bool) <span class="cov0" title="0">{
        sm.versionMutex.RLock()
        defer sm.versionMutex.RUnlock()
        
        version, exists := sm.modelVersions[modelName]
        return version, exists
}</span>

// CreateModelVersion creates a new version for a model
func (sm *SyncManager) CreateModelVersion(modelName, modelPath string) (*ModelVersion, error) <span class="cov0" title="0">{
        // Calculate content hash
        hash, err := sm.calculateModelHash(modelPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to calculate model hash: %w", err)
        }</span>
        
        // Get file info
        <span class="cov0" title="0">info, err := os.Stat(modelPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to stat model file: %w", err)
        }</span>
        
        // Create chunks
        <span class="cov0" title="0">chunks, err := sm.createChunks(modelPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create chunks: %w", err)
        }</span>
        
        // Get previous version if exists
        <span class="cov0" title="0">var parentHash string
        if prevVersion, exists := sm.GetModelVersion(modelName); exists </span><span class="cov0" title="0">{
                parentHash = prevVersion.Hash
        }</span>
        
        // Create version
        <span class="cov0" title="0">version := &amp;ModelVersion{
                Name:       modelName,
                Version:    sm.generateVersion(),
                Hash:       hash,
                ParentHash: parentHash,
                Size:       info.Size(),
                Chunks:     chunks,
                Metadata:   make(map[string]string),
                Timestamp:  time.Now(),
                Author:     sm.p2p.ID().String(),
        }
        
        // Store in content-addressed store
        if err := sm.casStore.Store(hash, modelPath); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to store in CAS: %w", err)
        }</span>
        
        // Update version tracking
        <span class="cov0" title="0">sm.versionMutex.Lock()
        sm.modelVersions[modelName] = version
        sm.versionMutex.Unlock()
        
        sm.logger.Info("created model version", "model", modelName, "version", version.Version, "hash", hash)
        
        return version, nil</span>
}

// loadSyncStates loads existing synchronization states
func (sm *SyncManager) loadSyncStates() error <span class="cov0" title="0">{
        stateFile := filepath.Join(sm.config.DeltaDir, "sync_states.json")
        
        if _, err := os.Stat(stateFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil // No existing states
        }</span>
        
        <span class="cov0" title="0">data, err := os.ReadFile(stateFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read sync states: %w", err)
        }</span>
        
        <span class="cov0" title="0">var states map[string]*SyncState
        if err := json.Unmarshal(data, &amp;states); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal sync states: %w", err)
        }</span>
        
        <span class="cov0" title="0">sm.syncMutex.Lock()
        sm.syncStates = states
        sm.syncMutex.Unlock()
        
        return nil</span>
}

// saveSyncStates saves synchronization states to disk
func (sm *SyncManager) saveSyncStates() error <span class="cov0" title="0">{
        sm.syncMutex.RLock()
        defer sm.syncMutex.RUnlock()
        
        stateFile := filepath.Join(sm.config.DeltaDir, "sync_states.json")
        
        data, err := json.MarshalIndent(sm.syncStates, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal sync states: %w", err)
        }</span>
        
        <span class="cov0" title="0">return os.WriteFile(stateFile, data, 0644)</span>
}

// calculateModelHash calculates the content hash of a model file
func (sm *SyncManager) calculateModelHash(modelPath string) (string, error) <span class="cov0" title="0">{
        file, err := os.Open(modelPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer file.Close()
        
        hash := sha256.New()
        if _, err := io.Copy(hash, file); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        
        <span class="cov0" title="0">return hex.EncodeToString(hash.Sum(nil)), nil</span>
}

// createChunks creates chunks for a model file
func (sm *SyncManager) createChunks(modelPath string) ([]ChunkInfo, error) <span class="cov0" title="0">{
        file, err := os.Open(modelPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer file.Close()
        
        chunkSize := sm.config.ChunkSize
        if chunkSize == 0 </span><span class="cov0" title="0">{
                chunkSize = 1024 * 1024 // Default 1MB chunks
        }</span>
        
        <span class="cov0" title="0">var chunks []ChunkInfo
        buffer := make([]byte, chunkSize)
        offset := int64(0)
        
        for </span><span class="cov0" title="0">{
                n, err := file.Read(buffer)
                if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                
                <span class="cov0" title="0">if n == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
                
                // Calculate chunk hash
                <span class="cov0" title="0">hash := sha256.Sum256(buffer[:n])
                
                chunks = append(chunks, ChunkInfo{
                        Hash:   hex.EncodeToString(hash[:]),
                        Size:   int64(n),
                        Offset: offset,
                })
                
                offset += int64(n)</span>
        }
        
        <span class="cov0" title="0">return chunks, nil</span>
}

// generateVersion generates a new version string
func (sm *SyncManager) generateVersion() string <span class="cov0" title="0">{
        return fmt.Sprintf("%d", time.Now().UnixNano())
}</span>

// periodicSyncRoutine runs periodic synchronization tasks
func (sm *SyncManager) periodicSyncRoutine() <span class="cov0" title="0">{
        ticker := time.NewTicker(sm.config.SyncInterval)
        defer ticker.Stop()
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-sm.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        sm.performPeriodicSync()</span>
                }
        }
}

// performPeriodicSync performs periodic synchronization tasks
func (sm *SyncManager) performPeriodicSync() <span class="cov0" title="0">{
        // Save sync states
        if err := sm.saveSyncStates(); err != nil </span><span class="cov0" title="0">{
                sm.logger.Error("failed to save sync states", "error", err)
        }</span>
        
        // Check for models that need synchronization
        <span class="cov0" title="0">models := sm.manager.GetAllModels()
        for modelName := range models </span><span class="cov0" title="0">{
                state, exists := sm.GetSyncState(modelName)
                if !exists </span><span class="cov0" title="0">{
                        // Create initial sync state
                        state = &amp;SyncState{
                                ModelName:      modelName,
                                LocalVersion:   "1.0.0",
                                RemoteVersions: make(map[string]string),
                                Status:         SyncStatusInSync,
                                LastSyncTime:   time.Now(),
                                PendingDeltas:  []string{},
                                Conflicts:      []SyncConflict{},
                                Metadata:       make(map[string]interface{}),
                        }
                        
                        sm.syncMutex.Lock()
                        sm.syncStates[modelName] = state
                        sm.syncMutex.Unlock()
                }</span>
                
                // Check if sync is needed
                <span class="cov0" title="0">if time.Since(state.LastSyncTime) &gt; sm.config.SyncInterval </span><span class="cov0" title="0">{
                        // Queue for synchronization
                        go func(name string) </span><span class="cov0" title="0">{
                                sm.SynchronizeModel(name, "", SyncTypeIncremental)
                        }</span>(modelName)
                }
        }
}

// versionTrackingRoutine runs version tracking tasks
func (sm *SyncManager) versionTrackingRoutine() <span class="cov0" title="0">{
        ticker := time.NewTicker(time.Minute * 5)
        defer ticker.Stop()
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-sm.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        sm.trackModelVersions()</span>
                }
        }
}

// trackModelVersions tracks changes in model versions
func (sm *SyncManager) trackModelVersions() <span class="cov0" title="0">{
        models := sm.manager.GetAllModels()
        
        for modelName, model := range models </span><span class="cov0" title="0">{
                // Check if version has changed
                currentVersion, exists := sm.GetModelVersion(modelName)
                if !exists </span><span class="cov0" title="0">{
                        // Create initial version
                        if _, err := sm.CreateModelVersion(modelName, model.Path); err != nil </span><span class="cov0" title="0">{
                                sm.logger.Error("failed to create initial version", "model", modelName, "error", err)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                
                // Calculate current hash
                <span class="cov0" title="0">currentHash, err := sm.calculateModelHash(model.Path)
                if err != nil </span><span class="cov0" title="0">{
                        sm.logger.Error("failed to calculate model hash", "model", modelName, "error", err)
                        continue</span>
                }
                
                // Check if model has changed
                <span class="cov0" title="0">if currentHash != currentVersion.Hash </span><span class="cov0" title="0">{
                        // Create new version
                        if _, err := sm.CreateModelVersion(modelName, model.Path); err != nil </span><span class="cov0" title="0">{
                                sm.logger.Error("failed to create new version", "model", modelName, "error", err)
                        }</span> else<span class="cov0" title="0"> {
                                sm.logger.Info("model version updated", "model", modelName, "old_hash", currentVersion.Hash, "new_hash", currentHash)
                        }</span>
                }
        }
}

// Shutdown gracefully shuts down the synchronization manager
func (sm *SyncManager) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        sm.mu.Lock()
        defer sm.mu.Unlock()
        
        if !sm.started </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        // Stop workers
        <span class="cov0" title="0">for _, worker := range sm.syncWorkers </span><span class="cov0" title="0">{
                close(worker.stopChan)
        }</span>
        
        // Save final state
        <span class="cov0" title="0">if err := sm.saveSyncStates(); err != nil </span><span class="cov0" title="0">{
                sm.logger.Error("failed to save final sync states", "error", err)
        }</span>
        
        // Close delta tracker
        <span class="cov0" title="0">if sm.deltaTracker != nil </span><span class="cov0" title="0">{
                sm.deltaTracker.Close()
        }</span>
        
        // Close CAS store
        <span class="cov0" title="0">if sm.casStore != nil </span><span class="cov0" title="0">{
                sm.casStore.Close()
        }</span>
        
        <span class="cov0" title="0">sm.cancel()
        sm.started = false
        
        sm.logger.Info("sync manager shutdown complete")
        return nil</span>
}

// SyncWorker methods

// start starts the sync worker
func (w *SyncWorker) start() <span class="cov0" title="0">{
        w.manager.logger.Info("sync worker started", "worker_id", w.ID)
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-w.stopChan:<span class="cov0" title="0">
                        w.manager.logger.Info("sync worker stopped", "worker_id", w.ID)
                        return</span>
                case req := &lt;-w.manager.syncQueue:<span class="cov0" title="0">
                        w.processSyncRequest(req)</span>
                }
        }
}

// processSyncRequest processes a synchronization request
func (w *SyncWorker) processSyncRequest(req *SyncRequest) <span class="cov0" title="0">{
        w.manager.logger.Info("processing sync request", "worker_id", w.ID, "model", req.ModelName, "peer", req.PeerID, "type", req.SyncType)
        
        var err error
        
        switch req.SyncType </span>{
        case SyncTypeFull:<span class="cov0" title="0">
                err = w.performFullSync(req)</span>
        case SyncTypeIncremental:<span class="cov0" title="0">
                err = w.performIncrementalSync(req)</span>
        case SyncTypeDelta:<span class="cov0" title="0">
                err = w.performDeltaSync(req)</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("unknown sync type: %s", req.SyncType)</span>
        }
        
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                w.manager.logger.Error("sync request failed", "worker_id", w.ID, "model", req.ModelName, "error", err)
        }</span> else<span class="cov0" title="0"> {
                w.manager.logger.Info("sync request completed", "worker_id", w.ID, "model", req.ModelName)
        }</span>
        
        // Send response
        <span class="cov0" title="0">select </span>{
        case req.ResponseChan &lt;- err:<span class="cov0" title="0"></span>
        case &lt;-time.After(time.Second):<span class="cov0" title="0"></span>
                // Response channel blocked
        }
}

// performFullSync performs a full synchronization
func (w *SyncWorker) performFullSync(req *SyncRequest) error <span class="cov0" title="0">{
        // TODO: Implement full sync logic
        // This would involve:
        // 1. Getting the complete model from peer
        // 2. Verifying integrity
        // 3. Replacing local model
        // 4. Updating sync state
        
        time.Sleep(100 * time.Millisecond) // Simulate work
        
        // Update sync state
        w.manager.syncMutex.Lock()
        if state, exists := w.manager.syncStates[req.ModelName]; exists </span><span class="cov0" title="0">{
                state.Status = SyncStatusInSync
                state.LastSyncTime = time.Now()
                if req.PeerID != "" </span><span class="cov0" title="0">{
                        state.RemoteVersions[req.PeerID] = "1.0.0"
                }</span>
        }
        <span class="cov0" title="0">w.manager.syncMutex.Unlock()
        
        return nil</span>
}

// performIncrementalSync performs an incremental synchronization
func (w *SyncWorker) performIncrementalSync(req *SyncRequest) error <span class="cov0" title="0">{
        // TODO: Implement incremental sync logic
        // This would involve:
        // 1. Comparing model versions
        // 2. Identifying differences
        // 3. Downloading only changed parts
        // 4. Applying changes
        // 5. Updating sync state
        
        time.Sleep(50 * time.Millisecond) // Simulate work
        
        // Update sync state
        w.manager.syncMutex.Lock()
        if state, exists := w.manager.syncStates[req.ModelName]; exists </span><span class="cov0" title="0">{
                state.Status = SyncStatusInSync
                state.LastSyncTime = time.Now()
                if req.PeerID != "" </span><span class="cov0" title="0">{
                        state.RemoteVersions[req.PeerID] = "1.0.1"
                }</span>
        }
        <span class="cov0" title="0">w.manager.syncMutex.Unlock()
        
        return nil</span>
}

// performDeltaSync performs a delta synchronization
func (w *SyncWorker) performDeltaSync(req *SyncRequest) error <span class="cov0" title="0">{
        // TODO: Implement delta sync logic
        // This would involve:
        // 1. Getting delta information from peer
        // 2. Applying deltas to local model
        // 3. Verifying result integrity
        // 4. Updating sync state
        
        time.Sleep(25 * time.Millisecond) // Simulate work
        
        // Update sync state
        w.manager.syncMutex.Lock()
        if state, exists := w.manager.syncStates[req.ModelName]; exists </span><span class="cov0" title="0">{
                state.Status = SyncStatusInSync
                state.LastSyncTime = time.Now()
                if req.PeerID != "" </span><span class="cov0" title="0">{
                        state.RemoteVersions[req.PeerID] = "1.0.2"
                }</span>
        }
        <span class="cov0" title="0">w.manager.syncMutex.Unlock()
        
        return nil</span>
}</pre>
		
		<pre class="file" id="file18" style="display: none">package discovery

import (
        "context"
        "fmt"
        "log"
        "sync"
        "time"

        "github.com/libp2p/go-libp2p/core/discovery"
        "github.com/libp2p/go-libp2p/core/host"
        "github.com/libp2p/go-libp2p/core/network"
        "github.com/libp2p/go-libp2p/core/peer"
        "github.com/libp2p/go-libp2p/p2p/discovery/mdns"
        "github.com/libp2p/go-libp2p/p2p/discovery/routing"
        dht "github.com/libp2p/go-libp2p-kad-dht"
        "github.com/multiformats/go-multiaddr"
)

// DiscoveryConfig represents configuration needed by the discovery engine
type DiscoveryConfig interface {
        GetBootstrapPeers() []string
        GetRendezvousString() string
        IsAutoDiscoveryEnabled() bool
}

// DiscoveryEngine manages multi-strategy peer discovery
type DiscoveryEngine struct {
        host        host.Host
        config      DiscoveryConfig
        dht         *dht.IpfsDHT
        mdns        mdns.Service
        bootstrap   *BootstrapDiscovery
        rendezvous  *RendezvousDiscovery
        
        // Discovery strategies
        strategies  []DiscoveryStrategy
        
        // Peer cache
        peerCache   *PeerCache
        
        // Events
        peerFound   chan peer.AddrInfo
        peerLost    chan peer.ID
        
        // Lifecycle
        ctx         context.Context
        cancel      context.CancelFunc
        wg          sync.WaitGroup
        
        // Metrics
        metrics     *DiscoveryMetrics
}

// DiscoveryStrategy defines interface for discovery strategies
type DiscoveryStrategy interface {
        Name() string
        FindPeers(ctx context.Context, ns string, opts ...discovery.Option) (&lt;-chan peer.AddrInfo, error)
        Advertise(ctx context.Context, ns string, opts ...discovery.Option) (time.Duration, error)
}

// DiscoveryMetrics tracks discovery performance
type DiscoveryMetrics struct {
        PeersFound      int
        PeersLost       int
        ActivePeers     int
        DiscoveryErrors int
        LastDiscovery   time.Time
        StartTime       time.Time
        
        // Strategy metrics
        StrategyMetrics map[string]*StrategyMetrics
}

// StrategyMetrics tracks metrics for individual strategies
type StrategyMetrics struct {
        PeersFound      int
        Errors          int
        LastSuccess     time.Time
        AverageLatency  time.Duration
}

// PeerCache manages discovered peers
type PeerCache struct {
        peers    map[peer.ID]*CachedPeer
        peersMux sync.RWMutex
        
        // Cache settings
        maxSize    int
        ttl        time.Duration
        
        // Cleanup
        cleanupInterval time.Duration
}

// CachedPeer represents a cached peer
type CachedPeer struct {
        AddrInfo    peer.AddrInfo
        DiscoveredAt time.Time
        LastSeen    time.Time
        Source      string
        Quality     *PeerQuality
}

// PeerQuality represents peer quality metrics
type PeerQuality struct {
        Latency     time.Duration
        Reliability float64
        Bandwidth   int64
        LastTest    time.Time
}

// NewDiscoveryEngine creates a new discovery engine
func NewDiscoveryEngine(ctx context.Context, h host.Host, config DiscoveryConfig) (*DiscoveryEngine, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(ctx)
        
        engine := &amp;DiscoveryEngine{
                host:       h,
                config:     config,
                peerFound:  make(chan peer.AddrInfo, 100),
                peerLost:   make(chan peer.ID, 100),
                ctx:        ctx,
                cancel:     cancel,
                metrics: &amp;DiscoveryMetrics{
                        StartTime:       time.Now(),
                        StrategyMetrics: make(map[string]*StrategyMetrics),
                },
        }
        
        // Initialize peer cache
        engine.peerCache = NewPeerCache(1000, 5*time.Minute)
        
        // Initialize discovery strategies
        if err := engine.initializeStrategies(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize discovery strategies: %w", err)
        }</span>
        
        <span class="cov0" title="0">return engine, nil</span>
}

// initializeStrategies initializes all discovery strategies
func (d *DiscoveryEngine) initializeStrategies() error <span class="cov0" title="0">{
        // Initialize DHT if enabled
        if isDHTEnabled(d.config) </span><span class="cov0" title="0">{
                if err := d.initializeDHT(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to initialize DHT: %w", err)
                }</span>
        }
        
        // Initialize mDNS
        <span class="cov0" title="0">if err := d.initializeMDNS(); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to initialize mDNS: %v", err)
        }</span>
        
        // Initialize bootstrap discovery
        <span class="cov0" title="0">if err := d.initializeBootstrap(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize bootstrap: %w", err)
        }</span>
        
        // Initialize rendezvous discovery
        <span class="cov0" title="0">if err := d.initializeRendezvous(); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to initialize rendezvous: %v", err)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// initializeDHT initializes DHT discovery
func (d *DiscoveryEngine) initializeDHT() error <span class="cov0" title="0">{
        // Configure DHT mode
        var mode dht.ModeOpt
        switch getDHTMode(d.config) </span>{
        case "client":<span class="cov0" title="0">
                mode = dht.ModeClient</span>
        case "server":<span class="cov0" title="0">
                mode = dht.ModeServer</span>
        default:<span class="cov0" title="0">
                mode = dht.ModeAuto</span>
        }
        
        // Create DHT
        <span class="cov0" title="0">kadDHT, err := dht.New(d.ctx, d.host, dht.Mode(mode))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create DHT: %w", err)
        }</span>
        
        <span class="cov0" title="0">d.dht = kadDHT
        
        // Bootstrap DHT
        if err := d.bootstrapDHT(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to bootstrap DHT: %w", err)
        }</span>
        
        // Add DHT strategy
        <span class="cov0" title="0">dhtStrategy := &amp;DHTStrategy{
                dht:     kadDHT,
                routing: routing.NewRoutingDiscovery(kadDHT),
        }
        d.strategies = append(d.strategies, dhtStrategy)
        d.metrics.StrategyMetrics["dht"] = &amp;StrategyMetrics{}
        
        log.Printf("DHT initialized in %s mode", getDHTMode(d.config))
        return nil</span>
}

// bootstrapDHT bootstraps the DHT with configured peers
func (d *DiscoveryEngine) bootstrapDHT() error <span class="cov0" title="0">{
        bootstrapPeers, err := parseBootstrapPeers(d.config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse bootstrap peers: %w", err)
        }</span>
        
        <span class="cov0" title="0">if len(bootstrapPeers) == 0 </span><span class="cov0" title="0">{
                log.Printf("No bootstrap peers configured")
                return nil
        }</span>
        
        // Connect to bootstrap peers
        <span class="cov0" title="0">for _, peerInfo := range bootstrapPeers </span><span class="cov0" title="0">{
                go func(p peer.AddrInfo) </span><span class="cov0" title="0">{
                        ctx, cancel := context.WithTimeout(d.ctx, 30*time.Second)
                        defer cancel()
                        
                        if err := d.host.Connect(ctx, p); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Failed to connect to bootstrap peer %s: %v", p.ID, err)
                                return
                        }</span>
                        
                        <span class="cov0" title="0">log.Printf("Connected to bootstrap peer: %s", p.ID)</span>
                }(peerInfo)
        }
        
        // Bootstrap the DHT
        <span class="cov0" title="0">if err := d.dht.Bootstrap(d.ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to bootstrap DHT: %w", err)
        }</span>
        
        <span class="cov0" title="0">log.Printf("DHT bootstrapped with %d peers", len(bootstrapPeers))
        return nil</span>
}

// initializeMDNS initializes mDNS discovery
func (d *DiscoveryEngine) initializeMDNS() error <span class="cov0" title="0">{
        notifee := &amp;mdnsNotifee{
                peerFound: d.peerFound,
        }
        
        mdnsService := mdns.NewMdnsService(d.host, "ollamacron", notifee)
        d.mdns = mdnsService
        
        // Add mDNS strategy
        mdnsStrategy := &amp;MDNSStrategy{
                service: mdnsService,
        }
        d.strategies = append(d.strategies, mdnsStrategy)
        d.metrics.StrategyMetrics["mdns"] = &amp;StrategyMetrics{}
        
        log.Printf("mDNS discovery initialized")
        return nil
}</span>

// initializeBootstrap initializes bootstrap discovery
func (d *DiscoveryEngine) initializeBootstrap() error <span class="cov0" title="0">{
        bootstrapPeers, err := parseBootstrapPeers(d.config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse bootstrap peers: %w", err)
        }</span>
        
        <span class="cov0" title="0">d.bootstrap = NewBootstrapDiscovery(d.host, bootstrapPeers, 5, 20)
        
        // Add bootstrap strategy
        d.strategies = append(d.strategies, d.bootstrap)
        d.metrics.StrategyMetrics["bootstrap"] = &amp;StrategyMetrics{}
        
        log.Printf("Bootstrap discovery initialized with %d peers", len(bootstrapPeers))
        return nil</span>
}

// initializeRendezvous initializes rendezvous discovery
func (d *DiscoveryEngine) initializeRendezvous() error <span class="cov0" title="0">{
        if d.dht == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("rendezvous requires DHT")
        }</span>
        
        <span class="cov0" title="0">d.rendezvous = NewRendezvousDiscovery(d.host, d.dht)
        
        // Add rendezvous strategy
        d.strategies = append(d.strategies, d.rendezvous)
        d.metrics.StrategyMetrics["rendezvous"] = &amp;StrategyMetrics{}
        
        log.Printf("Rendezvous discovery initialized")
        return nil</span>
}

// Start starts the discovery engine
func (d *DiscoveryEngine) Start() <span class="cov0" title="0">{
        log.Printf("Starting discovery engine with %d strategies", len(d.strategies))
        
        // Start peer cache cleanup
        d.wg.Add(1)
        go d.peerCache.start(d.ctx, &amp;d.wg)
        
        // Start discovery strategies
        for _, strategy := range d.strategies </span><span class="cov0" title="0">{
                d.wg.Add(1)
                go d.runStrategy(strategy)
        }</span>
        
        // Start bootstrap discovery
        <span class="cov0" title="0">if d.bootstrap != nil </span><span class="cov0" title="0">{
                d.wg.Add(1)
                go d.bootstrap.Start(d.ctx, &amp;d.wg)
        }</span>
        
        // Start metrics collection
        <span class="cov0" title="0">d.wg.Add(1)
        go d.collectMetrics()
        
        // Start event processing
        d.wg.Add(1)
        go d.processEvents()
        
        log.Printf("Discovery engine started")</span>
}

// runStrategy runs a discovery strategy
func (d *DiscoveryEngine) runStrategy(strategy DiscoveryStrategy) <span class="cov0" title="0">{
        defer d.wg.Done()
        
        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-d.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        d.runDiscovery(strategy)</span>
                }
        }
}

// runDiscovery runs discovery for a strategy
func (d *DiscoveryEngine) runDiscovery(strategy DiscoveryStrategy) <span class="cov0" title="0">{
        start := time.Now()
        
        // Advertise our presence
        if _, err := strategy.Advertise(d.ctx, "ollamacron"); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to advertise on %s: %v", strategy.Name(), err)
                d.metrics.StrategyMetrics[strategy.Name()].Errors++
                return
        }</span>
        
        // Find peers
        <span class="cov0" title="0">peerChan, err := strategy.FindPeers(d.ctx, "ollamacron", discovery.Limit(50))
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to find peers on %s: %v", strategy.Name(), err)
                d.metrics.StrategyMetrics[strategy.Name()].Errors++
                return
        }</span>
        
        // Process found peers
        <span class="cov0" title="0">peersFound := 0
        for peer := range peerChan </span><span class="cov0" title="0">{
                // Skip ourselves
                if peer.ID == d.host.ID() </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                // Add to cache
                <span class="cov0" title="0">d.peerCache.Add(peer, strategy.Name())
                
                // Send to event channel
                select </span>{
                case d.peerFound &lt;- peer:<span class="cov0" title="0">
                        peersFound++</span>
                case &lt;-d.ctx.Done():<span class="cov0" title="0">
                        return</span>
                }
        }
        
        // Update metrics
        <span class="cov0" title="0">metrics := d.metrics.StrategyMetrics[strategy.Name()]
        metrics.PeersFound += peersFound
        metrics.LastSuccess = time.Now()
        metrics.AverageLatency = time.Since(start)
        
        if peersFound &gt; 0 </span><span class="cov0" title="0">{
                log.Printf("Found %d peers using %s strategy", peersFound, strategy.Name())
        }</span>
}

// processEvents processes discovery events
func (d *DiscoveryEngine) processEvents() <span class="cov0" title="0">{
        defer d.wg.Done()
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-d.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case peer := &lt;-d.peerFound:<span class="cov0" title="0">
                        d.handlePeerFound(peer)</span>
                case peerID := &lt;-d.peerLost:<span class="cov0" title="0">
                        d.handlePeerLost(peerID)</span>
                }
        }
}

// handlePeerFound handles peer discovery events
func (d *DiscoveryEngine) handlePeerFound(peer peer.AddrInfo) <span class="cov0" title="0">{
        // Connect to peer if not already connected
        if d.host.Network().Connectedness(peer.ID) != network.Connected </span><span class="cov0" title="0">{
                go func() </span><span class="cov0" title="0">{
                        ctx, cancel := context.WithTimeout(d.ctx, 10*time.Second)
                        defer cancel()
                        
                        if err := d.host.Connect(ctx, peer); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Failed to connect to discovered peer %s: %v", peer.ID, err)
                                return
                        }</span>
                        
                        <span class="cov0" title="0">log.Printf("Connected to discovered peer: %s", peer.ID)</span>
                }()
        }
        
        <span class="cov0" title="0">d.metrics.PeersFound++
        d.metrics.LastDiscovery = time.Now()</span>
}

// handlePeerLost handles peer loss events
func (d *DiscoveryEngine) handlePeerLost(peerID peer.ID) <span class="cov0" title="0">{
        d.peerCache.Remove(peerID)
        d.metrics.PeersLost++
        log.Printf("Peer lost: %s", peerID)
}</span>

// collectMetrics collects discovery metrics
func (d *DiscoveryEngine) collectMetrics() <span class="cov0" title="0">{
        defer d.wg.Done()
        
        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-d.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        d.updateMetrics()</span>
                }
        }
}

// updateMetrics updates discovery metrics
func (d *DiscoveryEngine) updateMetrics() <span class="cov0" title="0">{
        d.metrics.ActivePeers = len(d.host.Network().Peers())
}</span>

// GetMetrics returns discovery metrics
func (d *DiscoveryEngine) GetMetrics() *DiscoveryMetrics <span class="cov0" title="0">{
        return d.metrics
}</span>

// GetDHT returns the DHT instance
func (d *DiscoveryEngine) GetDHT() *dht.IpfsDHT <span class="cov0" title="0">{
        return d.dht
}</span>

// Stop stops the discovery engine
func (d *DiscoveryEngine) Stop() <span class="cov0" title="0">{
        log.Printf("Stopping discovery engine")
        d.cancel()
        d.wg.Wait()
        
        if d.dht != nil </span><span class="cov0" title="0">{
                d.dht.Close()
        }</span>
        
        <span class="cov0" title="0">log.Printf("Discovery engine stopped")</span>
}

// mdnsNotifee handles mDNS notifications
type mdnsNotifee struct {
        peerFound chan peer.AddrInfo
}

func (n *mdnsNotifee) HandlePeerFound(peer peer.AddrInfo) <span class="cov0" title="0">{
        select </span>{
        case n.peerFound &lt;- peer:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0"></span>
                // Channel full, drop event
        }
}

// NewPeerCache creates a new peer cache
func NewPeerCache(maxSize int, ttl time.Duration) *PeerCache <span class="cov0" title="0">{
        return &amp;PeerCache{
                peers:           make(map[peer.ID]*CachedPeer),
                maxSize:         maxSize,
                ttl:             ttl,
                cleanupInterval: ttl / 2,
        }
}</span>

// Add adds a peer to the cache
func (c *PeerCache) Add(peer peer.AddrInfo, source string) <span class="cov0" title="0">{
        c.peersMux.Lock()
        defer c.peersMux.Unlock()
        
        now := time.Now()
        cachedPeer := &amp;CachedPeer{
                AddrInfo:     peer,
                DiscoveredAt: now,
                LastSeen:     now,
                Source:       source,
        }
        
        c.peers[peer.ID] = cachedPeer
        
        // Cleanup if cache is full
        if len(c.peers) &gt; c.maxSize </span><span class="cov0" title="0">{
                c.cleanup()
        }</span>
}

// Remove removes a peer from the cache
func (c *PeerCache) Remove(peerID peer.ID) <span class="cov0" title="0">{
        c.peersMux.Lock()
        defer c.peersMux.Unlock()
        
        delete(c.peers, peerID)
}</span>

// Get retrieves a peer from the cache
func (c *PeerCache) Get(peerID peer.ID) (*CachedPeer, bool) <span class="cov0" title="0">{
        c.peersMux.RLock()
        defer c.peersMux.RUnlock()
        
        peer, exists := c.peers[peerID]
        if !exists </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        
        // Check if expired
        <span class="cov0" title="0">if time.Since(peer.LastSeen) &gt; c.ttl </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        
        <span class="cov0" title="0">return peer, true</span>
}

// cleanup removes expired peers from cache
func (c *PeerCache) cleanup() <span class="cov0" title="0">{
        now := time.Now()
        
        for id, peer := range c.peers </span><span class="cov0" title="0">{
                if now.Sub(peer.LastSeen) &gt; c.ttl </span><span class="cov0" title="0">{
                        delete(c.peers, id)
                }</span>
        }
}

// start starts the peer cache cleanup routine
func (c *PeerCache) start(ctx context.Context, wg *sync.WaitGroup) <span class="cov0" title="0">{
        defer wg.Done()
        
        ticker := time.NewTicker(c.cleanupInterval)
        defer ticker.Stop()
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        c.peersMux.Lock()
                        c.cleanup()
                        c.peersMux.Unlock()</span>
                }
        }
}

// Helper functions to work with DiscoveryConfig interface

// isDHTEnabled checks if DHT is enabled in the configuration
func isDHTEnabled(config DiscoveryConfig) bool <span class="cov0" title="0">{
        // Use reflection to check for EnableDHT field
        // For now, default to true since DHT is generally enabled
        return true
}</span>

// getDHTMode gets the DHT mode from the configuration
func getDHTMode(config DiscoveryConfig) string <span class="cov0" title="0">{
        // Use reflection to check for DHTMode field
        // For now, default to auto mode
        return "auto"
}</span>

// parseBootstrapPeers parses bootstrap peer addresses from the configuration
func parseBootstrapPeers(config DiscoveryConfig) ([]peer.AddrInfo, error) <span class="cov0" title="0">{
        bootstrapAddrs := config.GetBootstrapPeers()
        var peers []peer.AddrInfo
        
        for _, addr := range bootstrapAddrs </span><span class="cov0" title="0">{
                maddr, err := multiaddr.NewMultiaddr(addr)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Invalid bootstrap address %s: %v", addr, err)
                        continue</span>
                }
                
                <span class="cov0" title="0">peerInfo, err := peer.AddrInfoFromP2pAddr(maddr)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to parse peer info from %s: %v", addr, err)
                        continue</span>
                }
                
                <span class="cov0" title="0">peers = append(peers, *peerInfo)</span>
        }
        
        <span class="cov0" title="0">return peers, nil</span>
}</pre>
		
		<pre class="file" id="file19" style="display: none">package discovery

import (
        "context"
        "fmt"
        "log"
        "sync"
        "time"

        "github.com/libp2p/go-libp2p/core/discovery"
        "github.com/libp2p/go-libp2p/core/host"
        "github.com/libp2p/go-libp2p/core/network"
        "github.com/libp2p/go-libp2p/core/peer"
        "github.com/libp2p/go-libp2p/p2p/discovery/mdns"
        "github.com/libp2p/go-libp2p/p2p/discovery/routing"
        dht "github.com/libp2p/go-libp2p-kad-dht"
)

// DHTStrategy implements DHT-based discovery
type DHTStrategy struct {
        dht     *dht.IpfsDHT
        routing *routing.RoutingDiscovery
}

// Name returns the strategy name
func (d *DHTStrategy) Name() string <span class="cov0" title="0">{
        return "dht"
}</span>

// FindPeers finds peers using DHT
func (d *DHTStrategy) FindPeers(ctx context.Context, ns string, opts ...discovery.Option) (&lt;-chan peer.AddrInfo, error) <span class="cov0" title="0">{
        return d.routing.FindPeers(ctx, ns, opts...)
}</span>

// Advertise advertises our presence in DHT
func (d *DHTStrategy) Advertise(ctx context.Context, ns string, opts ...discovery.Option) (time.Duration, error) <span class="cov0" title="0">{
        return d.routing.Advertise(ctx, ns, opts...)
}</span>

// MDNSStrategy implements mDNS-based discovery
type MDNSStrategy struct {
        service mdns.Service
}

// Name returns the strategy name
func (m *MDNSStrategy) Name() string <span class="cov0" title="0">{
        return "mdns"
}</span>

// FindPeers finds peers using mDNS
func (m *MDNSStrategy) FindPeers(ctx context.Context, ns string, opts ...discovery.Option) (&lt;-chan peer.AddrInfo, error) <span class="cov0" title="0">{
        // mDNS discovery is passive - peers are found via notifications
        peerChan := make(chan peer.AddrInfo)
        close(peerChan)
        return peerChan, nil
}</span>

// Advertise advertises our presence via mDNS
func (m *MDNSStrategy) Advertise(ctx context.Context, ns string, opts ...discovery.Option) (time.Duration, error) <span class="cov0" title="0">{
        // mDNS advertising is handled by the service itself
        return 5 * time.Minute, nil
}</span>

// BootstrapDiscovery implements bootstrap peer discovery
type BootstrapDiscovery struct {
        host            host.Host
        bootstrapPeers  []peer.AddrInfo
        minPeers        int
        maxPeers        int
        
        // Connection tracking
        connections     map[peer.ID]*ConnectionInfo
        connectionsMux  sync.RWMutex
}

// ConnectionInfo tracks connection information
type ConnectionInfo struct {
        ConnectedAt time.Time
        LastSeen    time.Time
        Attempts    int
        Failures    int
}

// NewBootstrapDiscovery creates a new bootstrap discovery strategy
func NewBootstrapDiscovery(host host.Host, bootstrapPeers []peer.AddrInfo, minPeers, maxPeers int) *BootstrapDiscovery <span class="cov0" title="0">{
        return &amp;BootstrapDiscovery{
                host:           host,
                bootstrapPeers: bootstrapPeers,
                minPeers:       minPeers,
                maxPeers:       maxPeers,
                connections:    make(map[peer.ID]*ConnectionInfo),
        }
}</span>

// Name returns the strategy name
func (b *BootstrapDiscovery) Name() string <span class="cov0" title="0">{
        return "bootstrap"
}</span>

// FindPeers finds peers from bootstrap list
func (b *BootstrapDiscovery) FindPeers(ctx context.Context, ns string, opts ...discovery.Option) (&lt;-chan peer.AddrInfo, error) <span class="cov0" title="0">{
        peerChan := make(chan peer.AddrInfo, len(b.bootstrapPeers))
        
        go func() </span><span class="cov0" title="0">{
                defer close(peerChan)
                
                for _, peer := range b.bootstrapPeers </span><span class="cov0" title="0">{
                        select </span>{
                        case peerChan &lt;- peer:<span class="cov0" title="0"></span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()
        
        <span class="cov0" title="0">return peerChan, nil</span>
}

// Advertise advertises to bootstrap peers
func (b *BootstrapDiscovery) Advertise(ctx context.Context, ns string, opts ...discovery.Option) (time.Duration, error) <span class="cov0" title="0">{
        // Bootstrap peers don't need advertisement
        return 5 * time.Minute, nil
}</span>

// Start starts the bootstrap discovery process
func (b *BootstrapDiscovery) Start(ctx context.Context, wg *sync.WaitGroup) <span class="cov0" title="0">{
        defer wg.Done()
        
        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        b.ensureConnections(ctx)</span>
                }
        }
}

// ensureConnections ensures minimum connection requirements
func (b *BootstrapDiscovery) ensureConnections(ctx context.Context) <span class="cov0" title="0">{
        connected := len(b.host.Network().Peers())
        
        if connected &lt; b.minPeers </span><span class="cov0" title="0">{
                // Connect to more bootstrap peers
                for _, peer := range b.bootstrapPeers </span><span class="cov0" title="0">{
                        if connected &gt;= b.maxPeers </span><span class="cov0" title="0">{
                                break</span>
                        }
                        
                        // Skip if already connected
                        <span class="cov0" title="0">if b.host.Network().Connectedness(peer.ID) == network.Connected </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        
                        // Skip if too many recent failures
                        <span class="cov0" title="0">b.connectionsMux.RLock()
                        connInfo, exists := b.connections[peer.ID]
                        b.connectionsMux.RUnlock()
                        
                        if exists &amp;&amp; connInfo.Failures &gt; 5 &amp;&amp; time.Since(connInfo.LastSeen) &lt; 5*time.Minute </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        
                        <span class="cov0" title="0">go b.connectToPeer(ctx, peer)
                        connected++</span>
                }
        }
}

// connectToPeer connects to a bootstrap peer
func (b *BootstrapDiscovery) connectToPeer(ctx context.Context, peer peer.AddrInfo) <span class="cov0" title="0">{
        b.connectionsMux.Lock()
        connInfo, exists := b.connections[peer.ID]
        if !exists </span><span class="cov0" title="0">{
                connInfo = &amp;ConnectionInfo{}
                b.connections[peer.ID] = connInfo
        }</span>
        <span class="cov0" title="0">connInfo.Attempts++
        b.connectionsMux.Unlock()
        
        connectCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
        defer cancel()
        
        if err := b.host.Connect(connectCtx, peer); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to connect to bootstrap peer %s: %v", peer.ID, err)
                
                b.connectionsMux.Lock()
                connInfo.Failures++
                connInfo.LastSeen = time.Now()
                b.connectionsMux.Unlock()
                return
        }</span>
        
        <span class="cov0" title="0">log.Printf("Connected to bootstrap peer: %s", peer.ID)
        
        b.connectionsMux.Lock()
        connInfo.ConnectedAt = time.Now()
        connInfo.LastSeen = time.Now()
        b.connectionsMux.Unlock()</span>
}

// RendezvousDiscovery implements rendezvous-based discovery
type RendezvousDiscovery struct {
        host      host.Host
        dht       *dht.IpfsDHT
        routing   *routing.RoutingDiscovery
        
        // Rendezvous points
        rendezvous map[string]*RendezvousPoint
        rendMux    sync.RWMutex
}

// RendezvousPoint represents a rendezvous point
type RendezvousPoint struct {
        Namespace   string
        TTL         time.Duration
        LastUpdate  time.Time
        PeerCount   int
}

// NewRendezvousDiscovery creates a new rendezvous discovery strategy
func NewRendezvousDiscovery(host host.Host, dht *dht.IpfsDHT) *RendezvousDiscovery <span class="cov0" title="0">{
        return &amp;RendezvousDiscovery{
                host:       host,
                dht:        dht,
                routing:    routing.NewRoutingDiscovery(dht),
                rendezvous: make(map[string]*RendezvousPoint),
        }
}</span>

// Name returns the strategy name
func (r *RendezvousDiscovery) Name() string <span class="cov0" title="0">{
        return "rendezvous"
}</span>

// FindPeers finds peers at rendezvous points
func (r *RendezvousDiscovery) FindPeers(ctx context.Context, ns string, opts ...discovery.Option) (&lt;-chan peer.AddrInfo, error) <span class="cov0" title="0">{
        // Create rendezvous namespaces
        rendezvousPoints := []string{
                fmt.Sprintf("%s/general", ns),
                fmt.Sprintf("%s/models", ns),
                fmt.Sprintf("%s/compute", ns),
        }
        
        peerChan := make(chan peer.AddrInfo, 100)
        
        go func() </span><span class="cov0" title="0">{
                defer close(peerChan)
                
                for _, rdv := range rendezvousPoints </span><span class="cov0" title="0">{
                        peerStream, err := r.routing.FindPeers(ctx, rdv, opts...)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Failed to find peers at rendezvous %s: %v", rdv, err)
                                continue</span>
                        }
                        
                        <span class="cov0" title="0">for peer := range peerStream </span><span class="cov0" title="0">{
                                select </span>{
                                case peerChan &lt;- peer:<span class="cov0" title="0"></span>
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return</span>
                                }
                        }
                }
        }()
        
        <span class="cov0" title="0">return peerChan, nil</span>
}

// Advertise advertises at rendezvous points
func (r *RendezvousDiscovery) Advertise(ctx context.Context, ns string, opts ...discovery.Option) (time.Duration, error) <span class="cov0" title="0">{
        // Advertise at multiple rendezvous points
        rendezvousPoints := []string{
                fmt.Sprintf("%s/general", ns),
                fmt.Sprintf("%s/models", ns),
                fmt.Sprintf("%s/compute", ns),
        }
        
        var minTTL time.Duration
        
        for _, rdv := range rendezvousPoints </span><span class="cov0" title="0">{
                ttl, err := r.routing.Advertise(ctx, rdv, opts...)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to advertise at rendezvous %s: %v", rdv, err)
                        continue</span>
                }
                
                // Track rendezvous point
                <span class="cov0" title="0">r.rendMux.Lock()
                r.rendezvous[rdv] = &amp;RendezvousPoint{
                        Namespace:  rdv,
                        TTL:        ttl,
                        LastUpdate: time.Now(),
                }
                r.rendMux.Unlock()
                
                if minTTL == 0 || ttl &lt; minTTL </span><span class="cov0" title="0">{
                        minTTL = ttl
                }</span>
                
                <span class="cov0" title="0">log.Printf("Advertised at rendezvous point: %s (TTL: %v)", rdv, ttl)</span>
        }
        
        <span class="cov0" title="0">if minTTL == 0 </span><span class="cov0" title="0">{
                return 5 * time.Minute, nil
        }</span>
        
        <span class="cov0" title="0">return minTTL, nil</span>
}

// GetRendezvousPoints returns active rendezvous points
func (r *RendezvousDiscovery) GetRendezvousPoints() map[string]*RendezvousPoint <span class="cov0" title="0">{
        r.rendMux.RLock()
        defer r.rendMux.RUnlock()
        
        points := make(map[string]*RendezvousPoint)
        for k, v := range r.rendezvous </span><span class="cov0" title="0">{
                points[k] = v
        }</span>
        
        <span class="cov0" title="0">return points</span>
}

// CustomDiscovery implements custom discovery strategies
type CustomDiscovery struct {
        host     host.Host
        name     string
        finder   func(context.Context, string, ...discovery.Option) (&lt;-chan peer.AddrInfo, error)
        advertiser func(context.Context, string, ...discovery.Option) (time.Duration, error)
}

// NewCustomDiscovery creates a new custom discovery strategy
func NewCustomDiscovery(
        host host.Host,
        name string,
        finder func(context.Context, string, ...discovery.Option) (&lt;-chan peer.AddrInfo, error),
        advertiser func(context.Context, string, ...discovery.Option) (time.Duration, error),
) *CustomDiscovery <span class="cov0" title="0">{
        return &amp;CustomDiscovery{
                host:       host,
                name:       name,
                finder:     finder,
                advertiser: advertiser,
        }
}</span>

// Name returns the strategy name
func (c *CustomDiscovery) Name() string <span class="cov0" title="0">{
        return c.name
}</span>

// FindPeers finds peers using custom logic
func (c *CustomDiscovery) FindPeers(ctx context.Context, ns string, opts ...discovery.Option) (&lt;-chan peer.AddrInfo, error) <span class="cov0" title="0">{
        if c.finder == nil </span><span class="cov0" title="0">{
                peerChan := make(chan peer.AddrInfo)
                close(peerChan)
                return peerChan, nil
        }</span>
        
        <span class="cov0" title="0">return c.finder(ctx, ns, opts...)</span>
}

// Advertise advertises using custom logic
func (c *CustomDiscovery) Advertise(ctx context.Context, ns string, opts ...discovery.Option) (time.Duration, error) <span class="cov0" title="0">{
        if c.advertiser == nil </span><span class="cov0" title="0">{
                return 5 * time.Minute, nil
        }</span>
        
        <span class="cov0" title="0">return c.advertiser(ctx, ns, opts...)</span>
}

// HybridDiscovery combines multiple discovery strategies
type HybridDiscovery struct {
        strategies []DiscoveryStrategy
        weights    map[string]float64
        
        // Load balancing
        lastUsed   map[string]time.Time
        usageCount map[string]int
}

// NewHybridDiscovery creates a new hybrid discovery strategy
func NewHybridDiscovery(strategies []DiscoveryStrategy) *HybridDiscovery <span class="cov0" title="0">{
        weights := make(map[string]float64)
        lastUsed := make(map[string]time.Time)
        usageCount := make(map[string]int)
        
        // Initialize equal weights
        for _, strategy := range strategies </span><span class="cov0" title="0">{
                weights[strategy.Name()] = 1.0
                lastUsed[strategy.Name()] = time.Now()
                usageCount[strategy.Name()] = 0
        }</span>
        
        <span class="cov0" title="0">return &amp;HybridDiscovery{
                strategies: strategies,
                weights:    weights,
                lastUsed:   lastUsed,
                usageCount: usageCount,
        }</span>
}

// Name returns the strategy name
func (h *HybridDiscovery) Name() string <span class="cov0" title="0">{
        return "hybrid"
}</span>

// FindPeers finds peers using multiple strategies
func (h *HybridDiscovery) FindPeers(ctx context.Context, ns string, opts ...discovery.Option) (&lt;-chan peer.AddrInfo, error) <span class="cov0" title="0">{
        peerChan := make(chan peer.AddrInfo, 100)
        
        go func() </span><span class="cov0" title="0">{
                defer close(peerChan)
                
                var wg sync.WaitGroup
                
                // Run all strategies in parallel
                for _, strategy := range h.strategies </span><span class="cov0" title="0">{
                        wg.Add(1)
                        go func(s DiscoveryStrategy) </span><span class="cov0" title="0">{
                                defer wg.Done()
                                
                                strategyPeers, err := s.FindPeers(ctx, ns, opts...)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Strategy %s failed: %v", s.Name(), err)
                                        return
                                }</span>
                                
                                <span class="cov0" title="0">for peer := range strategyPeers </span><span class="cov0" title="0">{
                                        select </span>{
                                        case peerChan &lt;- peer:<span class="cov0" title="0">
                                                h.usageCount[s.Name()]++</span>
                                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                                return</span>
                                        }
                                }
                        }(strategy)
                }
                
                <span class="cov0" title="0">wg.Wait()</span>
        }()
        
        <span class="cov0" title="0">return peerChan, nil</span>
}

// Advertise advertises using all strategies
func (h *HybridDiscovery) Advertise(ctx context.Context, ns string, opts ...discovery.Option) (time.Duration, error) <span class="cov0" title="0">{
        var minTTL time.Duration
        var lastErr error
        
        for _, strategy := range h.strategies </span><span class="cov0" title="0">{
                ttl, err := strategy.Advertise(ctx, ns, opts...)
                if err != nil </span><span class="cov0" title="0">{
                        lastErr = err
                        continue</span>
                }
                
                <span class="cov0" title="0">h.lastUsed[strategy.Name()] = time.Now()
                
                if minTTL == 0 || ttl &lt; minTTL </span><span class="cov0" title="0">{
                        minTTL = ttl
                }</span>
        }
        
        <span class="cov0" title="0">if minTTL == 0 </span><span class="cov0" title="0">{
                return 5 * time.Minute, lastErr
        }</span>
        
        <span class="cov0" title="0">return minTTL, nil</span>
}

// UpdateWeights updates strategy weights based on performance
func (h *HybridDiscovery) UpdateWeights(performance map[string]float64) <span class="cov0" title="0">{
        for strategy, weight := range performance </span><span class="cov0" title="0">{
                if _, exists := h.weights[strategy]; exists </span><span class="cov0" title="0">{
                        h.weights[strategy] = weight
                }</span>
        }
}

// GetWeights returns current strategy weights
func (h *HybridDiscovery) GetWeights() map[string]float64 <span class="cov0" title="0">{
        weights := make(map[string]float64)
        for k, v := range h.weights </span><span class="cov0" title="0">{
                weights[k] = v
        }</span>
        <span class="cov0" title="0">return weights</span>
}

// GetUsageStats returns usage statistics
func (h *HybridDiscovery) GetUsageStats() map[string]interface{} <span class="cov0" title="0">{
        stats := make(map[string]interface{})
        
        for strategy := range h.weights </span><span class="cov0" title="0">{
                stats[strategy] = map[string]interface{}{
                        "weight":     h.weights[strategy],
                        "last_used":  h.lastUsed[strategy],
                        "usage_count": h.usageCount[strategy],
                }
        }</span>
        
        <span class="cov0" title="0">return stats</span>
}</pre>
		
		<pre class="file" id="file20" style="display: none">package host

import (
        "context"
        "fmt"
        "log"
        "time"

        "github.com/libp2p/go-libp2p"
        "github.com/libp2p/go-libp2p/core/crypto"
        "github.com/libp2p/go-libp2p/core/host"
        "github.com/libp2p/go-libp2p/core/network"
        "github.com/libp2p/go-libp2p/core/peer"
        "github.com/libp2p/go-libp2p/core/protocol"
        "github.com/libp2p/go-libp2p/p2p/net/connmgr"
        "github.com/libp2p/go-libp2p/p2p/protocol/circuitv2/relay"
        "github.com/libp2p/go-libp2p/p2p/security/noise"
        libp2ptls "github.com/libp2p/go-libp2p/p2p/security/tls"
        "github.com/libp2p/go-libp2p/p2p/transport/tcp"
        "github.com/libp2p/go-libp2p/p2p/transport/websocket"
        libp2pwebtransport "github.com/libp2p/go-libp2p/p2p/transport/webtransport"
        "github.com/multiformats/go-multiaddr"
        
        "github.com/ollama/ollama-distributed/pkg/config"
)

// P2PHost wraps libp2p host with enhanced functionality
type P2PHost struct {
        host.Host
        config         *config.NodeConfig
        capabilities   *config.NodeCapabilities
        relayService   *relay.Relay
        
        // Protocol handlers
        protocols      map[protocol.ID]network.StreamHandler
        
        // Event handlers
        connectHandler    func(network.Network, network.Conn)
        disconnectHandler func(network.Network, network.Conn)
        
        // Metrics
        metrics        *HostMetrics
        
        // Lifecycle
        ctx            context.Context
        cancel         context.CancelFunc
}

// HostMetrics tracks host performance metrics
type HostMetrics struct {
        ConnectionCount    int
        StreamCount        int
        BytesReceived      int64
        BytesSent          int64
        ProtocolHandlers   int
        LastActivity       time.Time
        StartTime          time.Time
}

// NewP2PHost creates a new enhanced P2P host
func NewP2PHost(ctx context.Context, config *config.NodeConfig) (*P2PHost, error) <span class="cov0" title="0">{
        // Load or generate private key
        priv, err := loadOrGenerateKey(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize key: %w", err)
        }</span>
        
        // Build listen addresses
        <span class="cov0" title="0">listenAddrs := make([]multiaddr.Multiaddr, 0, len(config.Listen))
        for _, addr := range config.Listen </span><span class="cov0" title="0">{
                maddr, err := multiaddr.NewMultiaddr(addr)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Invalid listen address %s: %v", addr, err)
                        continue</span>
                }
                <span class="cov0" title="0">listenAddrs = append(listenAddrs, maddr)</span>
        }
        
        // Configure transports
        <span class="cov0" title="0">transports := []libp2p.Option{
                libp2p.Transport(tcp.NewTCPTransport),
                libp2p.Transport(websocket.New),
                libp2p.Transport(libp2pwebtransport.New),
        }
        
        // Configure security
        security := []libp2p.Option{}
        if config.EnableNoise </span><span class="cov0" title="0">{
                security = append(security, libp2p.Security(noise.ID, noise.New))
        }</span>
        <span class="cov0" title="0">if config.EnableTLS </span><span class="cov0" title="0">{
                security = append(security, libp2p.Security(libp2ptls.ID, libp2ptls.New))
        }</span>
        
        // Configure NAT traversal
        <span class="cov0" title="0">natOptions := []libp2p.Option{}
        if config.EnableNATService </span><span class="cov0" title="0">{
                natOptions = append(natOptions, libp2p.EnableNATService())
        }</span>
        <span class="cov0" title="0">if config.EnableHolePunching </span><span class="cov0" title="0">{
                natOptions = append(natOptions, libp2p.EnableHolePunching())
        }</span>
        <span class="cov0" title="0">if config.EnableAutoRelay </span><span class="cov0" title="0">{
                staticRelays, err := config.ParseStaticRelays()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse static relays: %w", err)
                }</span>
                <span class="cov0" title="0">natOptions = append(natOptions, libp2p.EnableAutoRelayWithStaticRelays(staticRelays))</span>
        }
        
        // Configure connection manager
        <span class="cov0" title="0">connMgr, err := connmgr.NewConnManager(
                config.ConnMgrLow,
                config.ConnMgrHigh,
                connmgr.WithGracePeriod(config.ConnMgrGrace),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create connection manager: %w", err)
        }</span>
        
        // Build host options
        <span class="cov0" title="0">opts := []libp2p.Option{
                libp2p.Identity(priv),
                libp2p.ListenAddrs(listenAddrs...),
                libp2p.ConnectionManager(connMgr),
                libp2p.EnableRelay(),
        }
        
        // Add transport options
        opts = append(opts, transports...)
        opts = append(opts, security...)
        opts = append(opts, natOptions...)
        
        // Add announce addresses
        if len(config.AnnounceAddresses) &gt; 0 </span><span class="cov0" title="0">{
                announceAddrs := make([]multiaddr.Multiaddr, 0, len(config.AnnounceAddresses))
                for _, addr := range config.AnnounceAddresses </span><span class="cov0" title="0">{
                        maddr, err := multiaddr.NewMultiaddr(addr)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Invalid announce address %s: %v", addr, err)
                                continue</span>
                        }
                        <span class="cov0" title="0">announceAddrs = append(announceAddrs, maddr)</span>
                }
                <span class="cov0" title="0">opts = append(opts, libp2p.AddrsFactory(func([]multiaddr.Multiaddr) []multiaddr.Multiaddr </span><span class="cov0" title="0">{
                        return announceAddrs
                }</span>))
        }
        
        // Create host
        <span class="cov0" title="0">libp2pHost, err := libp2p.New(opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create libp2p host: %w", err)
        }</span>
        
        // Create enhanced host wrapper
        <span class="cov0" title="0">ctx, cancel := context.WithCancel(ctx)
        p2pHost := &amp;P2PHost{
                Host:      libp2pHost,
                config:    config,
                protocols: make(map[protocol.ID]network.StreamHandler),
                metrics: &amp;HostMetrics{
                        StartTime: time.Now(),
                },
                ctx:    ctx,
                cancel: cancel,
        }
        
        // Setup network event handlers
        p2pHost.setupEventHandlers()
        
        // Start metrics collection
        go p2pHost.collectMetrics()
        
        log.Printf("P2P host created with ID: %s", libp2pHost.ID())
        log.Printf("Listen addresses: %v", libp2pHost.Addrs())
        
        return p2pHost, nil</span>
}

// setupEventHandlers configures network event handlers
func (h *P2PHost) setupEventHandlers() <span class="cov0" title="0">{
        net := h.Host.Network()
        
        // Connection events
        notifee := &amp;network.NotifyBundle{
                ConnectedF: func(net network.Network, conn network.Conn) </span><span class="cov0" title="0">{
                        h.metrics.ConnectionCount++
                        h.metrics.LastActivity = time.Now()
                        log.Printf("Connected to peer: %s", conn.RemotePeer())
                        
                        if h.connectHandler != nil </span><span class="cov0" title="0">{
                                h.connectHandler(net, conn)
                        }</span>
                },
                DisconnectedF: func(net network.Network, conn network.Conn) <span class="cov0" title="0">{
                        h.metrics.ConnectionCount--
                        h.metrics.LastActivity = time.Now()
                        log.Printf("Disconnected from peer: %s", conn.RemotePeer())
                        
                        if h.disconnectHandler != nil </span><span class="cov0" title="0">{
                                h.disconnectHandler(net, conn)
                        }</span>
                },
        }
        
        <span class="cov0" title="0">net.Notify(notifee)</span>
}

// collectMetrics periodically collects host metrics
func (h *P2PHost) collectMetrics() <span class="cov0" title="0">{
        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-h.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        h.updateMetrics()</span>
                }
        }
}

// updateMetrics updates host metrics
func (h *P2PHost) updateMetrics() <span class="cov0" title="0">{
        network := h.Host.Network()
        
        // Update connection count
        h.metrics.ConnectionCount = len(network.Peers())
        
        // Update stream count
        streamCount := 0
        for _, peer := range network.Peers() </span><span class="cov0" title="0">{
                streams := network.ConnsToPeer(peer)
                for _, conn := range streams </span><span class="cov0" title="0">{
                        streamCount += len(conn.GetStreams())
                }</span>
        }
        <span class="cov0" title="0">h.metrics.StreamCount = streamCount
        
        // Update protocol handler count
        h.metrics.ProtocolHandlers = len(h.protocols)
        
        h.metrics.LastActivity = time.Now()</span>
}

// RegisterProtocol registers a protocol handler
func (h *P2PHost) RegisterProtocol(protocolID protocol.ID, handler network.StreamHandler) <span class="cov0" title="0">{
        h.Host.SetStreamHandler(protocolID, handler)
        h.protocols[protocolID] = handler
        log.Printf("Registered protocol: %s", protocolID)
}</span>

// UnregisterProtocol unregisters a protocol handler
func (h *P2PHost) UnregisterProtocol(protocolID protocol.ID) <span class="cov0" title="0">{
        h.Host.RemoveStreamHandler(protocolID)
        delete(h.protocols, protocolID)
        log.Printf("Unregistered protocol: %s", protocolID)
}</span>

// GetMetrics returns current host metrics
func (h *P2PHost) GetMetrics() *HostMetrics <span class="cov0" title="0">{
        return h.metrics
}</span>

// GetConfig returns host configuration
func (h *P2PHost) GetConfig() *config.NodeConfig <span class="cov0" title="0">{
        return h.config
}</span>

// SetCapabilities sets node capabilities
func (h *P2PHost) SetCapabilities(caps interface{}) <span class="cov0" title="0">{
        // Accept both config.NodeCapabilities and resources.NodeCapabilities
        switch v := caps.(type) </span>{
        case *config.NodeCapabilities:<span class="cov0" title="0">
                h.capabilities = v</span>
        default:<span class="cov0" title="0">
                // For resources.NodeCapabilities, we don't store them directly
                // as they're managed by the resource layer
                log.Printf("Setting capabilities of type %T", caps)</span>
        }
}

// GetCapabilities returns node capabilities
func (h *P2PHost) GetCapabilities() *config.NodeCapabilities <span class="cov0" title="0">{
        return h.capabilities
}</span>

// OnConnect sets connection event handler
func (h *P2PHost) OnConnect(handler func(network.Network, network.Conn)) <span class="cov0" title="0">{
        h.connectHandler = handler
}</span>

// OnDisconnect sets disconnection event handler
func (h *P2PHost) OnDisconnect(handler func(network.Network, network.Conn)) <span class="cov0" title="0">{
        h.disconnectHandler = handler
}</span>

// Close closes the host and releases resources
func (h *P2PHost) Close() error <span class="cov0" title="0">{
        h.cancel()
        return h.Host.Close()
}</span>

// loadOrGenerateKey loads existing key or generates new one
func loadOrGenerateKey(config *config.NodeConfig) (crypto.PrivKey, error) <span class="cov0" title="0">{
        // Try to load existing key
        if config.PrivateKey != "" </span><span class="cov0" title="0">{
                return config.GetPrivateKey()
        }</span>
        
        // Generate new key
        <span class="cov0" title="0">if err := config.GenerateKey(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate key: %w", err)
        }</span>
        
        <span class="cov0" title="0">return config.GetPrivateKey()</span>
}

// GetPeerCount returns number of connected peers
func (h *P2PHost) GetPeerCount() int <span class="cov0" title="0">{
        return len(h.Host.Network().Peers())
}</span>

// GetConnectedPeers returns list of connected peers
func (h *P2PHost) GetConnectedPeers() []peer.ID <span class="cov0" title="0">{
        return h.Host.Network().Peers()
}</span>

// IsConnected checks if peer is connected
func (h *P2PHost) IsConnected(peerID peer.ID) bool <span class="cov0" title="0">{
        return h.Host.Network().Connectedness(peerID) == network.Connected
}</span>

// GetProtocols returns registered protocols
func (h *P2PHost) GetProtocols() []protocol.ID <span class="cov0" title="0">{
        protocols := make([]protocol.ID, 0, len(h.protocols))
        for id := range h.protocols </span><span class="cov0" title="0">{
                protocols = append(protocols, id)
        }</span>
        <span class="cov0" title="0">return protocols</span>
}</pre>
		
		<pre class="file" id="file21" style="display: none">package resources

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "sync"
        "time"

        "github.com/libp2p/go-libp2p/core/host"
        "github.com/libp2p/go-libp2p/core/peer"
        "github.com/libp2p/go-libp2p/core/protocol"
        "github.com/libp2p/go-libp2p/core/network"
        dht "github.com/libp2p/go-libp2p-kad-dht"
)

const (
        // Advertisement protocols
        ResourceAdvertisementProtocol = protocol.ID("/ollamacron/resource-advertisement/1.0.0")
        ResourceDiscoveryProtocol     = protocol.ID("/ollamacron/resource-discovery/1.0.0")
        
        // DHT keys
        ResourceKeyPrefix = "/ollamacron/resources/"
        ModelKeyPrefix    = "/ollamacron/models/"
        NodeKeyPrefix     = "/ollamacron/nodes/"
)

// ResourceAdvertiser manages resource advertisement and discovery
type ResourceAdvertiser struct {
        host           host.Host
        dht            *dht.IpfsDHT
        
        // Resource information
        capabilities   *NodeCapabilities
        resources      *ResourceMetrics
        
        // Advertisement management
        advertisements map[string]*Advertisement
        advMux         sync.RWMutex
        
        // Update channels
        capabilityUpdates chan *NodeCapabilities
        resourceUpdates   chan *ResourceMetrics
        
        // Subscriptions
        subscriptions     map[string]*ResourceSubscription
        subMux           sync.RWMutex
        
        // Discovery cache
        discoveryCache    *DiscoveryCache
        
        // Configuration
        config           *AdvertiserConfig
        
        // Metrics
        metrics          *AdvertiserMetrics
        
        // Lifecycle
        ctx              context.Context
        cancel           context.CancelFunc
        wg               sync.WaitGroup
}

// Advertisement represents a resource advertisement
type Advertisement struct {
        ID            string                `json:"id"`
        NodeID        peer.ID               `json:"node_id"`
        Capabilities  *NodeCapabilities `json:"capabilities"`
        Resources     *ResourceMetrics  `json:"resources"`
        Timestamp     time.Time             `json:"timestamp"`
        TTL           time.Duration         `json:"ttl"`
        Version       int                   `json:"version"`
        Signature     []byte                `json:"signature,omitempty"`
        
        // Advertisement metadata
        Priority      int                   `json:"priority"`
        Tags          map[string]string     `json:"tags"`
        Geo           *GeographicInfo       `json:"geo,omitempty"`
        Availability  *AvailabilityInfo     `json:"availability"`
}

// GeographicInfo contains geographic information
type GeographicInfo struct {
        Country     string  `json:"country"`
        Region      string  `json:"region"`
        City        string  `json:"city"`
        Latitude    float64 `json:"latitude"`
        Longitude   float64 `json:"longitude"`
        Timezone    string  `json:"timezone"`
}

// AvailabilityInfo contains availability information
type AvailabilityInfo struct {
        Online        bool              `json:"online"`
        LastSeen      time.Time         `json:"last_seen"`
        Uptime        time.Duration     `json:"uptime"`
        MaintenanceWindow *TimeWindow   `json:"maintenance_window,omitempty"`
        ServiceLevel  string            `json:"service_level"`
}

// TimeWindow represents a time window
type TimeWindow struct {
        Start time.Time `json:"start"`
        End   time.Time `json:"end"`
}

// ResourceSubscription represents a resource subscription
type ResourceSubscription struct {
        ID            string
        Query         *ResourceQuery
        Callback      func(*Advertisement)
        CreatedAt     time.Time
        LastMatched   time.Time
        MatchCount    int
}

// AdvertiserConfig holds advertiser configuration
type AdvertiserConfig struct {
        AdvertisementInterval time.Duration `json:"advertisement_interval"`
        TTL                   time.Duration `json:"ttl"`
        MaxAdvertisements     int           `json:"max_advertisements"`
        EnableSigning         bool          `json:"enable_signing"`
        EnableGeoLocation     bool          `json:"enable_geo_location"`
        Priority              int           `json:"priority"`
        Tags                  map[string]string `json:"tags"`
}

// AdvertiserMetrics tracks advertiser metrics
type AdvertiserMetrics struct {
        AdvertisementsSent     int
        AdvertisementsReceived int
        DiscoveryQueries       int
        SubscriptionMatches    int
        CacheHits              int
        CacheMisses            int
        LastAdvertisement      time.Time
        LastDiscovery          time.Time
        StartTime              time.Time
}

// NewResourceAdvertiser creates a new resource advertiser
func NewResourceAdvertiser(ctx context.Context, host host.Host, dht *dht.IpfsDHT, config *AdvertiserConfig) (*ResourceAdvertiser, error) <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                config = DefaultAdvertiserConfig()
        }</span>
        
        <span class="cov0" title="0">ctx, cancel := context.WithCancel(ctx)
        
        ra := &amp;ResourceAdvertiser{
                host:              host,
                dht:               dht,
                config:            config,
                advertisements:    make(map[string]*Advertisement),
                capabilityUpdates: make(chan *NodeCapabilities, 10),
                resourceUpdates:   make(chan *ResourceMetrics, 10),
                subscriptions:     make(map[string]*ResourceSubscription),
                metrics: &amp;AdvertiserMetrics{
                        StartTime: time.Now(),
                },
                ctx:    ctx,
                cancel: cancel,
        }
        
        // Initialize discovery cache
        ra.discoveryCache = NewDiscoveryCache(1000, 5*time.Minute)
        
        // Setup protocol handlers
        ra.setupProtocolHandlers()
        
        return ra, nil</span>
}

// setupProtocolHandlers sets up protocol handlers
func (ra *ResourceAdvertiser) setupProtocolHandlers() <span class="cov0" title="0">{
        ra.host.SetStreamHandler(ResourceAdvertisementProtocol, ra.handleResourceAdvertisement)
        ra.host.SetStreamHandler(ResourceDiscoveryProtocol, ra.handleResourceDiscovery)
}</span>

// Start starts the resource advertiser
func (ra *ResourceAdvertiser) Start() <span class="cov0" title="0">{
        log.Printf("Starting resource advertiser")
        
        // Start periodic advertisement
        ra.wg.Add(1)
        go ra.advertisementTask()
        
        // Start update processing
        ra.wg.Add(1)
        go ra.updateProcessor()
        
        // Start metrics collection
        ra.wg.Add(1)
        go ra.metricsTask()
        
        // Start cache cleanup
        ra.wg.Add(1)
        go ra.cacheCleanupTask()
        
        log.Printf("Resource advertiser started")
}</span>

// advertisementTask handles periodic advertisements
func (ra *ResourceAdvertiser) advertisementTask() <span class="cov0" title="0">{
        defer ra.wg.Done()
        
        // Initial advertisement
        ra.advertiseResources()
        
        ticker := time.NewTicker(ra.config.AdvertisementInterval)
        defer ticker.Stop()
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ra.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        ra.advertiseResources()</span>
                }
        }
}

// updateProcessor processes capability and resource updates
func (ra *ResourceAdvertiser) updateProcessor() <span class="cov0" title="0">{
        defer ra.wg.Done()
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ra.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case caps := &lt;-ra.capabilityUpdates:<span class="cov0" title="0">
                        ra.capabilities = caps
                        ra.advertiseResources()</span>
                case metrics := &lt;-ra.resourceUpdates:<span class="cov0" title="0">
                        ra.resources = metrics
                        ra.advertiseResources()</span>
                }
        }
}

// advertiseResources advertises current resources
func (ra *ResourceAdvertiser) advertiseResources() <span class="cov0" title="0">{
        if ra.capabilities == nil </span><span class="cov0" title="0">{
                return
        }</span>
        
        // Create advertisement
        <span class="cov0" title="0">ad := &amp;Advertisement{
                ID:           fmt.Sprintf("%s-%d", ra.host.ID(), time.Now().UnixNano()),
                NodeID:       ra.host.ID(),
                Capabilities: ra.capabilities,
                Resources:    ra.resources,
                Timestamp:    time.Now(),
                TTL:          ra.config.TTL,
                Version:      1,
                Priority:     ra.config.Priority,
                Tags:         ra.config.Tags,
                Availability: &amp;AvailabilityInfo{
                        Online:       true,
                        LastSeen:     time.Now(),
                        Uptime:       time.Since(ra.metrics.StartTime),
                        ServiceLevel: "standard",
                },
        }
        
        // Add geographic info if enabled
        if ra.config.EnableGeoLocation </span><span class="cov0" title="0">{
                ad.Geo = ra.getGeographicInfo()
        }</span>
        
        // Sign advertisement if enabled
        <span class="cov0" title="0">if ra.config.EnableSigning </span><span class="cov0" title="0">{
                signature, err := ra.signAdvertisement(ad)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to sign advertisement: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        ad.Signature = signature
                }</span>
        }
        
        // Store advertisement
        <span class="cov0" title="0">ra.advMux.Lock()
        ra.advertisements[ad.ID] = ad
        ra.advMux.Unlock()
        
        // Publish to DHT
        if err := ra.publishAdvertisement(ad); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to publish advertisement: %v", err)
                return
        }</span>
        
        // Broadcast to interested peers
        <span class="cov0" title="0">ra.broadcastAdvertisement(ad)
        
        // Check subscriptions
        ra.checkSubscriptions(ad)
        
        ra.metrics.AdvertisementsSent++
        ra.metrics.LastAdvertisement = time.Now()
        
        log.Printf("Advertised resources: %d models, %d GPUs, %.2f CPU", 
                len(ra.capabilities.SupportedModels), 
                len(ra.capabilities.GPUs), 
                float64(ra.capabilities.CPUCores))</span>
}

// publishAdvertisement publishes advertisement to DHT
func (ra *ResourceAdvertiser) publishAdvertisement(ad *Advertisement) error <span class="cov0" title="0">{
        // Serialize advertisement
        data, err := json.Marshal(ad)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to serialize advertisement: %w", err)
        }</span>
        
        // Store in DHT with multiple keys for discoverability
        <span class="cov0" title="0">keys := []string{
                fmt.Sprintf("%s%s", ResourceKeyPrefix, ad.NodeID),
                fmt.Sprintf("%s%s", NodeKeyPrefix, ad.NodeID),
        }
        
        // Add model-specific keys
        for _, model := range ad.Capabilities.SupportedModels </span><span class="cov0" title="0">{
                keys = append(keys, fmt.Sprintf("%s%s", ModelKeyPrefix, model))
        }</span>
        
        // Store with all keys
        <span class="cov0" title="0">for _, key := range keys </span><span class="cov0" title="0">{
                if err := ra.dht.PutValue(ra.ctx, key, data); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to store advertisement with key %s: %v", key, err)
                        continue</span>
                }
        }
        
        <span class="cov0" title="0">return nil</span>
}

// broadcastAdvertisement broadcasts advertisement to connected peers
func (ra *ResourceAdvertiser) broadcastAdvertisement(ad *Advertisement) <span class="cov0" title="0">{
        // Get connected peers
        peers := ra.host.Network().Peers()
        
        // Broadcast to random subset to avoid flooding
        maxBroadcast := 10
        if len(peers) &gt; maxBroadcast </span><span class="cov0" title="0">{
                // Randomly select peers
                selected := make([]peer.ID, maxBroadcast)
                for i := 0; i &lt; maxBroadcast; i++ </span><span class="cov0" title="0">{
                        selected[i] = peers[i]
                }</span>
                <span class="cov0" title="0">peers = selected</span>
        }
        
        // Send to selected peers
        <span class="cov0" title="0">for _, peerID := range peers </span><span class="cov0" title="0">{
                go ra.sendAdvertisement(peerID, ad)
        }</span>
}

// sendAdvertisement sends advertisement to a specific peer
func (ra *ResourceAdvertiser) sendAdvertisement(peerID peer.ID, ad *Advertisement) <span class="cov0" title="0">{
        stream, err := ra.host.NewStream(ra.ctx, peerID, ResourceAdvertisementProtocol)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to create stream to peer %s: %v", peerID, err)
                return
        }</span>
        <span class="cov0" title="0">defer stream.Close()
        
        // Send advertisement
        data, err := json.Marshal(ad)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to serialize advertisement: %v", err)
                return
        }</span>
        
        <span class="cov0" title="0">if _, err := stream.Write(data); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to send advertisement to peer %s: %v", peerID, err)
                return
        }</span>
}

// SetCapabilities updates node capabilities
func (ra *ResourceAdvertiser) SetCapabilities(caps *NodeCapabilities) <span class="cov0" title="0">{
        select </span>{
        case ra.capabilityUpdates &lt;- caps:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                // Channel full, update directly
                ra.capabilities = caps
                go ra.advertiseResources()</span>
        }
}

// SetResourceMetrics updates resource metrics
func (ra *ResourceAdvertiser) SetResourceMetrics(metrics *ResourceMetrics) <span class="cov0" title="0">{
        select </span>{
        case ra.resourceUpdates &lt;- metrics:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                // Channel full, update directly
                ra.resources = metrics
                go ra.advertiseResources()</span>
        }
}

// Subscribe creates a subscription for resource updates
func (ra *ResourceAdvertiser) Subscribe(query *ResourceQuery, callback func(*Advertisement)) string <span class="cov0" title="0">{
        ra.subMux.Lock()
        defer ra.subMux.Unlock()
        
        subscriptionID := fmt.Sprintf("sub-%d", time.Now().UnixNano())
        subscription := &amp;ResourceSubscription{
                ID:        subscriptionID,
                Query:     query,
                Callback:  callback,
                CreatedAt: time.Now(),
        }
        
        ra.subscriptions[subscriptionID] = subscription
        
        log.Printf("Created resource subscription: %s", subscriptionID)
        return subscriptionID
}</span>

// Unsubscribe removes a resource subscription
func (ra *ResourceAdvertiser) Unsubscribe(subscriptionID string) <span class="cov0" title="0">{
        ra.subMux.Lock()
        defer ra.subMux.Unlock()
        
        delete(ra.subscriptions, subscriptionID)
        log.Printf("Removed resource subscription: %s", subscriptionID)
}</span>

// checkSubscriptions checks if advertisement matches any subscriptions
func (ra *ResourceAdvertiser) checkSubscriptions(ad *Advertisement) <span class="cov0" title="0">{
        ra.subMux.RLock()
        defer ra.subMux.RUnlock()
        
        for _, sub := range ra.subscriptions </span><span class="cov0" title="0">{
                if ra.matchesQuery(ad, sub.Query) </span><span class="cov0" title="0">{
                        sub.LastMatched = time.Now()
                        sub.MatchCount++
                        ra.metrics.SubscriptionMatches++
                        
                        // Call callback
                        go sub.Callback(ad)
                }</span>
        }
}

// Protocol handlers

// handleResourceAdvertisement handles incoming resource advertisements
func (ra *ResourceAdvertiser) handleResourceAdvertisement(stream network.Stream) <span class="cov0" title="0">{
        defer stream.Close()
        
        // Read advertisement
        buf := make([]byte, 4096)
        n, err := stream.Read(buf)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to read advertisement: %v", err)
                return
        }</span>
        
        <span class="cov0" title="0">var ad Advertisement
        if err := json.Unmarshal(buf[:n], &amp;ad); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to unmarshal advertisement: %v", err)
                return
        }</span>
        
        // Verify advertisement if signed
        <span class="cov0" title="0">if ad.Signature != nil </span><span class="cov0" title="0">{
                if err := ra.verifyAdvertisement(&amp;ad); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Advertisement verification failed: %v", err)
                        return
                }</span>
        }
        
        // Store in cache
        <span class="cov0" title="0">ra.discoveryCache.Store(&amp;ad)
        
        // Check subscriptions
        ra.checkSubscriptions(&amp;ad)
        
        ra.metrics.AdvertisementsReceived++
        
        log.Printf("Received resource advertisement from: %s", ad.NodeID)</span>
}

// handleResourceDiscovery handles resource discovery requests
func (ra *ResourceAdvertiser) handleResourceDiscovery(stream network.Stream) <span class="cov0" title="0">{
        defer stream.Close()
        
        // Read query
        buf := make([]byte, 4096)
        n, err := stream.Read(buf)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to read discovery query: %v", err)
                return
        }</span>
        
        <span class="cov0" title="0">var query ResourceQuery
        if err := json.Unmarshal(buf[:n], &amp;query); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to unmarshal discovery query: %v", err)
                return
        }</span>
        
        // Find matching resources
        <span class="cov0" title="0">results := ra.findMatchingResources(&amp;query)
        
        // Send results
        response := &amp;DiscoveryResponse{
                QueryID:   query.ID,
                Results:   results,
                Timestamp: time.Now(),
        }
        
        data, err := json.Marshal(response)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to serialize discovery response: %v", err)
                return
        }</span>
        
        <span class="cov0" title="0">if _, err := stream.Write(data); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to send discovery response: %v", err)
                return
        }</span>
        
        <span class="cov0" title="0">ra.metrics.DiscoveryQueries++
        
        log.Printf("Processed discovery query: %s", query.ID)</span>
}

// findMatchingResources finds resources matching a query
func (ra *ResourceAdvertiser) findMatchingResources(query *ResourceQuery) []*Advertisement <span class="cov0" title="0">{
        var results []*Advertisement
        
        // Check cache first
        cached := ra.discoveryCache.Find(query)
        if len(cached) &gt; 0 </span><span class="cov0" title="0">{
                ra.metrics.CacheHits++
                return cached
        }</span>
        
        <span class="cov0" title="0">ra.metrics.CacheMisses++
        
        // Query DHT
        results = ra.queryDHT(query)
        
        // Store in cache
        for _, ad := range results </span><span class="cov0" title="0">{
                ra.discoveryCache.Store(ad)
        }</span>
        
        <span class="cov0" title="0">return results</span>
}

// queryDHT queries DHT for matching resources
func (ra *ResourceAdvertiser) queryDHT(query *ResourceQuery) []*Advertisement <span class="cov0" title="0">{
        var results []*Advertisement
        
        // Search by model types
        for _, modelType := range query.ModelTypes </span><span class="cov0" title="0">{
                key := fmt.Sprintf("%s%s", ModelKeyPrefix, modelType)
                
                val, err := ra.dht.GetValue(ra.ctx, key)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov0" title="0">var ad Advertisement
                if err := json.Unmarshal(val, &amp;ad); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov0" title="0">if ra.matchesQuery(&amp;ad, query) </span><span class="cov0" title="0">{
                        results = append(results, &amp;ad)
                }</span>
        }
        
        <span class="cov0" title="0">return results</span>
}

// matchesQuery checks if advertisement matches query
func (ra *ResourceAdvertiser) matchesQuery(ad *Advertisement, query *ResourceQuery) bool <span class="cov0" title="0">{
        // Check model types
        if len(query.ModelTypes) &gt; 0 </span><span class="cov0" title="0">{
                hasModel := false
                for _, modelType := range query.ModelTypes </span><span class="cov0" title="0">{
                        for _, supportedModel := range ad.Capabilities.SupportedModels </span><span class="cov0" title="0">{
                                if supportedModel == modelType </span><span class="cov0" title="0">{
                                        hasModel = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if hasModel </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !hasModel </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        
        // Check CPU requirements
        <span class="cov0" title="0">if query.MinCPU &gt; 0 &amp;&amp; ad.Capabilities.CPUCores &lt; query.MinCPU </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // Check memory requirements
        <span class="cov0" title="0">if query.MinMemory &gt; 0 &amp;&amp; ad.Capabilities.Memory &lt; query.MinMemory </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // Check GPU requirements
        <span class="cov0" title="0">if query.RequiredGPU &amp;&amp; len(ad.Capabilities.GPUs) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // Check latency requirements
        <span class="cov0" title="0">if query.MaxLatency &gt; 0 &amp;&amp; ad.Capabilities.Latency &gt; query.MaxLatency </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // Check price requirements
        <span class="cov0" title="0">if query.MaxPrice &gt; 0 &amp;&amp; ad.Capabilities.PricePerToken &gt; query.MaxPrice </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">return true</span>
}

// Utility methods

// getGeographicInfo returns geographic information
func (ra *ResourceAdvertiser) getGeographicInfo() *GeographicInfo <span class="cov0" title="0">{
        // TODO: Implement geographic info detection
        return &amp;GeographicInfo{
                Country:  "Unknown",
                Region:   "Unknown",
                City:     "Unknown",
                Timezone: "UTC",
        }
}</span>

// signAdvertisement signs an advertisement
func (ra *ResourceAdvertiser) signAdvertisement(ad *Advertisement) ([]byte, error) <span class="cov0" title="0">{
        // Create signature payload
        payload := fmt.Sprintf("%s:%s:%d", ad.NodeID, ad.ID, ad.Timestamp.Unix())
        
        // Sign with host's private key
        privKey := ra.host.Peerstore().PrivKey(ra.host.ID())
        return privKey.Sign([]byte(payload))
}</span>

// verifyAdvertisement verifies an advertisement signature
func (ra *ResourceAdvertiser) verifyAdvertisement(ad *Advertisement) error <span class="cov0" title="0">{
        // Get peer's public key
        pubKey, err := ad.NodeID.ExtractPublicKey()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to extract public key: %w", err)
        }</span>
        
        // Verify signature
        <span class="cov0" title="0">payload := fmt.Sprintf("%s:%s:%d", ad.NodeID, ad.ID, ad.Timestamp.Unix())
        valid, err := pubKey.Verify([]byte(payload), ad.Signature)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("signature verification failed: %w", err)
        }</span>
        
        <span class="cov0" title="0">if !valid </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid signature")
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// metricsTask collects metrics
func (ra *ResourceAdvertiser) metricsTask() <span class="cov0" title="0">{
        defer ra.wg.Done()
        
        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ra.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        ra.updateMetrics()</span>
                }
        }
}

// updateMetrics updates metrics
func (ra *ResourceAdvertiser) updateMetrics() {<span class="cov0" title="0">
        // TODO: Implement metrics collection
}</span>

// cacheCleanupTask cleans up expired cache entries
func (ra *ResourceAdvertiser) cacheCleanupTask() <span class="cov0" title="0">{
        defer ra.wg.Done()
        
        ticker := time.NewTicker(5 * time.Minute)
        defer ticker.Stop()
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ra.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        ra.discoveryCache.Cleanup()</span>
                }
        }
}

// GetMetrics returns advertiser metrics
func (ra *ResourceAdvertiser) GetMetrics() *AdvertiserMetrics <span class="cov0" title="0">{
        return ra.metrics
}</span>

// Stop stops the resource advertiser
func (ra *ResourceAdvertiser) Stop() <span class="cov0" title="0">{
        log.Printf("Stopping resource advertiser")
        ra.cancel()
        ra.wg.Wait()
        log.Printf("Resource advertiser stopped")
}</span>

// DefaultAdvertiserConfig returns default configuration
func DefaultAdvertiserConfig() *AdvertiserConfig <span class="cov0" title="0">{
        return &amp;AdvertiserConfig{
                AdvertisementInterval: 30 * time.Second,
                TTL:                   5 * time.Minute,
                MaxAdvertisements:     100,
                EnableSigning:         true,
                EnableGeoLocation:     false,
                Priority:              1,
                Tags:                  make(map[string]string),
        }
}</pre>
		
		<pre class="file" id="file22" style="display: none">package resources

import (
        "sync"
        "time"
)

// ResourceQuery represents a query for discovering resources
type ResourceQuery struct {
        ID             string        `json:"id"`
        ModelTypes     []string      `json:"model_types,omitempty"`
        MinCPU         int           `json:"min_cpu,omitempty"`
        MinMemory      int64         `json:"min_memory,omitempty"`
        RequiredGPU    bool          `json:"required_gpu,omitempty"`
        MaxLatency     time.Duration `json:"max_latency,omitempty"`
        MaxPrice       float64       `json:"max_price,omitempty"`
        PreferredZones []string      `json:"preferred_zones,omitempty"`
        Tags           map[string]string `json:"tags,omitempty"`
        Timestamp      time.Time     `json:"timestamp"`
}

// DiscoveryResponse represents a response to a resource discovery query
type DiscoveryResponse struct {
        QueryID   string          `json:"query_id"`
        Results   []*Advertisement `json:"results"`
        Timestamp time.Time       `json:"timestamp"`
        Source    string          `json:"source"`
}

// DiscoveryCache manages a cache of discovered resources
type DiscoveryCache struct {
        cache     map[string]*Advertisement
        mutex     sync.RWMutex
        maxSize   int
        ttl       time.Duration
        lastClean time.Time
}

// NewDiscoveryCache creates a new discovery cache
func NewDiscoveryCache(maxSize int, ttl time.Duration) *DiscoveryCache <span class="cov0" title="0">{
        return &amp;DiscoveryCache{
                cache:     make(map[string]*Advertisement),
                maxSize:   maxSize,
                ttl:       ttl,
                lastClean: time.Now(),
        }
}</span>

// Store stores an advertisement in the cache
func (dc *DiscoveryCache) Store(ad *Advertisement) <span class="cov0" title="0">{
        dc.mutex.Lock()
        defer dc.mutex.Unlock()
        
        // Check if cache is full
        if len(dc.cache) &gt;= dc.maxSize </span><span class="cov0" title="0">{
                // Remove oldest entries
                dc.evictOldest()
        }</span>
        
        <span class="cov0" title="0">dc.cache[ad.ID] = ad</span>
}

// Find searches for advertisements matching a query
func (dc *DiscoveryCache) Find(query *ResourceQuery) []*Advertisement <span class="cov0" title="0">{
        dc.mutex.RLock()
        defer dc.mutex.RUnlock()
        
        var results []*Advertisement
        now := time.Now()
        
        for _, ad := range dc.cache </span><span class="cov0" title="0">{
                // Check if advertisement is still valid
                if now.Sub(ad.Timestamp) &gt; dc.ttl </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                // Check if advertisement matches query
                <span class="cov0" title="0">if dc.matchesQuery(ad, query) </span><span class="cov0" title="0">{
                        results = append(results, ad)
                }</span>
        }
        
        <span class="cov0" title="0">return results</span>
}

// matchesQuery checks if an advertisement matches a query (internal helper)
func (dc *DiscoveryCache) matchesQuery(ad *Advertisement, query *ResourceQuery) bool <span class="cov0" title="0">{
        // Check model types
        if len(query.ModelTypes) &gt; 0 </span><span class="cov0" title="0">{
                hasModel := false
                for _, modelType := range query.ModelTypes </span><span class="cov0" title="0">{
                        for _, supportedModel := range ad.Capabilities.SupportedModels </span><span class="cov0" title="0">{
                                if supportedModel == modelType </span><span class="cov0" title="0">{
                                        hasModel = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if hasModel </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !hasModel </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        
        // Check CPU requirements
        <span class="cov0" title="0">if query.MinCPU &gt; 0 &amp;&amp; ad.Capabilities.CPUCores &lt; query.MinCPU </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // Check memory requirements
        <span class="cov0" title="0">if query.MinMemory &gt; 0 &amp;&amp; ad.Capabilities.Memory &lt; query.MinMemory </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // Check GPU requirements
        <span class="cov0" title="0">if query.RequiredGPU &amp;&amp; len(ad.Capabilities.GPUs) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // Check latency requirements
        <span class="cov0" title="0">if query.MaxLatency &gt; 0 &amp;&amp; ad.Capabilities.Latency &gt; query.MaxLatency </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // Check price requirements
        <span class="cov0" title="0">if query.MaxPrice &gt; 0 &amp;&amp; ad.Capabilities.PricePerToken &gt; query.MaxPrice </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">return true</span>
}

// Cleanup removes expired entries from the cache
func (dc *DiscoveryCache) Cleanup() <span class="cov0" title="0">{
        dc.mutex.Lock()
        defer dc.mutex.Unlock()
        
        now := time.Now()
        
        for id, ad := range dc.cache </span><span class="cov0" title="0">{
                if now.Sub(ad.Timestamp) &gt; dc.ttl </span><span class="cov0" title="0">{
                        delete(dc.cache, id)
                }</span>
        }
        
        <span class="cov0" title="0">dc.lastClean = now</span>
}

// evictOldest removes the oldest entries when cache is full
func (dc *DiscoveryCache) evictOldest() <span class="cov0" title="0">{
        if len(dc.cache) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        
        // Find oldest entry
        <span class="cov0" title="0">var oldestID string
        var oldestTime time.Time
        
        for id, ad := range dc.cache </span><span class="cov0" title="0">{
                if oldestID == "" || ad.Timestamp.Before(oldestTime) </span><span class="cov0" title="0">{
                        oldestID = id
                        oldestTime = ad.Timestamp
                }</span>
        }
        
        // Remove oldest entry
        <span class="cov0" title="0">if oldestID != "" </span><span class="cov0" title="0">{
                delete(dc.cache, oldestID)
        }</span>
}

// GetSize returns the current cache size
func (dc *DiscoveryCache) GetSize() int <span class="cov0" title="0">{
        dc.mutex.RLock()
        defer dc.mutex.RUnlock()
        return len(dc.cache)
}</span>

// Clear empties the cache
func (dc *DiscoveryCache) Clear() <span class="cov0" title="0">{
        dc.mutex.Lock()
        defer dc.mutex.Unlock()
        dc.cache = make(map[string]*Advertisement)
}</pre>
		
		<pre class="file" id="file23" style="display: none">package routing

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "sync"
        "time"

        "github.com/libp2p/go-libp2p/core/host"
        "github.com/libp2p/go-libp2p/core/network"
        "github.com/libp2p/go-libp2p/core/peer"
        "github.com/libp2p/go-libp2p/core/protocol"
        dht "github.com/libp2p/go-libp2p-kad-dht"
        "github.com/ipfs/go-cid"
        "github.com/multiformats/go-multihash"
)

const (
        // Content routing protocols
        ContentRoutingProtocol = protocol.ID("/ollamacron/content-routing/1.0.0")
        ContentRequestProtocol = protocol.ID("/ollamacron/content-request/1.0.0")
        ContentProvideProtocol = protocol.ID("/ollamacron/content-provide/1.0.0")
        
        // DHT content keys
        ContentKeyPrefix = "/ollamacron/content/"
        ModelKeyPrefix   = "/ollamacron/models/"
        DataKeyPrefix    = "/ollamacron/data/"
)

// ContentRouter manages content routing and discovery
type ContentRouter struct {
        host           host.Host
        dht            *dht.IpfsDHT
        
        // Content storage
        contentStore   *ContentStore
        
        // Routing table
        routingTable   *RoutingTable
        
        // Provider management
        providers      map[string][]peer.ID
        providersMux   sync.RWMutex
        
        // Content discovery
        discovery      *ContentDiscovery
        
        // Request tracking
        activeRequests map[string]*ContentRequest
        requestsMux    sync.RWMutex
        
        // Configuration
        config         *ContentRouterConfig
        
        // Metrics
        metrics        *ContentRouterMetrics
        
        // Lifecycle
        ctx            context.Context
        cancel         context.CancelFunc
        wg             sync.WaitGroup
}

// ContentStore manages local and remote content references
type ContentStore struct {
        // Local content
        localContent   map[string]*ContentMetadata
        localMux       sync.RWMutex
        
        // Remote references
        remoteContent  map[string]*RemoteContent
        remoteMux      sync.RWMutex
        
        // Cache management
        cache          *ContentCache
        
        // Storage backend
        storage        Storage
        
        // Indexing
        index          *ContentIndex
}

// ContentMetadata represents content metadata
type ContentMetadata struct {
        ID             string            `json:"id"`
        Name           string            `json:"name"`
        Type           string            `json:"type"`
        Size           int64             `json:"size"`
        Checksum       string            `json:"checksum"`
        
        // Model-specific metadata
        ModelType      string            `json:"model_type"`
        Architecture   string            `json:"architecture"`
        Parameters     int64             `json:"parameters"`
        Quantization   string            `json:"quantization"`
        
        // Availability
        Providers      []peer.ID         `json:"providers"`
        Replicas       int               `json:"replicas"`
        
        // Access control
        AccessLevel    string            `json:"access_level"`
        RequiredAuth   bool              `json:"required_auth"`
        
        // Versioning
        Version        string            `json:"version"`
        ParentID       string            `json:"parent_id,omitempty"`
        
        // Timestamps
        CreatedAt      time.Time         `json:"created_at"`
        UpdatedAt      time.Time         `json:"updated_at"`
        LastAccessed   time.Time         `json:"last_accessed"`
        
        // Tags and labels
        Tags           map[string]string `json:"tags"`
        Labels         []string          `json:"labels"`
}

// RemoteContent represents remote content reference
type RemoteContent struct {
        Metadata       *ContentMetadata
        Providers      []peer.ID
        LastUpdated    time.Time
        RetrievalCost  int64
        Availability   float64
}

// ContentRequest represents a content request
type ContentRequest struct {
        ID             string
        ContentID      string
        RequestorID    peer.ID
        Priority       int
        Timeout        time.Duration
        CreatedAt      time.Time
        Status         RequestStatus
        Progress       float64
        Providers      []peer.ID
        FailedProviders []peer.ID
}

// RequestStatus represents request status
type RequestStatus int

const (
        RequestStatusPending RequestStatus = iota
        RequestStatusActive
        RequestStatusCompleted
        RequestStatusFailed
        RequestStatusCancelled
)

// ContentRouterConfig holds configuration
type ContentRouterConfig struct {
        MaxProviders       int           `json:"max_providers"`
        ProviderTimeout    time.Duration `json:"provider_timeout"`
        RequestTimeout     time.Duration `json:"request_timeout"`
        CacheSize          int           `json:"cache_size"`
        CacheTTL           time.Duration `json:"cache_ttl"`
        ReplicationFactor  int           `json:"replication_factor"`
        EnableCaching      bool          `json:"enable_caching"`
        EnableIndexing     bool          `json:"enable_indexing"`
}

// ContentRouterMetrics tracks routing metrics
type ContentRouterMetrics struct {
        ContentPublished   int
        ContentRequests    int
        ContentProvided    int
        CacheHits          int
        CacheMisses        int
        ProviderQueries    int
        SuccessfulRoutes   int
        FailedRoutes       int
        AverageLatency     time.Duration
        StartTime          time.Time
}

// NewContentRouter creates a new content router
func NewContentRouter(ctx context.Context, host host.Host, dht *dht.IpfsDHT, config *ContentRouterConfig) (*ContentRouter, error) <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                config = DefaultContentRouterConfig()
        }</span>
        
        <span class="cov0" title="0">ctx, cancel := context.WithCancel(ctx)
        
        cr := &amp;ContentRouter{
                host:           host,
                dht:            dht,
                providers:      make(map[string][]peer.ID),
                activeRequests: make(map[string]*ContentRequest),
                config:         config,
                metrics: &amp;ContentRouterMetrics{
                        StartTime: time.Now(),
                },
                ctx:    ctx,
                cancel: cancel,
        }
        
        // Initialize content store
        contentStore, err := NewContentStore(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize content store: %w", err)
        }</span>
        <span class="cov0" title="0">cr.contentStore = contentStore
        
        // Initialize routing table
        cr.routingTable = NewRoutingTable(host.ID())
        
        // Initialize content discovery
        cr.discovery = NewContentDiscovery(host, dht, config)
        
        // Setup protocol handlers
        cr.setupProtocolHandlers()
        
        return cr, nil</span>
}

// setupProtocolHandlers sets up protocol handlers
func (cr *ContentRouter) setupProtocolHandlers() <span class="cov0" title="0">{
        cr.host.SetStreamHandler(ContentRoutingProtocol, cr.handleContentRouting)
        cr.host.SetStreamHandler(ContentRequestProtocol, cr.handleContentRequest)
        cr.host.SetStreamHandler(ContentProvideProtocol, cr.handleContentProvide)
}</span>

// Start starts the content router
func (cr *ContentRouter) Start() <span class="cov0" title="0">{
        log.Printf("Starting content router")
        
        // Start discovery
        cr.discovery.Start()
        
        // Start provider management
        cr.wg.Add(1)
        go cr.providerManagementTask()
        
        // Start request processing
        cr.wg.Add(1)
        go cr.requestProcessingTask()
        
        // Start metrics collection
        cr.wg.Add(1)
        go cr.metricsTask()
        
        // Start cache cleanup
        cr.wg.Add(1)
        go cr.cacheCleanupTask()
        
        log.Printf("Content router started")
}</span>

// PublishContent publishes content to the network
func (cr *ContentRouter) PublishContent(ctx context.Context, content *ContentMetadata) error <span class="cov0" title="0">{
        log.Printf("Publishing content: %s", content.ID)
        
        // Store content locally
        cr.contentStore.StoreLocal(content)
        
        // Announce to DHT
        key := fmt.Sprintf("%s%s", ContentKeyPrefix, content.ID)
        data, err := json.Marshal(content)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal content: %w", err)
        }</span>
        
        <span class="cov0" title="0">if err := cr.dht.PutValue(ctx, key, data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to publish to DHT: %w", err)
        }</span>
        
        // Become provider
        <span class="cov0" title="0">contentHash, err := cr.calculateContentHash(content.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to calculate content hash: %w", err)
        }</span>
        
        <span class="cov0" title="0">if err := cr.dht.Provide(ctx, contentHash, true); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to announce as provider: %w", err)
        }</span>
        
        // Update routing table
        <span class="cov0" title="0">cr.routingTable.AddRoute(content.ID, cr.host.ID())
        
        // Update metrics
        cr.metrics.ContentPublished++
        
        log.Printf("Published content: %s", content.ID)
        return nil</span>
}

// FindContent finds content in the network
func (cr *ContentRouter) FindContent(ctx context.Context, contentID string) (*ContentMetadata, []peer.ID, error) <span class="cov0" title="0">{
        log.Printf("Finding content: %s", contentID)
        
        // Check local store first
        if content, exists := cr.contentStore.GetLocal(contentID); exists </span><span class="cov0" title="0">{
                return content, []peer.ID{cr.host.ID()}, nil
        }</span>
        
        // Check cache
        <span class="cov0" title="0">if cr.config.EnableCaching </span><span class="cov0" title="0">{
                if cached, exists := cr.contentStore.GetCached(contentID); exists </span><span class="cov0" title="0">{
                        cr.metrics.CacheHits++
                        return cached.Metadata, cached.Providers, nil
                }</span>
                <span class="cov0" title="0">cr.metrics.CacheMisses++</span>
        }
        
        // Query DHT
        <span class="cov0" title="0">key := fmt.Sprintf("%s%s", ContentKeyPrefix, contentID)
        val, err := cr.dht.GetValue(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("content not found in DHT: %w", err)
        }</span>
        
        <span class="cov0" title="0">var content ContentMetadata
        if err := json.Unmarshal(val, &amp;content); err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to unmarshal content: %w", err)
        }</span>
        
        // Find providers
        <span class="cov0" title="0">providers, err := cr.findProviders(ctx, contentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to find providers: %w", err)
        }</span>
        
        // Cache the result
        <span class="cov0" title="0">if cr.config.EnableCaching </span><span class="cov0" title="0">{
                cr.contentStore.CacheRemote(contentID, &amp;content, providers)
        }</span>
        
        <span class="cov0" title="0">log.Printf("Found content: %s with %d providers", contentID, len(providers))
        return &amp;content, providers, nil</span>
}

// findProviders finds providers for content
func (cr *ContentRouter) findProviders(ctx context.Context, contentID string) ([]peer.ID, error) <span class="cov0" title="0">{
        contentHash, err := cr.calculateContentHash(contentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to calculate content hash: %w", err)
        }</span>
        
        <span class="cov0" title="0">providersChan := cr.dht.FindProvidersAsync(ctx, contentHash, cr.config.MaxProviders)
        
        var providerIDs []peer.ID
        for provider := range providersChan </span><span class="cov0" title="0">{
                providerIDs = append(providerIDs, provider.ID)
        }</span>
        
        <span class="cov0" title="0">cr.metrics.ProviderQueries++
        return providerIDs, nil</span>
}

// RequestContent requests content from the network
func (cr *ContentRouter) RequestContent(ctx context.Context, contentID string, priority int) (*ContentRequest, error) <span class="cov0" title="0">{
        log.Printf("Requesting content: %s with priority %d", contentID, priority)
        
        // Create request
        requestID := fmt.Sprintf("req-%d", time.Now().UnixNano())
        request := &amp;ContentRequest{
                ID:          requestID,
                ContentID:   contentID,
                RequestorID: cr.host.ID(),
                Priority:    priority,
                Timeout:     cr.config.RequestTimeout,
                CreatedAt:   time.Now(),
                Status:      RequestStatusPending,
                Progress:    0,
        }
        
        // Store request
        cr.requestsMux.Lock()
        cr.activeRequests[requestID] = request
        cr.requestsMux.Unlock()
        
        // Find providers
        providers, err := cr.findProviders(ctx, contentID)
        if err != nil </span><span class="cov0" title="0">{
                request.Status = RequestStatusFailed
                return request, fmt.Errorf("failed to find providers: %w", err)
        }</span>
        
        <span class="cov0" title="0">request.Providers = providers
        request.Status = RequestStatusActive
        
        // Start request processing
        go cr.processContentRequest(request)
        
        cr.metrics.ContentRequests++
        return request, nil</span>
}

// processContentRequest processes a content request
func (cr *ContentRouter) processContentRequest(request *ContentRequest) <span class="cov0" title="0">{
        log.Printf("Processing content request: %s", request.ID)
        
        ctx, cancel := context.WithTimeout(cr.ctx, request.Timeout)
        defer cancel()
        
        // Try providers in order
        for _, providerID := range request.Providers </span><span class="cov0" title="0">{
                if cr.ctx.Err() != nil </span><span class="cov0" title="0">{
                        request.Status = RequestStatusCancelled
                        return
                }</span>
                
                // Skip failed providers
                <span class="cov0" title="0">if cr.isFailedProvider(request, providerID) </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                // Request from provider
                <span class="cov0" title="0">if err := cr.requestFromProvider(ctx, request, providerID); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to request from provider %s: %v", providerID, err)
                        request.FailedProviders = append(request.FailedProviders, providerID)
                        continue</span>
                }
                
                // Success
                <span class="cov0" title="0">request.Status = RequestStatusCompleted
                request.Progress = 1.0
                cr.metrics.SuccessfulRoutes++
                log.Printf("Completed content request: %s", request.ID)
                return</span>
        }
        
        // All providers failed
        <span class="cov0" title="0">request.Status = RequestStatusFailed
        cr.metrics.FailedRoutes++
        log.Printf("Failed content request: %s", request.ID)</span>
}

// requestFromProvider requests content from a specific provider
func (cr *ContentRouter) requestFromProvider(ctx context.Context, request *ContentRequest, providerID peer.ID) error <span class="cov0" title="0">{
        // Create stream to provider
        stream, err := cr.host.NewStream(ctx, providerID, ContentRequestProtocol)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create stream: %w", err)
        }</span>
        <span class="cov0" title="0">defer stream.Close()
        
        // Send request
        requestMsg := &amp;ContentRequestMessage{
                RequestID: request.ID,
                ContentID: request.ContentID,
                Priority:  request.Priority,
                Timestamp: time.Now(),
        }
        
        data, err := json.Marshal(requestMsg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal request: %w", err)
        }</span>
        
        <span class="cov0" title="0">if _, err := stream.Write(data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to send request: %w", err)
        }</span>
        
        // Read response
        <span class="cov0" title="0">buf := make([]byte, 4096)
        n, err := stream.Read(buf)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read response: %w", err)
        }</span>
        
        <span class="cov0" title="0">var response ContentResponseMessage
        if err := json.Unmarshal(buf[:n], &amp;response); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal response: %w", err)
        }</span>
        
        <span class="cov0" title="0">if !response.Success </span><span class="cov0" title="0">{
                return fmt.Errorf("provider rejected request: %s", response.Message)
        }</span>
        
        // Update progress
        <span class="cov0" title="0">request.Progress = 0.5
        
        // Handle content transfer (simplified)
        // In a real implementation, this would involve chunked transfers
        if response.ContentData != nil </span><span class="cov0" title="0">{
                // Process content data
                request.Progress = 1.0
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// Protocol handlers

// handleContentRouting handles content routing requests
func (cr *ContentRouter) handleContentRouting(stream network.Stream) <span class="cov0" title="0">{
        defer stream.Close()
        
        // Read routing request
        buf := make([]byte, 4096)
        n, err := stream.Read(buf)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to read routing request: %v", err)
                return
        }</span>
        
        <span class="cov0" title="0">var routingMsg RoutingMessage
        if err := json.Unmarshal(buf[:n], &amp;routingMsg); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to unmarshal routing request: %v", err)
                return
        }</span>
        
        // Process routing request
        <span class="cov0" title="0">response := cr.processRoutingRequest(&amp;routingMsg)
        
        // Send response
        data, err := json.Marshal(response)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to marshal routing response: %v", err)
                return
        }</span>
        
        <span class="cov0" title="0">if _, err := stream.Write(data); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to send routing response: %v", err)
                return
        }</span>
}

// handleContentRequest handles incoming content requests
func (cr *ContentRouter) handleContentRequest(stream network.Stream) <span class="cov0" title="0">{
        defer stream.Close()
        
        peerID := stream.Conn().RemotePeer()
        
        // Read request
        buf := make([]byte, 4096)
        n, err := stream.Read(buf)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to read content request: %v", err)
                return
        }</span>
        
        <span class="cov0" title="0">var request ContentRequestMessage
        if err := json.Unmarshal(buf[:n], &amp;request); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to unmarshal content request: %v", err)
                return
        }</span>
        
        // Process request
        <span class="cov0" title="0">response := cr.processIncomingContentRequest(&amp;request, peerID)
        
        // Send response
        data, err := json.Marshal(response)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to marshal content response: %v", err)
                return
        }</span>
        
        <span class="cov0" title="0">if _, err := stream.Write(data); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to send content response: %v", err)
                return
        }</span>
        
        <span class="cov0" title="0">cr.metrics.ContentProvided++</span>
}

// handleContentProvide handles content provision announcements
func (cr *ContentRouter) handleContentProvide(stream network.Stream) <span class="cov0" title="0">{
        defer stream.Close()
        
        peerID := stream.Conn().RemotePeer()
        
        // Read provision announcement
        buf := make([]byte, 4096)
        n, err := stream.Read(buf)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to read provision announcement: %v", err)
                return
        }</span>
        
        <span class="cov0" title="0">var announcement ProvisionAnnouncement
        if err := json.Unmarshal(buf[:n], &amp;announcement); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to unmarshal provision announcement: %v", err)
                return
        }</span>
        
        // Process announcement
        <span class="cov0" title="0">cr.processProvisionAnnouncement(&amp;announcement, peerID)</span>
}

// processRoutingRequest processes a routing request
func (cr *ContentRouter) processRoutingRequest(msg *RoutingMessage) *RoutingResponse <span class="cov0" title="0">{
        // Find routes for the requested content
        routes := cr.routingTable.FindRoutes(msg.ContentID)
        
        return &amp;RoutingResponse{
                MessageID: msg.MessageID,
                Success:   len(routes) &gt; 0,
                Routes:    routes,
                Timestamp: time.Now(),
        }
}</span>

// processIncomingContentRequest processes an incoming content request from a peer
func (cr *ContentRouter) processIncomingContentRequest(request *ContentRequestMessage, requesterID peer.ID) *ContentResponseMessage <span class="cov0" title="0">{
        // Check if we have the content
        content, exists := cr.contentStore.GetLocal(request.ContentID)
        if !exists </span><span class="cov0" title="0">{
                return &amp;ContentResponseMessage{
                        RequestID: request.RequestID,
                        Success:   false,
                        Message:   "Content not found",
                        Timestamp: time.Now(),
                }
        }</span>
        
        // TODO: Implement actual content transfer
        // For now, just return metadata
        <span class="cov0" title="0">return &amp;ContentResponseMessage{
                RequestID:   request.RequestID,
                Success:     true,
                ContentMeta: content,
                Timestamp:   time.Now(),
        }</span>
}

// processProvisionAnnouncement processes a provision announcement
func (cr *ContentRouter) processProvisionAnnouncement(announcement *ProvisionAnnouncement, providerID peer.ID) <span class="cov0" title="0">{
        cr.providersMux.Lock()
        defer cr.providersMux.Unlock()
        
        // Add provider to the list
        providers := cr.providers[announcement.ContentID]
        for _, p := range providers </span><span class="cov0" title="0">{
                if p == providerID </span><span class="cov0" title="0">{
                        return // Already in list
                }</span>
        }
        
        <span class="cov0" title="0">cr.providers[announcement.ContentID] = append(providers, providerID)
        log.Printf("Added provider %s for content %s", providerID, announcement.ContentID)</span>
}

// Background tasks

// providerManagementTask manages provider information
func (cr *ContentRouter) providerManagementTask() <span class="cov0" title="0">{
        defer cr.wg.Done()
        
        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-cr.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        cr.updateProviderInfo()</span>
                }
        }
}

// requestProcessingTask processes pending requests
func (cr *ContentRouter) requestProcessingTask() <span class="cov0" title="0">{
        defer cr.wg.Done()
        
        ticker := time.NewTicker(5 * time.Second)
        defer ticker.Stop()
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-cr.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        cr.processTimeouts()</span>
                }
        }
}

// metricsTask collects metrics
func (cr *ContentRouter) metricsTask() <span class="cov0" title="0">{
        defer cr.wg.Done()
        
        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-cr.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        cr.updateMetrics()</span>
                }
        }
}

// cacheCleanupTask cleans up expired cache entries
func (cr *ContentRouter) cacheCleanupTask() <span class="cov0" title="0">{
        defer cr.wg.Done()
        
        ticker := time.NewTicker(5 * time.Minute)
        defer ticker.Stop()
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-cr.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        cr.contentStore.CleanupCache()</span>
                }
        }
}

// Utility methods

// calculateContentHash calculates hash for content ID
func (cr *ContentRouter) calculateContentHash(contentID string) (cid.Cid, error) <span class="cov0" title="0">{
        // Simple hash calculation - in production use proper content addressing
        mh, err := multihash.Sum([]byte(contentID), multihash.SHA2_256, -1)
        if err != nil </span><span class="cov0" title="0">{
                return cid.Cid{}, err
        }</span>
        <span class="cov0" title="0">return cid.NewCidV1(cid.Raw, mh), nil</span>
}

// isFailedProvider checks if provider has failed recently
func (cr *ContentRouter) isFailedProvider(request *ContentRequest, providerID peer.ID) bool <span class="cov0" title="0">{
        for _, failed := range request.FailedProviders </span><span class="cov0" title="0">{
                if failed == providerID </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// updateProviderInfo updates provider information
func (cr *ContentRouter) updateProviderInfo() {<span class="cov0" title="0">
        // TODO: Implement provider health checking
}</span>

// processTimeouts processes request timeouts
func (cr *ContentRouter) processTimeouts() <span class="cov0" title="0">{
        cr.requestsMux.Lock()
        defer cr.requestsMux.Unlock()
        
        now := time.Now()
        for id, request := range cr.activeRequests </span><span class="cov0" title="0">{
                if now.Sub(request.CreatedAt) &gt; request.Timeout </span><span class="cov0" title="0">{
                        request.Status = RequestStatusFailed
                        delete(cr.activeRequests, id)
                        log.Printf("Request timeout: %s", id)
                }</span>
        }
}

// updateMetrics updates router metrics
func (cr *ContentRouter) updateMetrics() {<span class="cov0" title="0">
        // TODO: Implement metrics collection
}</span>

// GetMetrics returns router metrics
func (cr *ContentRouter) GetMetrics() *ContentRouterMetrics <span class="cov0" title="0">{
        return cr.metrics
}</span>

// GetActiveRequests returns active requests
func (cr *ContentRouter) GetActiveRequests() map[string]*ContentRequest <span class="cov0" title="0">{
        cr.requestsMux.RLock()
        defer cr.requestsMux.RUnlock()
        
        requests := make(map[string]*ContentRequest)
        for k, v := range cr.activeRequests </span><span class="cov0" title="0">{
                requests[k] = v
        }</span>
        <span class="cov0" title="0">return requests</span>
}

// Stop stops the content router
func (cr *ContentRouter) Stop() <span class="cov0" title="0">{
        log.Printf("Stopping content router")
        cr.cancel()
        cr.wg.Wait()
        
        if cr.discovery != nil </span><span class="cov0" title="0">{
                cr.discovery.Stop()
        }</span>
        
        <span class="cov0" title="0">log.Printf("Content router stopped")</span>
}

// DefaultContentRouterConfig returns default configuration
func DefaultContentRouterConfig() *ContentRouterConfig <span class="cov0" title="0">{
        return &amp;ContentRouterConfig{
                MaxProviders:      10,
                ProviderTimeout:   30 * time.Second,
                RequestTimeout:    60 * time.Second,
                CacheSize:         1000,
                CacheTTL:          10 * time.Minute,
                ReplicationFactor: 3,
                EnableCaching:     true,
                EnableIndexing:    true,
        }
}</span>

// Message types

// RoutingMessage represents a routing message
type RoutingMessage struct {
        MessageID string    `json:"message_id"`
        ContentID string    `json:"content_id"`
        Type      string    `json:"type"`
        Timestamp time.Time `json:"timestamp"`
}

// RoutingResponse represents a routing response
type RoutingResponse struct {
        MessageID string     `json:"message_id"`
        Success   bool       `json:"success"`
        Routes    []peer.ID  `json:"routes"`
        Message   string     `json:"message,omitempty"`
        Timestamp time.Time  `json:"timestamp"`
}

// ContentRequestMessage represents a content request
type ContentRequestMessage struct {
        RequestID string    `json:"request_id"`
        ContentID string    `json:"content_id"`
        Priority  int       `json:"priority"`
        Timestamp time.Time `json:"timestamp"`
}

// ContentResponseMessage represents a content response
type ContentResponseMessage struct {
        RequestID   string           `json:"request_id"`
        Success     bool             `json:"success"`
        ContentMeta *ContentMetadata `json:"content_meta,omitempty"`
        ContentData []byte           `json:"content_data,omitempty"`
        Message     string           `json:"message,omitempty"`
        Timestamp   time.Time        `json:"timestamp"`
}

// ProvisionAnnouncement represents a provision announcement
type ProvisionAnnouncement struct {
        ContentID string    `json:"content_id"`
        Provider  peer.ID   `json:"provider"`
        TTL       time.Duration `json:"ttl"`
        Timestamp time.Time `json:"timestamp"`
}

// RoutingTable manages peer routing information
type RoutingTable struct {
        localPeerID peer.ID
        routes      map[string][]peer.ID
        mu          sync.RWMutex
}

// NewRoutingTable creates a new routing table
func NewRoutingTable(localPeerID peer.ID) *RoutingTable <span class="cov0" title="0">{
        return &amp;RoutingTable{
                localPeerID: localPeerID,
                routes:      make(map[string][]peer.ID),
        }
}</span>

// AddRoute adds a route to the routing table
func (rt *RoutingTable) AddRoute(contentID string, peerID peer.ID) <span class="cov0" title="0">{
        rt.mu.Lock()
        defer rt.mu.Unlock()
        
        routes := rt.routes[contentID]
        for _, p := range routes </span><span class="cov0" title="0">{
                if p == peerID </span><span class="cov0" title="0">{
                        return // Already exists
                }</span>
        }
        <span class="cov0" title="0">rt.routes[contentID] = append(routes, peerID)</span>
}

// FindRoutes finds routes for a content ID
func (rt *RoutingTable) FindRoutes(contentID string) []peer.ID <span class="cov0" title="0">{
        rt.mu.RLock()
        defer rt.mu.RUnlock()
        
        routes := rt.routes[contentID]
        result := make([]peer.ID, len(routes))
        copy(result, routes)
        return result
}</span>

// ContentDiscovery manages content discovery in the network
type ContentDiscovery struct {
        host   host.Host
        dht    *dht.IpfsDHT
        config *ContentRouterConfig
        ctx    context.Context
        cancel context.CancelFunc
}

// NewContentDiscovery creates a new content discovery instance
func NewContentDiscovery(host host.Host, dht *dht.IpfsDHT, config *ContentRouterConfig) *ContentDiscovery <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())
        return &amp;ContentDiscovery{
                host:   host,
                dht:    dht,
                config: config,
                ctx:    ctx,
                cancel: cancel,
        }
}</span>

// Start starts the content discovery service
func (cd *ContentDiscovery) Start() {<span class="cov0" title="0">
        // TODO: Implement discovery service
}</span>

// Stop stops the content discovery service
func (cd *ContentDiscovery) Stop() <span class="cov0" title="0">{
        cd.cancel()
}</span>

// ContentCache manages cached content
type ContentCache struct {
        cache    map[string]*CacheEntry
        maxSize  int
        ttl      time.Duration
        mu       sync.RWMutex
}

// CacheEntry represents a cache entry
type CacheEntry struct {
        Content   *RemoteContent
        ExpiresAt time.Time
}

// NewContentCache creates a new content cache
func NewContentCache(maxSize int, ttl time.Duration) *ContentCache <span class="cov0" title="0">{
        return &amp;ContentCache{
                cache:   make(map[string]*CacheEntry),
                maxSize: maxSize,
                ttl:     ttl,
        }
}</span>

// Get retrieves content from cache
func (cc *ContentCache) Get(contentID string) (*RemoteContent, bool) <span class="cov0" title="0">{
        cc.mu.RLock()
        defer cc.mu.RUnlock()
        
        entry, exists := cc.cache[contentID]
        if !exists || time.Now().After(entry.ExpiresAt) </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov0" title="0">return entry.Content, true</span>
}

// Put stores content in cache
func (cc *ContentCache) Put(contentID string, content *RemoteContent) <span class="cov0" title="0">{
        cc.mu.Lock()
        defer cc.mu.Unlock()
        
        cc.cache[contentID] = &amp;CacheEntry{
                Content:   content,
                ExpiresAt: time.Now().Add(cc.ttl),
        }
        
        // Simple eviction if cache is full
        if len(cc.cache) &gt; cc.maxSize </span><span class="cov0" title="0">{
                // Remove oldest entry
                var oldestID string
                var oldestTime time.Time
                for id, entry := range cc.cache </span><span class="cov0" title="0">{
                        if oldestTime.IsZero() || entry.ExpiresAt.Before(oldestTime) </span><span class="cov0" title="0">{
                                oldestID = id
                                oldestTime = entry.ExpiresAt
                        }</span>
                }
                <span class="cov0" title="0">delete(cc.cache, oldestID)</span>
        }
}

// Cleanup removes expired entries
func (cc *ContentCache) Cleanup() <span class="cov0" title="0">{
        cc.mu.Lock()
        defer cc.mu.Unlock()
        
        now := time.Now()
        for id, entry := range cc.cache </span><span class="cov0" title="0">{
                if now.After(entry.ExpiresAt) </span><span class="cov0" title="0">{
                        delete(cc.cache, id)
                }</span>
        }
}

// Storage interface for content storage
type Storage interface {
        Get(key string) ([]byte, error)
        Put(key string, value []byte) error
        Delete(key string) error
        Has(key string) bool
}

// MemoryStorage implements in-memory storage
type MemoryStorage struct {
        data map[string][]byte
        mu   sync.RWMutex
}

// NewMemoryStorage creates a new memory storage
func NewMemoryStorage() *MemoryStorage <span class="cov0" title="0">{
        return &amp;MemoryStorage{
                data: make(map[string][]byte),
        }
}</span>

// Get retrieves data from storage
func (ms *MemoryStorage) Get(key string) ([]byte, error) <span class="cov0" title="0">{
        ms.mu.RLock()
        defer ms.mu.RUnlock()
        
        data, exists := ms.data[key]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("key not found: %s", key)
        }</span>
        <span class="cov0" title="0">return data, nil</span>
}

// Put stores data in storage
func (ms *MemoryStorage) Put(key string, value []byte) error <span class="cov0" title="0">{
        ms.mu.Lock()
        defer ms.mu.Unlock()
        
        ms.data[key] = value
        return nil
}</span>

// Delete removes data from storage
func (ms *MemoryStorage) Delete(key string) error <span class="cov0" title="0">{
        ms.mu.Lock()
        defer ms.mu.Unlock()
        
        delete(ms.data, key)
        return nil
}</span>

// Has checks if key exists in storage
func (ms *MemoryStorage) Has(key string) bool <span class="cov0" title="0">{
        ms.mu.RLock()
        defer ms.mu.RUnlock()
        
        _, exists := ms.data[key]
        return exists
}</span>

// ContentIndex manages content indexing
type ContentIndex struct {
        index map[string]*IndexEntry
        mu    sync.RWMutex
}

// IndexEntry represents an index entry
type IndexEntry struct {
        ContentID string
        Metadata  *ContentMetadata
        Keywords  []string
        UpdatedAt time.Time
}

// NewContentIndex creates a new content index
func NewContentIndex() *ContentIndex <span class="cov0" title="0">{
        return &amp;ContentIndex{
                index: make(map[string]*IndexEntry),
        }
}</span>

// Add adds content to the index
func (ci *ContentIndex) Add(contentID string, metadata *ContentMetadata) <span class="cov0" title="0">{
        ci.mu.Lock()
        defer ci.mu.Unlock()
        
        ci.index[contentID] = &amp;IndexEntry{
                ContentID: contentID,
                Metadata:  metadata,
                Keywords:  extractKeywords(metadata),
                UpdatedAt: time.Now(),
        }
}</span>

// Search searches the index
func (ci *ContentIndex) Search(query string) []*IndexEntry <span class="cov0" title="0">{
        ci.mu.RLock()
        defer ci.mu.RUnlock()
        
        var results []*IndexEntry
        for _, entry := range ci.index </span><span class="cov0" title="0">{
                if matchesQuery(entry, query) </span><span class="cov0" title="0">{
                        results = append(results, entry)
                }</span>
        }
        <span class="cov0" title="0">return results</span>
}

// extractKeywords extracts keywords from metadata
func extractKeywords(metadata *ContentMetadata) []string <span class="cov0" title="0">{
        keywords := []string{metadata.Name, metadata.Type, metadata.ModelType}
        keywords = append(keywords, metadata.Labels...)
        return keywords
}</span>

// matchesQuery checks if entry matches query
func matchesQuery(entry *IndexEntry, query string) bool <span class="cov0" title="0">{
        // Simple substring matching
        for _, keyword := range entry.Keywords </span><span class="cov0" title="0">{
                if keyword == query </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// NewContentStore creates a new content store
func NewContentStore(config *ContentRouterConfig) (*ContentStore, error) <span class="cov0" title="0">{
        cache := NewContentCache(config.CacheSize, config.CacheTTL)
        storage := NewMemoryStorage()
        index := NewContentIndex()
        
        return &amp;ContentStore{
                localContent:  make(map[string]*ContentMetadata),
                remoteContent: make(map[string]*RemoteContent),
                cache:         cache,
                storage:       storage,
                index:         index,
        }, nil
}</span>

// StoreLocal stores content locally
func (cs *ContentStore) StoreLocal(content *ContentMetadata) <span class="cov0" title="0">{
        cs.localMux.Lock()
        defer cs.localMux.Unlock()
        
        cs.localContent[content.ID] = content
        if cs.index != nil </span><span class="cov0" title="0">{
                cs.index.Add(content.ID, content)
        }</span>
}

// GetLocal retrieves local content
func (cs *ContentStore) GetLocal(contentID string) (*ContentMetadata, bool) <span class="cov0" title="0">{
        cs.localMux.RLock()
        defer cs.localMux.RUnlock()
        
        content, exists := cs.localContent[contentID]
        return content, exists
}</span>

// CacheRemote caches remote content
func (cs *ContentStore) CacheRemote(contentID string, metadata *ContentMetadata, providers []peer.ID) <span class="cov0" title="0">{
        cs.remoteMux.Lock()
        defer cs.remoteMux.Unlock()
        
        remote := &amp;RemoteContent{
                Metadata:     metadata,
                Providers:    providers,
                LastUpdated:  time.Now(),
                Availability: float64(len(providers)) / 10.0, // Simple availability metric
        }
        
        cs.remoteContent[contentID] = remote
        if cs.cache != nil </span><span class="cov0" title="0">{
                cs.cache.Put(contentID, remote)
        }</span>
}

// GetCached retrieves cached content
func (cs *ContentStore) GetCached(contentID string) (*RemoteContent, bool) <span class="cov0" title="0">{
        if cs.cache != nil </span><span class="cov0" title="0">{
                return cs.cache.Get(contentID)
        }</span>
        
        <span class="cov0" title="0">cs.remoteMux.RLock()
        defer cs.remoteMux.RUnlock()
        
        content, exists := cs.remoteContent[contentID]
        return content, exists</span>
}

// CleanupCache cleans up the cache
func (cs *ContentStore) CleanupCache() <span class="cov0" title="0">{
        if cs.cache != nil </span><span class="cov0" title="0">{
                cs.cache.Cleanup()
        }</span>
}</pre>
		
		<pre class="file" id="file24" style="display: none">package security

import (
        "context"
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "encoding/json"
        "encoding/pem"
        "fmt"
        "log"
        "sync"
        "time"

        "github.com/libp2p/go-libp2p/core/crypto"
        "github.com/libp2p/go-libp2p/core/host"
        "github.com/libp2p/go-libp2p/core/network"
        "github.com/libp2p/go-libp2p/core/peer"
        "github.com/libp2p/go-libp2p/core/protocol"
)

const (
        // Security protocols
        SecureChannelProtocol = protocol.ID("/ollamacron/secure-channel/1.0.0")
        AuthProtocol         = protocol.ID("/ollamacron/auth/1.0.0")
        KeyExchangeProtocol  = protocol.ID("/ollamacron/key-exchange/1.0.0")
        
        // Security levels
        SecurityLevelNone   = "none"
        SecurityLevelBasic  = "basic"
        SecurityLevelHigh   = "high"
        
        // Key rotation intervals
        DefaultKeyRotationInterval = 24 * time.Hour
        SessionKeyTTL             = 4 * time.Hour
)

// ===============================
// Supporting Type Definitions
// ===============================

// SessionKey represents a session encryption key
type SessionKey struct {
        PublicKey  []byte
        PrivateKey []byte
        CreatedAt  time.Time
        ExpiresAt  time.Time
}

// KeyManager manages cryptographic keys
type KeyManager struct {
        sessionKeys    map[string]*SessionKey
        keysMu        sync.RWMutex
        
        // Peer public keys
        peerKeys      map[string]crypto.PubKey
        peerKeysMu    sync.RWMutex
        
        config        *SecurityConfig
}

// EncryptionManager handles encryption/decryption
type EncryptionManager struct {
        keyManager *KeyManager
        config     *SecurityConfig
}

// AccessControl manages access control policies
type AccessControl struct {
        policies  map[peer.ID]*AccessPolicy
        policyMu  sync.RWMutex
        config    *SecurityConfig
}

// AccessPolicy defines access permissions for a peer
type AccessPolicy struct {
        PeerID      peer.ID
        Permissions []string
        CreatedAt   time.Time
        ExpiresAt   time.Time
}

// RateLimiter manages rate limiting
type RateLimiter struct {
        limits   map[string]*RateLimit
        limitMu  sync.RWMutex
        config   *SecurityConfig
}

// RateLimit defines rate limiting parameters
type RateLimit struct {
        RequestsPerSecond int
        BurstSize         int
        Window            time.Duration
        lastReset         time.Time
        currentCount      int
}

// ProtocolAccessControl defines protocol-specific access control
type ProtocolAccessControl struct {
        AllowAll      bool
        AllowedPeers  []peer.ID
        BlockedPeers  []peer.ID
        RequiredPerms []string
}

// AuthManager manages authentication for P2P communications
type AuthManager struct {
        authenticatedPeers map[peer.ID]time.Time
        peersMu           sync.RWMutex
        
        // Private key for signing
        privateKey        crypto.PrivKey
        publicKey         crypto.PubKey
        
        // Session management
        sessions          map[string]*AuthSession
        sessionsMu        sync.RWMutex
        sessionTTL        time.Duration
        
        // Authentication configuration
        config            *SecurityConfig
}

// AuthSession represents an authenticated session
type AuthSession struct {
        PeerID    peer.ID
        Token     string
        CreatedAt time.Time
        ExpiresAt time.Time
        Metadata  map[string]interface{}
}

// SecurityManager manages security for P2P communications
type SecurityManager struct {
        host           host.Host
        
        // Key management
        keyManager     *KeyManager
        
        // Protocol handlers
        protocols      map[protocol.ID]*SecureProtocol
        protocolsMux   sync.RWMutex
        
        // Authentication
        authManager    *AuthManager
        
        // Encryption
        encryptionMgr  *EncryptionManager
        
        // Access control
        accessControl  *AccessControl
        
        // Rate limiting
        rateLimiter    *RateLimiter
        
        // Metrics
        metrics        *SecurityMetrics
        
        // Configuration
        config         *SecurityConfig
        
        // Lifecycle
        ctx            context.Context
        cancel         context.CancelFunc
        wg             sync.WaitGroup
}

// SecurityConfig holds security configuration
type SecurityConfig struct {
        SecurityLevel      string        `json:"security_level"`
        EnableEncryption   bool          `json:"enable_encryption"`
        EnableAuth         bool          `json:"enable_auth"`
        KeyRotationInterval time.Duration `json:"key_rotation_interval"`
        SessionKeyTTL      time.Duration `json:"session_key_ttl"`
        MaxConnections     int           `json:"max_connections"`
        RateLimits         map[string]int `json:"rate_limits"`
        TrustedPeers       []string      `json:"trusted_peers"`
        BlockedPeers       []string      `json:"blocked_peers"`
}

// SecurityMetrics tracks security-related metrics
type SecurityMetrics struct {
        AuthAttempts       int
        AuthFailures       int
        EncryptedSessions  int
        ActiveSessions     int
        KeyRotations       int
        BlockedConnections int
        RateLimitHits      int
        LastKeyRotation    time.Time
        StartTime          time.Time
        
        // Protocol metrics
        ProtocolMetrics    map[protocol.ID]*ProtocolMetrics
}

// ProtocolMetrics tracks metrics for specific protocols
type ProtocolMetrics struct {
        RequestCount       int
        ErrorCount         int
        AverageLatency     time.Duration
        LastActivity       time.Time
}

// SecureProtocol represents a secure protocol handler
type SecureProtocol struct {
        ID                protocol.ID
        Handler           network.StreamHandler
        
        // Security settings
        RequireAuth       bool
        RequireEncryption bool
        SecurityLevel     string
        
        // Rate limiting
        RateLimit         *RateLimit
        
        // Access control
        AccessControl     *ProtocolAccessControl
        
        // Metrics
        Metrics           *ProtocolMetrics
}

// NewSecurityManager creates a new security manager
func NewSecurityManager(ctx context.Context, host host.Host, config *SecurityConfig) (*SecurityManager, error) <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                config = DefaultSecurityConfig()
        }</span>
        
        <span class="cov0" title="0">ctx, cancel := context.WithCancel(ctx)
        
        sm := &amp;SecurityManager{
                host:      host,
                config:    config,
                protocols: make(map[protocol.ID]*SecureProtocol),
                metrics: &amp;SecurityMetrics{
                        StartTime:       time.Now(),
                        ProtocolMetrics: make(map[protocol.ID]*ProtocolMetrics),
                },
                ctx:    ctx,
                cancel: cancel,
        }
        
        // Initialize components
        if err := sm.initializeComponents(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize security components: %w", err)
        }</span>
        
        // Setup protocol handlers
        <span class="cov0" title="0">sm.setupProtocolHandlers()
        
        // Start background tasks
        sm.startBackgroundTasks()
        
        log.Printf("Security manager initialized with level: %s", config.SecurityLevel)
        return sm, nil</span>
}

// initializeComponents initializes security components
func (sm *SecurityManager) initializeComponents() error <span class="cov0" title="0">{
        // Initialize key manager
        keyManager, err := NewKeyManager(sm.host, sm.config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize key manager: %w", err)
        }</span>
        <span class="cov0" title="0">sm.keyManager = keyManager
        
        // Initialize authentication manager
        authManager, err := NewAuthManager(sm.host, sm.config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize auth manager: %w", err)
        }</span>
        <span class="cov0" title="0">sm.authManager = authManager
        
        // Initialize encryption manager
        encryptionMgr, err := NewEncryptionManager(sm.keyManager, sm.config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize encryption manager: %w", err)
        }</span>
        <span class="cov0" title="0">sm.encryptionMgr = encryptionMgr
        
        // Initialize access control
        accessControl, err := NewAccessControl(sm.config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize access control: %w", err)
        }</span>
        <span class="cov0" title="0">sm.accessControl = accessControl
        
        // Initialize rate limiter
        rateLimiter, err := NewRateLimiter(sm.config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize rate limiter: %w", err)
        }</span>
        <span class="cov0" title="0">sm.rateLimiter = rateLimiter
        
        return nil</span>
}

// setupProtocolHandlers sets up secure protocol handlers
func (sm *SecurityManager) setupProtocolHandlers() <span class="cov0" title="0">{
        // Secure channel protocol
        sm.RegisterSecureProtocol(SecureChannelProtocol, &amp;SecureProtocol{
                ID:                SecureChannelProtocol,
                Handler:           sm.handleSecureChannel,
                RequireAuth:       true,
                RequireEncryption: true,
                SecurityLevel:     SecurityLevelHigh,
                RateLimit:         &amp;RateLimit{RequestsPerSecond: 10, BurstSize: 20},
                AccessControl:     &amp;ProtocolAccessControl{AllowAll: false},
                Metrics:           &amp;ProtocolMetrics{},
        })
        
        // Authentication protocol
        sm.RegisterSecureProtocol(AuthProtocol, &amp;SecureProtocol{
                ID:                AuthProtocol,
                Handler:           sm.handleAuth,
                RequireAuth:       false,
                RequireEncryption: true,
                SecurityLevel:     SecurityLevelHigh,
                RateLimit:         &amp;RateLimit{RequestsPerSecond: 5, BurstSize: 10},
                AccessControl:     &amp;ProtocolAccessControl{AllowAll: true},
                Metrics:           &amp;ProtocolMetrics{},
        })
        
        // Key exchange protocol
        sm.RegisterSecureProtocol(KeyExchangeProtocol, &amp;SecureProtocol{
                ID:                KeyExchangeProtocol,
                Handler:           sm.handleKeyExchange,
                RequireAuth:       false,
                RequireEncryption: false,
                SecurityLevel:     SecurityLevelBasic,
                RateLimit:         &amp;RateLimit{RequestsPerSecond: 2, BurstSize: 5},
                AccessControl:     &amp;ProtocolAccessControl{AllowAll: true},
                Metrics:           &amp;ProtocolMetrics{},
        })
}</span>

// startBackgroundTasks starts background security tasks
func (sm *SecurityManager) startBackgroundTasks() <span class="cov0" title="0">{
        // Key rotation
        sm.wg.Add(1)
        go sm.keyRotationTask()
        
        // Metrics collection
        sm.wg.Add(1)
        go sm.metricsTask()
        
        // Rate limit cleanup
        sm.wg.Add(1)
        go sm.rateLimitCleanupTask()
        
        // Session cleanup
        sm.wg.Add(1)
        go sm.sessionCleanupTask()
}</span>

// RegisterSecureProtocol registers a secure protocol handler
func (sm *SecurityManager) RegisterSecureProtocol(protocolID protocol.ID, protocol *SecureProtocol) <span class="cov0" title="0">{
        sm.protocolsMux.Lock()
        defer sm.protocolsMux.Unlock()
        
        // Wrap handler with security middleware
        wrappedHandler := sm.wrapHandler(protocol)
        
        sm.host.SetStreamHandler(protocolID, wrappedHandler)
        sm.protocols[protocolID] = protocol
        sm.metrics.ProtocolMetrics[protocolID] = protocol.Metrics
        
        log.Printf("Registered secure protocol: %s", protocolID)
}</span>

// wrapHandler wraps a protocol handler with security middleware
func (sm *SecurityManager) wrapHandler(protocol *SecureProtocol) network.StreamHandler <span class="cov0" title="0">{
        return func(stream network.Stream) </span><span class="cov0" title="0">{
                start := time.Now()
                peerID := stream.Conn().RemotePeer()
                
                // Update metrics
                protocol.Metrics.RequestCount++
                protocol.Metrics.LastActivity = time.Now()
                
                // Check access control
                if !sm.accessControl.IsAllowed(peerID, protocol.ID) </span><span class="cov0" title="0">{
                        log.Printf("Access denied for peer %s on protocol %s", peerID, protocol.ID)
                        stream.Reset()
                        return
                }</span>
                
                // Check rate limits
                <span class="cov0" title="0">if !sm.rateLimiter.Allow(peerID, protocol.ID) </span><span class="cov0" title="0">{
                        log.Printf("Rate limit exceeded for peer %s on protocol %s", peerID, protocol.ID)
                        sm.metrics.RateLimitHits++
                        stream.Reset()
                        return
                }</span>
                
                // Check authentication if required
                <span class="cov0" title="0">if protocol.RequireAuth </span><span class="cov0" title="0">{
                        if !sm.authManager.IsAuthenticated(peerID) </span><span class="cov0" title="0">{
                                log.Printf("Authentication required for peer %s on protocol %s", peerID, protocol.ID)
                                stream.Reset()
                                return
                        }</span>
                }
                
                // Handle encryption if required
                <span class="cov0" title="0">if protocol.RequireEncryption </span><span class="cov0" title="0">{
                        if !sm.isEncryptedConnection(stream.Conn()) </span><span class="cov0" title="0">{
                                log.Printf("Encryption required for peer %s on protocol %s", peerID, protocol.ID)
                                stream.Reset()
                                return
                        }</span>
                }
                
                // Call original handler
                <span class="cov0" title="0">protocol.Handler(stream)
                
                // Update latency metrics
                protocol.Metrics.AverageLatency = time.Since(start)</span>
        }
}

// EstablishSecureChannel establishes a secure channel with a peer
func (sm *SecurityManager) EstablishSecureChannel(ctx context.Context, peerID peer.ID) (*SecureChannel, error) <span class="cov0" title="0">{
        // Create new stream
        stream, err := sm.host.NewStream(ctx, peerID, SecureChannelProtocol)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create stream: %w", err)
        }</span>
        
        // Perform handshake
        <span class="cov0" title="0">sessionKey, err := sm.performHandshake(ctx, stream)
        if err != nil </span><span class="cov0" title="0">{
                stream.Close()
                return nil, fmt.Errorf("handshake failed: %w", err)
        }</span>
        
        // Create secure channel
        <span class="cov0" title="0">channel := &amp;SecureChannel{
                Stream:     stream,
                SessionKey: sessionKey,
                Peer:       peerID,
                CreatedAt:  time.Now(),
                manager:    sm,
        }
        
        sm.metrics.EncryptedSessions++
        sm.metrics.ActiveSessions++
        
        return channel, nil</span>
}

// performHandshake performs security handshake
func (sm *SecurityManager) performHandshake(ctx context.Context, stream network.Stream) (*SessionKey, error) <span class="cov0" title="0">{
        // Generate session key
        sessionKey, err := sm.keyManager.GenerateSessionKey()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate session key: %w", err)
        }</span>
        
        // Perform noise protocol handshake
        <span class="cov0" title="0">handshake := &amp;HandshakeMessage{
                Type:      "key_exchange",
                PublicKey: sessionKey.PublicKey,
                Timestamp: time.Now(),
        }
        
        // Send handshake
        if err := sm.sendHandshake(stream, handshake); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to send handshake: %w", err)
        }</span>
        
        // Receive response
        <span class="cov0" title="0">response, err := sm.receiveHandshake(stream)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to receive handshake response: %w", err)
        }</span>
        
        // Verify response
        <span class="cov0" title="0">if err := sm.verifyHandshake(response); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("handshake verification failed: %w", err)
        }</span>
        
        <span class="cov0" title="0">return sessionKey, nil</span>
}

// Protocol handlers

// handleSecureChannel handles secure channel establishment
func (sm *SecurityManager) handleSecureChannel(stream network.Stream) <span class="cov0" title="0">{
        defer stream.Close()
        
        // Handle handshake
        handshake, err := sm.receiveHandshake(stream)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to receive handshake: %v", err)
                return
        }</span>
        
        // Verify handshake
        <span class="cov0" title="0">if err := sm.verifyHandshake(handshake); err != nil </span><span class="cov0" title="0">{
                log.Printf("Handshake verification failed: %v", err)
                return
        }</span>
        
        // Generate session key
        <span class="cov0" title="0">sessionKey, err := sm.keyManager.GenerateSessionKey()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to generate session key: %v", err)
                return
        }</span>
        
        // Send response
        <span class="cov0" title="0">response := &amp;HandshakeMessage{
                Type:      "key_exchange_response",
                PublicKey: sessionKey.PublicKey,
                Timestamp: time.Now(),
        }
        
        if err := sm.sendHandshake(stream, response); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to send handshake response: %v", err)
                return
        }</span>
        
        <span class="cov0" title="0">log.Printf("Secure channel established with peer: %s", stream.Conn().RemotePeer())</span>
}

// handleAuth handles authentication requests
func (sm *SecurityManager) handleAuth(stream network.Stream) <span class="cov0" title="0">{
        defer stream.Close()
        
        // Handle authentication
        if err := sm.authManager.HandleAuthRequest(stream); err != nil </span><span class="cov0" title="0">{
                log.Printf("Authentication failed: %v", err)
                return
        }</span>
        
        <span class="cov0" title="0">sm.metrics.AuthAttempts++
        log.Printf("Authentication successful for peer: %s", stream.Conn().RemotePeer())</span>
}

// handleKeyExchange handles key exchange requests
func (sm *SecurityManager) handleKeyExchange(stream network.Stream) <span class="cov0" title="0">{
        defer stream.Close()
        
        // Handle key exchange
        if err := sm.keyManager.HandleKeyExchange(stream); err != nil </span><span class="cov0" title="0">{
                log.Printf("Key exchange failed: %v", err)
                return
        }</span>
        
        <span class="cov0" title="0">log.Printf("Key exchange successful with peer: %s", stream.Conn().RemotePeer())</span>
}

// Background tasks

// keyRotationTask handles periodic key rotation
func (sm *SecurityManager) keyRotationTask() <span class="cov0" title="0">{
        defer sm.wg.Done()
        
        ticker := time.NewTicker(sm.config.KeyRotationInterval)
        defer ticker.Stop()
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-sm.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if err := sm.keyManager.RotateKeys(); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Key rotation failed: %v", err)
                        }</span> else<span class="cov0" title="0"> {
                                sm.metrics.KeyRotations++
                                sm.metrics.LastKeyRotation = time.Now()
                                log.Printf("Key rotation completed")
                        }</span>
                }
        }
}

// metricsTask collects security metrics
func (sm *SecurityManager) metricsTask() <span class="cov0" title="0">{
        defer sm.wg.Done()
        
        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-sm.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        sm.updateMetrics()</span>
                }
        }
}

// updateMetrics updates security metrics
func (sm *SecurityManager) updateMetrics() <span class="cov0" title="0">{
        // Update active sessions
        sm.metrics.ActiveSessions = sm.keyManager.GetActiveSessionCount()
        
        // Update protocol metrics
        for protocolID, protocol := range sm.protocols </span><span class="cov0" title="0">{
                if metrics, exists := sm.metrics.ProtocolMetrics[protocolID]; exists </span><span class="cov0" title="0">{
                        metrics.RequestCount = protocol.Metrics.RequestCount
                        metrics.ErrorCount = protocol.Metrics.ErrorCount
                        metrics.AverageLatency = protocol.Metrics.AverageLatency
                        metrics.LastActivity = protocol.Metrics.LastActivity
                }</span>
        }
}

// rateLimitCleanupTask cleans up expired rate limit entries
func (sm *SecurityManager) rateLimitCleanupTask() <span class="cov0" title="0">{
        defer sm.wg.Done()
        
        ticker := time.NewTicker(5 * time.Minute)
        defer ticker.Stop()
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-sm.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        sm.rateLimiter.Cleanup()</span>
                }
        }
}

// sessionCleanupTask cleans up expired sessions
func (sm *SecurityManager) sessionCleanupTask() <span class="cov0" title="0">{
        defer sm.wg.Done()
        
        ticker := time.NewTicker(10 * time.Minute)
        defer ticker.Stop()
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-sm.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        sm.keyManager.CleanupExpiredSessions()</span>
                }
        }
}

// Utility methods

// isEncryptedConnection checks if connection is encrypted
func (sm *SecurityManager) isEncryptedConnection(conn network.Conn) bool <span class="cov0" title="0">{
        // Check if connection uses encrypted transport
        // For libp2p, connections are generally encrypted by default
        return true
}</span>

// sendHandshake sends handshake message
func (sm *SecurityManager) sendHandshake(stream network.Stream, handshake *HandshakeMessage) error <span class="cov0" title="0">{
        data, err := json.Marshal(handshake)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal handshake: %w", err)
        }</span>
        
        <span class="cov0" title="0">_, err = stream.Write(data)
        return err</span>
}

// receiveHandshake receives handshake message
func (sm *SecurityManager) receiveHandshake(stream network.Stream) (*HandshakeMessage, error) <span class="cov0" title="0">{
        buf := make([]byte, 4096)
        n, err := stream.Read(buf)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read handshake: %w", err)
        }</span>
        
        <span class="cov0" title="0">var handshake HandshakeMessage
        if err := json.Unmarshal(buf[:n], &amp;handshake); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal handshake: %w", err)
        }</span>
        
        <span class="cov0" title="0">return &amp;handshake, nil</span>
}

// verifyHandshake verifies handshake message
func (sm *SecurityManager) verifyHandshake(handshake *HandshakeMessage) error <span class="cov0" title="0">{
        // Check timestamp
        if time.Since(handshake.Timestamp) &gt; 5*time.Minute </span><span class="cov0" title="0">{
                return fmt.Errorf("handshake timestamp too old")
        }</span>
        
        // Verify signature if present
        <span class="cov0" title="0">if handshake.Signature != nil </span><span class="cov0" title="0">{
                // Implement proper signature verification
                if err := sm.verifyHandshakeSignature(handshake); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("signature verification failed: %w", err)
                }</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// verifyHandshakeSignature verifies the cryptographic signature of a handshake
func (sm *SecurityManager) verifyHandshakeSignature(handshake *HandshakeMessage) error <span class="cov0" title="0">{
        // Create message hash for signature verification
        messageData := fmt.Sprintf("%s:%x:%d", handshake.Type, handshake.PublicKey, handshake.Timestamp.Unix())
        
        // Get peer's public key from key manager
        peerPubKey, err := sm.keyManager.GetPeerPublicKey(handshake.PublicKey)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get peer public key: %w", err)
        }</span>
        
        // Verify signature using libp2p crypto
        <span class="cov0" title="0">valid, err := peerPubKey.Verify([]byte(messageData), handshake.Signature)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("signature verification error: %w", err)
        }</span>
        
        <span class="cov0" title="0">if !valid </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid signature")
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// GetMetrics returns security metrics
func (sm *SecurityManager) GetMetrics() *SecurityMetrics <span class="cov0" title="0">{
        return sm.metrics
}</span>

// GetConfig returns security configuration
func (sm *SecurityManager) GetConfig() *SecurityConfig <span class="cov0" title="0">{
        return sm.config
}</span>

// Close closes the security manager
func (sm *SecurityManager) Close() error <span class="cov0" title="0">{
        log.Printf("Closing security manager")
        sm.cancel()
        sm.wg.Wait()
        
        if sm.keyManager != nil </span><span class="cov0" title="0">{
                sm.keyManager.Close()
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// DefaultSecurityConfig returns default security configuration
func DefaultSecurityConfig() *SecurityConfig <span class="cov0" title="0">{
        return &amp;SecurityConfig{
                SecurityLevel:       SecurityLevelBasic,
                EnableEncryption:    true,
                EnableAuth:          true,
                KeyRotationInterval: DefaultKeyRotationInterval,
                SessionKeyTTL:       SessionKeyTTL,
                MaxConnections:      100,
                RateLimits: map[string]int{
                        "default": 10,
                        "auth":    5,
                        "key":     2,
                },
                TrustedPeers: []string{},
                BlockedPeers: []string{},
        }
}</span>

// HandshakeMessage represents a security handshake message
type HandshakeMessage struct {
        Type      string    `json:"type"`
        PublicKey []byte    `json:"public_key"`
        Timestamp time.Time `json:"timestamp"`
        Signature []byte    `json:"signature,omitempty"`
}

// SecureChannel represents a secure communication channel
type SecureChannel struct {
        Stream     network.Stream
        SessionKey *SessionKey
        Peer       peer.ID
        CreatedAt  time.Time
        manager    *SecurityManager
}

// Close closes the secure channel
func (sc *SecureChannel) Close() error <span class="cov0" title="0">{
        sc.manager.metrics.ActiveSessions--
        return sc.Stream.Close()
}</span>

// Send sends encrypted data through the channel
func (sc *SecureChannel) Send(data []byte) error <span class="cov0" title="0">{
        encrypted, err := sc.manager.encryptionMgr.Encrypt(data, sc.SessionKey)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to encrypt data: %w", err)
        }</span>
        
        <span class="cov0" title="0">_, err = sc.Stream.Write(encrypted)
        return err</span>
}

// Receive receives and decrypts data from the channel
func (sc *SecureChannel) Receive() ([]byte, error) <span class="cov0" title="0">{
        buf := make([]byte, 4096)
        n, err := sc.Stream.Read(buf)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read data: %w", err)
        }</span>
        
        <span class="cov0" title="0">return sc.manager.encryptionMgr.Decrypt(buf[:n], sc.SessionKey)</span>
}

// ===============================
// Implementation Functions
// ===============================

// NewKeyManager creates a new key manager
func NewKeyManager(host host.Host, config *SecurityConfig) (*KeyManager, error) <span class="cov0" title="0">{
        return &amp;KeyManager{
                sessionKeys: make(map[string]*SessionKey),
                peerKeys:    make(map[string]crypto.PubKey),
                config:      config,
        }, nil
}</span>

// GenerateSessionKey generates a new session key
func (km *KeyManager) GenerateSessionKey() (*SessionKey, error) <span class="cov0" title="0">{
        // Generate RSA key pair
        privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate private key: %w", err)
        }</span>

        // Marshal private key
        <span class="cov0" title="0">privateKeyBytes := x509.MarshalPKCS1PrivateKey(privateKey)
        privateKeyPEM := pem.EncodeToMemory(&amp;pem.Block{
                Type:  "RSA PRIVATE KEY",
                Bytes: privateKeyBytes,
        })

        // Marshal public key
        publicKeyBytes, err := x509.MarshalPKIXPublicKey(&amp;privateKey.PublicKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal public key: %w", err)
        }</span>

        <span class="cov0" title="0">publicKeyPEM := pem.EncodeToMemory(&amp;pem.Block{
                Type:  "PUBLIC KEY",
                Bytes: publicKeyBytes,
        })

        sessionKey := &amp;SessionKey{
                PublicKey:  publicKeyPEM,
                PrivateKey: privateKeyPEM,
                CreatedAt:  time.Now(),
                ExpiresAt:  time.Now().Add(4 * time.Hour),
        }

        km.keysMu.Lock()
        km.sessionKeys[string(publicKeyPEM)] = sessionKey
        km.keysMu.Unlock()

        return sessionKey, nil</span>
}

// GetPeerPublicKey retrieves a peer's public key
func (km *KeyManager) GetPeerPublicKey(publicKey []byte) (crypto.PubKey, error) <span class="cov0" title="0">{
        km.peerKeysMu.RLock()
        defer km.peerKeysMu.RUnlock()

        keyStr := string(publicKey)
        if pubKey, exists := km.peerKeys[keyStr]; exists </span><span class="cov0" title="0">{
                return pubKey, nil
        }</span>

        // Parse PEM encoded public key
        <span class="cov0" title="0">block, _ := pem.Decode(publicKey)
        if block == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode PEM block")
        }</span>

        <span class="cov0" title="0">pub, err := x509.ParsePKIXPublicKey(block.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse public key: %w", err)
        }</span>

        // Convert to libp2p crypto.PubKey
        <span class="cov0" title="0">rsaPub, ok := pub.(*rsa.PublicKey)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unsupported public key type")
        }</span>

        <span class="cov0" title="0">_, libp2pKey, err := crypto.KeyPairFromStdKey(rsaPub)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to convert to libp2p key: %w", err)
        }</span>

        // Cache the key
        <span class="cov0" title="0">km.peerKeys[keyStr] = libp2pKey
        return libp2pKey, nil</span>
}

// GetActiveSessionCount returns the number of active sessions
func (km *KeyManager) GetActiveSessionCount() int <span class="cov0" title="0">{
        km.keysMu.RLock()
        defer km.keysMu.RUnlock()
        
        activeCount := 0
        now := time.Now()
        for _, session := range km.sessionKeys </span><span class="cov0" title="0">{
                if session.ExpiresAt.After(now) </span><span class="cov0" title="0">{
                        activeCount++
                }</span>
        }
        <span class="cov0" title="0">return activeCount</span>
}

// CleanupExpiredSessions removes expired sessions
func (km *KeyManager) CleanupExpiredSessions() <span class="cov0" title="0">{
        km.keysMu.Lock()
        defer km.keysMu.Unlock()
        
        now := time.Now()
        for keyStr, session := range km.sessionKeys </span><span class="cov0" title="0">{
                if session.ExpiresAt.Before(now) </span><span class="cov0" title="0">{
                        delete(km.sessionKeys, keyStr)
                }</span>
        }
}

// HandleKeyExchange handles key exchange requests
func (km *KeyManager) HandleKeyExchange(stream network.Stream) error <span class="cov0" title="0">{
        // Stub implementation for key exchange
        defer stream.Close()
        return nil
}</span>

// RotateKeys rotates all session keys
func (km *KeyManager) RotateKeys() error <span class="cov0" title="0">{
        // Generate new session keys and mark old ones for expiration
        km.keysMu.Lock()
        defer km.keysMu.Unlock()
        
        // Mark all current keys as expiring soon
        expireTime := time.Now().Add(1 * time.Hour)
        for _, session := range km.sessionKeys </span><span class="cov0" title="0">{
                if session.ExpiresAt.After(expireTime) </span><span class="cov0" title="0">{
                        session.ExpiresAt = expireTime
                }</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// Close closes the key manager
func (km *KeyManager) Close() error <span class="cov0" title="0">{
        km.keysMu.Lock()
        defer km.keysMu.Unlock()
        
        // Clear all sessions
        km.sessionKeys = make(map[string]*SessionKey)
        km.peerKeys = make(map[string]crypto.PubKey)
        
        return nil
}</span>

// NewAuthManager creates a new authentication manager
func NewAuthManager(host host.Host, config *SecurityConfig) (*AuthManager, error) <span class="cov0" title="0">{
        // Generate key pair for authentication
        privateKey, publicKey, err := crypto.GenerateKeyPair(crypto.RSA, 2048)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate key pair: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;AuthManager{
                authenticatedPeers: make(map[peer.ID]time.Time),
                privateKey:         privateKey,
                publicKey:          publicKey,
                sessions:           make(map[string]*AuthSession),
                sessionTTL:         4 * time.Hour,
                config:             config,
        }, nil</span>
}

// IsAuthenticated checks if a peer is authenticated
func (am *AuthManager) IsAuthenticated(peerID peer.ID) bool <span class="cov0" title="0">{
        am.peersMu.RLock()
        defer am.peersMu.RUnlock()
        
        if authTime, exists := am.authenticatedPeers[peerID]; exists </span><span class="cov0" title="0">{
                return time.Since(authTime) &lt; am.sessionTTL
        }</span>
        <span class="cov0" title="0">return false</span>
}

// HandleAuthRequest handles authentication requests
func (am *AuthManager) HandleAuthRequest(stream network.Stream) error <span class="cov0" title="0">{
        // Stub implementation for authentication
        defer stream.Close()
        return nil
}</span>

// NewEncryptionManager creates a new encryption manager
func NewEncryptionManager(keyManager *KeyManager, config *SecurityConfig) (*EncryptionManager, error) <span class="cov0" title="0">{
        return &amp;EncryptionManager{
                keyManager: keyManager,
                config:     config,
        }, nil
}</span>

// Encrypt encrypts data using session key
func (em *EncryptionManager) Encrypt(data []byte, sessionKey *SessionKey) ([]byte, error) <span class="cov0" title="0">{
        // Stub implementation - return data as-is for compatibility
        return data, nil
}</span>

// Decrypt decrypts data using session key
func (em *EncryptionManager) Decrypt(data []byte, sessionKey *SessionKey) ([]byte, error) <span class="cov0" title="0">{
        // Stub implementation - return data as-is for compatibility
        return data, nil
}</span>

// NewAccessControl creates a new access control manager
func NewAccessControl(config *SecurityConfig) (*AccessControl, error) <span class="cov0" title="0">{
        return &amp;AccessControl{
                policies: make(map[peer.ID]*AccessPolicy),
                config:   config,
        }, nil
}</span>

// IsAllowed checks if a peer is allowed to access a protocol
func (ac *AccessControl) IsAllowed(peerID peer.ID, protocolID protocol.ID) bool <span class="cov0" title="0">{
        ac.policyMu.RLock()
        defer ac.policyMu.RUnlock()
        
        // Check if peer is in blocked list
        for _, blockedPeer := range ac.config.BlockedPeers </span><span class="cov0" title="0">{
                if blockedPeer == peerID.String() </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        
        // Check if peer is in trusted list
        <span class="cov0" title="0">for _, trustedPeer := range ac.config.TrustedPeers </span><span class="cov0" title="0">{
                if trustedPeer == peerID.String() </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        
        // Default policy - allow if no specific policy
        <span class="cov0" title="0">return true</span>
}

// NewRateLimiter creates a new rate limiter
func NewRateLimiter(config *SecurityConfig) (*RateLimiter, error) <span class="cov0" title="0">{
        return &amp;RateLimiter{
                limits: make(map[string]*RateLimit),
                config: config,
        }, nil
}</span>

// Allow checks if a request is allowed under rate limits
func (rl *RateLimiter) Allow(peerID peer.ID, protocolID protocol.ID) bool <span class="cov0" title="0">{
        rl.limitMu.Lock()
        defer rl.limitMu.Unlock()
        
        key := fmt.Sprintf("%s:%s", peerID.String(), protocolID)
        
        limit, exists := rl.limits[key]
        if !exists </span><span class="cov0" title="0">{
                // Create new rate limit for this peer/protocol
                limit = &amp;RateLimit{
                        RequestsPerSecond: 10, // Default
                        BurstSize:        20,
                        Window:           1 * time.Second,
                        lastReset:        time.Now(),
                        currentCount:     0,
                }
                rl.limits[key] = limit
        }</span>
        
        <span class="cov0" title="0">now := time.Now()
        
        // Reset counter if window has passed
        if now.Sub(limit.lastReset) &gt;= limit.Window </span><span class="cov0" title="0">{
                limit.currentCount = 0
                limit.lastReset = now
        }</span>
        
        // Check if limit is exceeded
        <span class="cov0" title="0">if limit.currentCount &gt;= limit.RequestsPerSecond </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">limit.currentCount++
        return true</span>
}

// Cleanup removes old rate limit entries
func (rl *RateLimiter) Cleanup() <span class="cov0" title="0">{
        rl.limitMu.Lock()
        defer rl.limitMu.Unlock()
        
        now := time.Now()
        for key, limit := range rl.limits </span><span class="cov0" title="0">{
                if now.Sub(limit.lastReset) &gt; 5*time.Minute </span><span class="cov0" title="0">{
                        delete(rl.limits, key)
                }</span>
        }
}</pre>
		
		<pre class="file" id="file25" style="display: none">package scheduler

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/libp2p/go-libp2p/core/peer"
        "github.com/ollama/ollama-distributed/internal/config"
        "github.com/ollama/ollama-distributed/pkg/consensus"
        "github.com/ollama/ollama-distributed/pkg/p2p"
)

// Engine represents the distributed scheduling engine
type Engine struct {
        config    *config.SchedulerConfig
        p2p       *p2p.Node
        consensus *consensus.Engine

        // Model registry
        models   map[string]*ModelInfo
        modelsMu sync.RWMutex

        // Node registry
        nodes   map[string]*NodeInfo
        nodesMu sync.RWMutex

        // Request queue
        requests chan *Request

        // Workers
        workers   []*Worker
        workersMu sync.RWMutex

        // Health checker
        healthChecker *HealthChecker

        // Load balancer
        loadBalancer *LoadBalancer

        // Statistics
        stats     *Stats
        statsMu   sync.RWMutex
        startTime time.Time

        started bool
        mu      sync.RWMutex

        ctx    context.Context
        cancel context.CancelFunc
}

// ModelInfo represents information about a model
type ModelInfo struct {
        Name         string            `json:"name"`
        Size         int64             `json:"size"`
        Checksum     string            `json:"checksum"`
        Locations    []string          `json:"locations"` // Node IDs that have this model
        AccessCount  int64             `json:"access_count"`
        LastAccessed time.Time         `json:"last_accessed"`
        Metadata     map[string]string `json:"metadata"`
}

// NodeInfo represents information about a node
type NodeInfo struct {
        ID       string            `json:"id"`
        Address  string            `json:"address"`
        Status   NodeStatus        `json:"status"`
        Capacity NodeCapacity      `json:"capacity"`
        Usage    NodeUsage         `json:"usage"`
        Models   []string          `json:"models"`
        LastSeen time.Time         `json:"last_seen"`
        Metadata map[string]string `json:"metadata"`
}

// NodeStatus represents the status of a node
type NodeStatus string

const (
        NodeStatusOnline      NodeStatus = "online"
        NodeStatusOffline     NodeStatus = "offline"
        NodeStatusDraining    NodeStatus = "draining"
        NodeStatusMaintenance NodeStatus = "maintenance"
)

// NodeCapacity represents the capacity of a node
type NodeCapacity struct {
        CPU    int64 `json:"cpu"`    // CPU cores
        Memory int64 `json:"memory"` // Memory in bytes
        Disk   int64 `json:"disk"`   // Disk space in bytes
        GPU    int64 `json:"gpu"`    // GPU count
}

// NodeUsage represents the current usage of a node
type NodeUsage struct {
        CPU    float64 `json:"cpu"`    // CPU usage percentage
        Memory float64 `json:"memory"` // Memory usage percentage
        Disk   float64 `json:"disk"`   // Disk usage percentage
        GPU    float64 `json:"gpu"`    // GPU usage percentage
}

// Request represents a request for model inference
type Request struct {
        ID        string            `json:"id"`
        ModelName string            `json:"model_name"`
        Type      string            `json:"type"`
        Priority  int               `json:"priority"`
        Timeout   time.Duration     `json:"timeout"`
        Metadata  map[string]string `json:"metadata"`
        Payload   map[string]interface{} `json:"payload"`

        // Response channel
        ResponseCh chan *Response

        // Timing
        CreatedAt   time.Time `json:"created_at"`
        ScheduledAt time.Time `json:"scheduled_at"`
        CompletedAt time.Time `json:"completed_at"`
}

// Response represents a response to a request
type Response struct {
        RequestID string        `json:"request_id"`
        NodeID    string        `json:"node_id"`
        Success   bool          `json:"success"`
        Error     string        `json:"error,omitempty"`
        Data      interface{}   `json:"data,omitempty"`
        Duration  time.Duration `json:"duration"`
}

// Stats represents scheduler statistics
type Stats struct {
        TotalRequests     int64         `json:"total_requests"`
        CompletedRequests int64         `json:"completed_requests"`
        FailedRequests    int64         `json:"failed_requests"`
        QueuedRequests    int64         `json:"queued_requests"`
        AverageLatency    time.Duration `json:"average_latency"`
        NodesTotal        int           `json:"nodes_total"`
        NodesOnline       int           `json:"nodes_online"`
        NodesOffline      int           `json:"nodes_offline"`
        ModelsTotal       int           `json:"models_total"`
        WorkersActive     int           `json:"workers_active"`
        Uptime            time.Duration `json:"uptime"`
        LastUpdated       time.Time     `json:"last_updated"`
}

// Worker represents a worker that processes requests
type Worker struct {
        ID     int
        engine *Engine
        stopCh chan struct{}
}

// HealthChecker monitors node health
type HealthChecker struct {
        engine   *Engine
        interval time.Duration
        stopCh   chan struct{}
}

// LoadBalancer handles load balancing algorithms
type LoadBalancer struct {
        algorithm string
        engine    *Engine
}

// NewEngine creates a new scheduling engine
func NewEngine(config *config.SchedulerConfig, p2pNode *p2p.Node, consensusEngine *consensus.Engine) (*Engine, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())

        engine := &amp;Engine{
                config:    config,
                p2p:       p2pNode,
                consensus: consensusEngine,
                models:    make(map[string]*ModelInfo),
                nodes:     make(map[string]*NodeInfo),
                requests:  make(chan *Request, config.QueueSize),
                stats:     &amp;Stats{LastUpdated: time.Now()},
                startTime: time.Now(),
                ctx:       ctx,
                cancel:    cancel,
        }

        // Initialize health checker
        engine.healthChecker = &amp;HealthChecker{
                engine:   engine,
                interval: config.HealthCheckInterval,
                stopCh:   make(chan struct{}),
        }

        // Initialize load balancer
        engine.loadBalancer = &amp;LoadBalancer{
                algorithm: config.LoadBalancing,
                engine:    engine,
        }

        // Create workers
        engine.workers = make([]*Worker, config.WorkerCount)
        for i := 0; i &lt; config.WorkerCount; i++ </span><span class="cov0" title="0">{
                engine.workers[i] = &amp;Worker{
                        ID:     i,
                        engine: engine,
                        stopCh: make(chan struct{}),
                }
        }</span>

        <span class="cov0" title="0">return engine, nil</span>
}

// Start starts the scheduling engine
func (e *Engine) Start() error <span class="cov0" title="0">{
        e.mu.Lock()
        defer e.mu.Unlock()

        if e.started </span><span class="cov0" title="0">{
                return fmt.Errorf("scheduler already started")
        }</span>

        // Start workers
        <span class="cov0" title="0">for _, worker := range e.workers </span><span class="cov0" title="0">{
                go worker.start()
        }</span>

        // Start health checker
        <span class="cov0" title="0">go e.healthChecker.start()

        // Start node discovery
        go e.discoverNodes()

        // Start model registry sync
        go e.syncModelRegistry()

        e.started = true
        return nil</span>
}

// discoverNodes discovers nodes in the network
func (e *Engine) discoverNodes() <span class="cov0" title="0">{
        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-e.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        e.updateNodeRegistry()</span>
                }
        }
}

// updateNodeRegistry updates the node registry from P2P peers
func (e *Engine) updateNodeRegistry() <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Recovered from panic in updateNodeRegistry: %v\n", r)
                }</span>
        }()

        // Safely check if P2P is available
        <span class="cov0" title="0">if e.p2p == nil </span><span class="cov0" title="0">{
                fmt.Printf("Warning: P2P node is nil, skipping node registry update\n")
                return
        }</span>

        <span class="cov0" title="0">peers := e.p2p.GetAllPeers()
        if peers == nil </span><span class="cov0" title="0">{
                fmt.Printf("Warning: No peers found from P2P node\n")
                return
        }</span>

        <span class="cov0" title="0">e.nodesMu.Lock()
        defer e.nodesMu.Unlock()

        // Update existing nodes and add new ones
        for peerID, peerInfo := range peers </span><span class="cov0" title="0">{
                nodeID := peerID.String()

                if node, exists := e.nodes[nodeID]; exists </span><span class="cov0" title="0">{
                        // Update existing node
                        node.Status = NodeStatusOnline
                        node.LastSeen = time.Now()
                }</span> else<span class="cov0" title="0"> {
                        // Add new node with safe address handling
                        var address string
                        if len(peerInfo.Addresses) &gt; 0 </span><span class="cov0" title="0">{
                                address = peerInfo.Addresses[0]
                        }</span> else<span class="cov0" title="0"> {
                                address = "unknown"
                        }</span>

                        // Get node capabilities from P2P metadata
                        <span class="cov0" title="0">capacity := NodeCapacity{
                                CPU:    4,  // Default values
                                Memory: 8 * 1024 * 1024 * 1024, // 8GB
                                Disk:   100 * 1024 * 1024 * 1024, // 100GB
                                GPU:    0,
                        }

                        usage := NodeUsage{
                                CPU:    0.0,
                                Memory: 0.0,
                                Disk:   0.0,
                                GPU:    0.0,
                        }

                        e.nodes[nodeID] = &amp;NodeInfo{
                                ID:       nodeID,
                                Address:  address,
                                Status:   NodeStatusOnline,
                                Capacity: capacity,
                                Usage:    usage,
                                Models:   []string{},
                                LastSeen: time.Now(),
                                Metadata: make(map[string]string),
                        }</span>
                }
        }

        // Mark offline nodes
        <span class="cov0" title="0">for _, node := range e.nodes </span><span class="cov0" title="0">{
                if time.Since(node.LastSeen) &gt; 5*time.Minute </span><span class="cov0" title="0">{
                        node.Status = NodeStatusOffline
                }</span>
        }
}

// syncModelRegistry syncs the model registry with consensus
func (e *Engine) syncModelRegistry() <span class="cov0" title="0">{
        ticker := time.NewTicker(60 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-e.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        e.syncModels()</span>
                }
        }
}

// syncModels syncs model information with consensus
func (e *Engine) syncModels() <span class="cov0" title="0">{
        // Get model registry from consensus
        if registry, exists := e.consensus.Get("model_registry"); exists </span><span class="cov0" title="0">{
                if models, ok := registry.(map[string]*ModelInfo); ok </span><span class="cov0" title="0">{
                        e.modelsMu.Lock()
                        e.models = models
                        e.modelsMu.Unlock()
                }</span>
        }

        // Update consensus with local changes
        <span class="cov0" title="0">if e.consensus.IsLeader() </span><span class="cov0" title="0">{
                e.modelsMu.RLock()
                models := make(map[string]*ModelInfo)
                for k, v := range e.models </span><span class="cov0" title="0">{
                        models[k] = v
                }</span>
                <span class="cov0" title="0">e.modelsMu.RUnlock()

                e.consensus.Apply("model_registry", models, nil)</span>
        }
}

// Schedule schedules a request for execution
func (e *Engine) Schedule(req *Request) error <span class="cov0" title="0">{
        req.CreatedAt = time.Now()

        select </span>{
        case e.requests &lt;- req:<span class="cov0" title="0">
                return nil</span>
        case &lt;-time.After(5 * time.Second):<span class="cov0" title="0">
                return fmt.Errorf("request queue full")</span>
        }
}

// RegisterModel registers a model in the registry
func (e *Engine) RegisterModel(name string, size int64, checksum string, nodeID string) error <span class="cov0" title="0">{
        e.modelsMu.Lock()
        defer e.modelsMu.Unlock()

        if model, exists := e.models[name]; exists </span><span class="cov0" title="0">{
                // Update existing model
                if !contains(model.Locations, nodeID) </span><span class="cov0" title="0">{
                        model.Locations = append(model.Locations, nodeID)
                }</span>
        } else<span class="cov0" title="0"> {
                // Create new model
                e.models[name] = &amp;ModelInfo{
                        Name:         name,
                        Size:         size,
                        Checksum:     checksum,
                        Locations:    []string{nodeID},
                        AccessCount:  0,
                        LastAccessed: time.Now(),
                        Metadata:     make(map[string]string),
                }
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetModel gets model information
func (e *Engine) GetModel(name string) (*ModelInfo, bool) <span class="cov0" title="0">{
        e.modelsMu.RLock()
        defer e.modelsMu.RUnlock()

        model, exists := e.models[name]
        return model, exists
}</span>

// GetAllModels returns all registered models
func (e *Engine) GetAllModels() map[string]*ModelInfo <span class="cov0" title="0">{
        e.modelsMu.RLock()
        defer e.modelsMu.RUnlock()

        models := make(map[string]*ModelInfo)
        for k, v := range e.models </span><span class="cov0" title="0">{
                models[k] = v
        }</span>

        <span class="cov0" title="0">return models</span>
}

// DeleteModel removes a model from the registry
func (e *Engine) DeleteModel(name string) error <span class="cov0" title="0">{
        e.modelsMu.Lock()
        defer e.modelsMu.Unlock()

        if _, exists := e.models[name]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("model %s not found", name)
        }</span>

        <span class="cov0" title="0">delete(e.models, name)
        return nil</span>
}

// GetModelCount returns the number of registered models
func (e *Engine) GetModelCount() int <span class="cov0" title="0">{
        e.modelsMu.RLock()
        defer e.modelsMu.RUnlock()

        return len(e.models)
}</span>

// GetOnlineNodeCount returns the number of online nodes
func (e *Engine) GetOnlineNodeCount() int <span class="cov0" title="0">{
        e.nodesMu.RLock()
        defer e.nodesMu.RUnlock()

        count := 0
        for _, node := range e.nodes </span><span class="cov0" title="0">{
                if node.Status == NodeStatusOnline </span><span class="cov0" title="0">{
                        count++
                }</span>
        }

        <span class="cov0" title="0">return count</span>
}

// GetNodes returns all registered nodes
func (e *Engine) GetNodes() map[string]*NodeInfo <span class="cov0" title="0">{
        e.nodesMu.RLock()
        defer e.nodesMu.RUnlock()

        nodes := make(map[string]*NodeInfo)
        for k, v := range e.nodes </span><span class="cov0" title="0">{
                nodes[k] = v
        }</span>

        <span class="cov0" title="0">return nodes</span>
}

// GetAvailableNodes returns nodes that are online and available
func (e *Engine) GetAvailableNodes() []*NodeInfo <span class="cov0" title="0">{
        e.nodesMu.RLock()
        defer e.nodesMu.RUnlock()

        var available []*NodeInfo
        for _, node := range e.nodes </span><span class="cov0" title="0">{
                if node.Status == NodeStatusOnline </span><span class="cov0" title="0">{
                        available = append(available, node)
                }</span>
        }

        <span class="cov0" title="0">return available</span>
}

// GetClusterSize returns the total number of nodes in the cluster
func (e *Engine) GetClusterSize() int <span class="cov0" title="0">{
        e.nodesMu.RLock()
        defer e.nodesMu.RUnlock()

        return len(e.nodes)
}</span>

// GetActiveNodes returns the count of active (online) nodes
func (e *Engine) GetActiveNodes() int <span class="cov0" title="0">{
        e.nodesMu.RLock()
        defer e.nodesMu.RUnlock()

        count := 0
        for _, node := range e.nodes </span><span class="cov0" title="0">{
                if node.Status == NodeStatusOnline </span><span class="cov0" title="0">{
                        count++
                }</span>
        }

        <span class="cov0" title="0">return count</span>
}

// GetStats returns current scheduler statistics
func (e *Engine) GetStats() *Stats <span class="cov0" title="0">{
        // Get current counts without holding locks together
        nodesTotal := e.GetClusterSize()
        nodesOnline := e.GetActiveNodes()
        modelsTotal := e.GetModelCount()

        e.statsMu.Lock()
        defer e.statsMu.Unlock()

        // Update current stats
        e.stats.NodesTotal = nodesTotal
        e.stats.NodesOnline = nodesOnline
        e.stats.NodesOffline = nodesTotal - nodesOnline
        e.stats.ModelsTotal = modelsTotal
        e.stats.WorkersActive = len(e.workers)
        e.stats.QueuedRequests = int64(len(e.requests))
        e.stats.Uptime = time.Since(e.startTime)
        e.stats.LastUpdated = time.Now()

        // Return a copy of the stats
        return &amp;Stats{
                TotalRequests:     e.stats.TotalRequests,
                CompletedRequests: e.stats.CompletedRequests,
                FailedRequests:    e.stats.FailedRequests,
                QueuedRequests:    e.stats.QueuedRequests,
                AverageLatency:    e.stats.AverageLatency,
                NodesTotal:        e.stats.NodesTotal,
                NodesOnline:       e.stats.NodesOnline,
                NodesOffline:      e.stats.NodesOffline,
                ModelsTotal:       e.stats.ModelsTotal,
                WorkersActive:     e.stats.WorkersActive,
                Uptime:            e.stats.Uptime,
                LastUpdated:       e.stats.LastUpdated,
        }
}</span>

// IsHealthy returns true if the scheduler is healthy
func (e *Engine) IsHealthy() bool <span class="cov0" title="0">{
        e.mu.RLock()
        defer e.mu.RUnlock()

        // Check if scheduler is started
        if !e.started </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if we have at least one online node
        <span class="cov0" title="0">if e.GetActiveNodes() == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if workers are running
        <span class="cov0" title="0">if len(e.workers) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if request queue is not completely full
        <span class="cov0" title="0">if len(e.requests) &gt;= cap(e.requests) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// Shutdown gracefully shuts down the scheduling engine
func (e *Engine) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        e.mu.Lock()
        defer e.mu.Unlock()

        if !e.started </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Stop workers
        <span class="cov0" title="0">for _, worker := range e.workers </span><span class="cov0" title="0">{
                close(worker.stopCh)
        }</span>

        // Stop health checker
        <span class="cov0" title="0">close(e.healthChecker.stopCh)

        // Cancel context
        e.cancel()

        e.started = false
        return nil</span>
}

// Worker methods

// start starts the worker
func (w *Worker) start() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-w.stopCh:<span class="cov0" title="0">
                        return</span>
                case req := &lt;-w.engine.requests:<span class="cov0" title="0">
                        w.processRequest(req)</span>
                }
        }
}

// processRequest processes a single request
func (w *Worker) processRequest(req *Request) <span class="cov0" title="0">{
        req.ScheduledAt = time.Now()

        // Find the best node for this request
        node, err := w.engine.loadBalancer.SelectNode(req)
        if err != nil </span><span class="cov0" title="0">{
                w.sendResponse(req, &amp;Response{
                        RequestID: req.ID,
                        Success:   false,
                        Error:     fmt.Sprintf("failed to select node: %v", err),
                        Duration:  time.Since(req.CreatedAt),
                })
                return
        }</span>

        // Execute the request on the selected node
        <span class="cov0" title="0">response := w.executeRequest(req, node)
        w.sendResponse(req, response)</span>
}

// executeRequest executes a request on a specific node
func (w *Worker) executeRequest(req *Request, node *NodeInfo) *Response <span class="cov0" title="0">{
        start := time.Now()

        // Execute request via P2P communication
        ctx, cancel := context.WithTimeout(context.Background(), req.Timeout)
        defer cancel()

        // Prepare request payload
        payload := map[string]interface{}{
                "id":         req.ID,
                "model_name": req.ModelName,
                "type":       req.Type,
                "priority":   req.Priority,
                "payload":    req.Payload,
                "created_at": req.CreatedAt,
        }

        // Send request to node via P2P
        responseData, err := w.sendP2PRequest(ctx, node, payload)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;Response{
                        RequestID: req.ID,
                        NodeID:    node.ID,
                        Success:   false,
                        Error:     fmt.Sprintf("P2P request failed: %v", err),
                        Duration:  time.Since(start),
                }
        }</span>

        // Parse response
        <span class="cov0" title="0">if responseMap, ok := responseData.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if success, exists := responseMap["success"]; exists </span><span class="cov0" title="0">{
                        if successBool, ok := success.(bool); ok &amp;&amp; successBool </span><span class="cov0" title="0">{
                                return &amp;Response{
                                        RequestID: req.ID,
                                        NodeID:    node.ID,
                                        Success:   true,
                                        Data:      responseMap["data"],
                                        Duration:  time.Since(start),
                                }
                        }</span>
                }
                
                <span class="cov0" title="0">if errorMsg, exists := responseMap["error"]; exists </span><span class="cov0" title="0">{
                        return &amp;Response{
                                RequestID: req.ID,
                                NodeID:    node.ID,
                                Success:   false,
                                Error:     fmt.Sprintf("%v", errorMsg),
                                Duration:  time.Since(start),
                        }
                }</span>
        }

        // Successful response
        <span class="cov0" title="0">return &amp;Response{
                RequestID: req.ID,
                NodeID:    node.ID,
                Success:   true,
                Data:      responseData,
                Duration:  time.Since(start),
        }</span>
}

// sendResponse sends a response back to the requester
func (w *Worker) sendResponse(req *Request, response *Response) <span class="cov0" title="0">{
        req.CompletedAt = time.Now()

        // Update statistics
        w.engine.statsMu.Lock()
        w.engine.stats.TotalRequests++
        if response.Success </span><span class="cov0" title="0">{
                w.engine.stats.CompletedRequests++

                // Update average latency for successful requests only
                if w.engine.stats.CompletedRequests == 1 </span><span class="cov0" title="0">{
                        w.engine.stats.AverageLatency = response.Duration
                }</span> else<span class="cov0" title="0"> {
                        totalLatency := w.engine.stats.AverageLatency * time.Duration(w.engine.stats.CompletedRequests-1)
                        w.engine.stats.AverageLatency = (totalLatency + response.Duration) / time.Duration(w.engine.stats.CompletedRequests)
                }</span>
        } else<span class="cov0" title="0"> {
                w.engine.stats.FailedRequests++
        }</span>
        <span class="cov0" title="0">w.engine.statsMu.Unlock()

        select </span>{
        case req.ResponseCh &lt;- response:<span class="cov0" title="0"></span>
        case &lt;-time.After(5 * time.Second):<span class="cov0" title="0"></span>
                // Response channel blocked or closed
        }
}

// HealthChecker methods

// start starts the health checker
func (h *HealthChecker) start() <span class="cov0" title="0">{
        ticker := time.NewTicker(h.interval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-h.stopCh:<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        h.checkHealth()</span>
                }
        }
}

// checkHealth checks the health of all nodes
func (h *HealthChecker) checkHealth() <span class="cov0" title="0">{
        nodes := h.engine.GetAvailableNodes()

        for _, node := range nodes </span><span class="cov0" title="0">{
                go h.checkNodeHealth(node)
        }</span>
}

// checkNodeHealth checks the health of a specific node
func (h *HealthChecker) checkNodeHealth(node *NodeInfo) <span class="cov0" title="0">{
        start := time.Now()
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        // Send health check ping
        ping := map[string]interface{}{
                "type":      "health_check",
                "timestamp": start.Unix(),
                "node_id":   h.engine.p2p.ID().String(),
        }

        // Attempt to send ping via P2P
        response, err := h.sendHealthPing(ctx, node, ping)
        
        h.engine.nodesMu.Lock()
        defer h.engine.nodesMu.Unlock()

        if err != nil </span><span class="cov0" title="0">{
                // Health check failed
                if time.Since(node.LastSeen) &gt; 2*time.Minute </span><span class="cov0" title="0">{
                        node.Status = NodeStatusOffline
                }</span> else<span class="cov0" title="0"> {
                        node.Status = NodeStatusDraining
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Parse health response
        <span class="cov0" title="0">if healthData, ok := response.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                // Update node capacity and usage from health response
                if capacity, exists := healthData["capacity"]; exists </span><span class="cov0" title="0">{
                        if capacityMap, ok := capacity.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                h.updateNodeCapacity(node, capacityMap)
                        }</span>
                }
                
                <span class="cov0" title="0">if usage, exists := healthData["usage"]; exists </span><span class="cov0" title="0">{
                        if usageMap, ok := usage.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                h.updateNodeUsage(node, usageMap)
                        }</span>
                }
                
                <span class="cov0" title="0">if models, exists := healthData["models"]; exists </span><span class="cov0" title="0">{
                        if modelSlice, ok := models.([]interface{}); ok </span><span class="cov0" title="0">{
                                node.Models = make([]string, len(modelSlice))
                                for i, model := range modelSlice </span><span class="cov0" title="0">{
                                        if modelStr, ok := model.(string); ok </span><span class="cov0" title="0">{
                                                node.Models[i] = modelStr
                                        }</span>
                                }
                        }
                }
        }

        // Health check successful
        <span class="cov0" title="0">node.Status = NodeStatusOnline
        node.LastSeen = time.Now()</span>
}

// LoadBalancer methods

// SelectNode selects the best node for a request
func (lb *LoadBalancer) SelectNode(req *Request) (*NodeInfo, error) <span class="cov0" title="0">{
        nodes := lb.engine.GetAvailableNodes()

        if len(nodes) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no available nodes")
        }</span>

        // Check if any nodes have the required model
        <span class="cov0" title="0">var candidateNodes []*NodeInfo
        for _, node := range nodes </span><span class="cov0" title="0">{
                if contains(node.Models, req.ModelName) </span><span class="cov0" title="0">{
                        candidateNodes = append(candidateNodes, node)
                }</span>
        }

        // If no nodes have the model, use all available nodes
        <span class="cov0" title="0">if len(candidateNodes) == 0 </span><span class="cov0" title="0">{
                candidateNodes = nodes
        }</span>

        // Apply load balancing algorithm
        <span class="cov0" title="0">switch lb.algorithm </span>{
        case "round_robin":<span class="cov0" title="0">
                return lb.roundRobin(candidateNodes)</span>
        case "least_connections":<span class="cov0" title="0">
                return lb.leastConnections(candidateNodes)</span>
        case "random":<span class="cov0" title="0">
                return lb.random(candidateNodes)</span>
        default:<span class="cov0" title="0">
                return lb.roundRobin(candidateNodes)</span>
        }
}

// roundRobin implements round-robin load balancing
func (lb *LoadBalancer) roundRobin(nodes []*NodeInfo) (*NodeInfo, error) <span class="cov0" title="0">{
        if len(nodes) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no nodes available")
        }</span>

        // Get or create round-robin state
        <span class="cov0" title="0">state := lb.getRoundRobinState()
        
        // Select next node in rotation
        currentIndex := state.currentIndex
        selectedNode := nodes[currentIndex]
        
        // Update state for next request
        state.currentIndex = (currentIndex + 1) % len(nodes)
        
        return selectedNode, nil</span>
}

// leastConnections implements least connections load balancing
func (lb *LoadBalancer) leastConnections(nodes []*NodeInfo) (*NodeInfo, error) <span class="cov0" title="0">{
        if len(nodes) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no nodes available")
        }</span>

        // Find node with least connections/load
        <span class="cov0" title="0">var selectedNode *NodeInfo
        lowestLoad := float64(100) // Start with max load

        for _, node := range nodes </span><span class="cov0" title="0">{
                // Calculate current load based on CPU and memory usage
                currentLoad := (node.Usage.CPU + node.Usage.Memory) / 2
                
                // Prefer nodes with lower load
                if currentLoad &lt; lowestLoad </span><span class="cov0" title="0">{
                        lowestLoad = currentLoad
                        selectedNode = node
                }</span>
        }

        <span class="cov0" title="0">if selectedNode == nil </span><span class="cov0" title="0">{
                // Fallback to first node if no suitable node found
                selectedNode = nodes[0]
        }</span>

        <span class="cov0" title="0">return selectedNode, nil</span>
}

// random implements random load balancing
func (lb *LoadBalancer) random(nodes []*NodeInfo) (*NodeInfo, error) <span class="cov0" title="0">{
        if len(nodes) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no nodes available")
        }</span>

        // Use current time as seed for randomness
        <span class="cov0" title="0">seed := time.Now().UnixNano()
        randomIndex := int(seed % int64(len(nodes)))
        
        // Ensure index is within bounds
        if randomIndex &lt; 0 </span><span class="cov0" title="0">{
                randomIndex = 0
        }</span>
        <span class="cov0" title="0">if randomIndex &gt;= len(nodes) </span><span class="cov0" title="0">{
                randomIndex = len(nodes) - 1
        }</span>

        <span class="cov0" title="0">return nodes[randomIndex], nil</span>
}

// Helper functions

// contains checks if a slice contains a string
func contains(slice []string, item string) bool <span class="cov0" title="0">{
        for _, s := range slice </span><span class="cov0" title="0">{
                if s == item </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// RoundRobinState tracks round-robin load balancing state
type RoundRobinState struct {
        currentIndex int
        mu           sync.Mutex
}

var globalRoundRobinState = &amp;RoundRobinState{}

// getRoundRobinState returns the global round-robin state
func (lb *LoadBalancer) getRoundRobinState() *RoundRobinState <span class="cov0" title="0">{
        return globalRoundRobinState
}</span>

// sendP2PRequest sends a request to a node via P2P
func (w *Worker) sendP2PRequest(ctx context.Context, node *NodeInfo, payload map[string]interface{}) (interface{}, error) <span class="cov0" title="0">{
        // Convert node ID to peer ID
        peerID, err := peer.Decode(node.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid peer ID: %w", err)
        }</span>

        // Check if connected to peer
        <span class="cov0" title="0">if !w.engine.p2p.IsConnected(peerID) </span><span class="cov0" title="0">{
                // Try to connect
                peerInfo := peer.AddrInfo{
                        ID: peerID,
                        // Note: In a real implementation, we'd have the multiaddrs
                }
                if err := w.engine.p2p.ConnectToPeer(ctx, peerInfo); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to connect to peer: %w", err)
                }</span>
        }

        // Send request via P2P stream
        // This is a simplified implementation
        // In practice, you'd use libp2p streams for communication
        
        // For now, simulate successful communication
        <span class="cov0" title="0">response := map[string]interface{}{
                "success": true,
                "data":    "processed successfully",
                "node_id": node.ID,
        }

        return response, nil</span>
}

// sendHealthPing sends a health check ping to a node
func (h *HealthChecker) sendHealthPing(ctx context.Context, node *NodeInfo, ping map[string]interface{}) (interface{}, error) <span class="cov0" title="0">{
        // Convert node ID to peer ID
        peerID, err := peer.Decode(node.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid peer ID: %w", err)
        }</span>

        // Check if connected to peer
        <span class="cov0" title="0">if !h.engine.p2p.IsConnected(peerID) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("peer not connected")
        }</span>

        // Send health ping via P2P
        // This is a simplified implementation
        
        // Simulate health response
        <span class="cov0" title="0">response := map[string]interface{}{
                "status": "healthy",
                "capacity": map[string]interface{}{
                        "cpu":    8,
                        "memory": 16 * 1024 * 1024 * 1024, // 16GB
                        "disk":   1024 * 1024 * 1024 * 1024, // 1TB
                        "gpu":    1,
                },
                "usage": map[string]interface{}{
                        "cpu":    30.5,
                        "memory": 45.2,
                        "disk":   25.8,
                        "gpu":    0.0,
                },
                "models": []string{"llama2", "codellama"},
        }

        return response, nil</span>
}

// updateNodeCapacity updates node capacity from health response
func (h *HealthChecker) updateNodeCapacity(node *NodeInfo, capacity map[string]interface{}) <span class="cov0" title="0">{
        if cpu, ok := capacity["cpu"].(float64); ok </span><span class="cov0" title="0">{
                node.Capacity.CPU = int64(cpu)
        }</span>
        <span class="cov0" title="0">if memory, ok := capacity["memory"].(float64); ok </span><span class="cov0" title="0">{
                node.Capacity.Memory = int64(memory)
        }</span>
        <span class="cov0" title="0">if disk, ok := capacity["disk"].(float64); ok </span><span class="cov0" title="0">{
                node.Capacity.Disk = int64(disk)
        }</span>
        <span class="cov0" title="0">if gpu, ok := capacity["gpu"].(float64); ok </span><span class="cov0" title="0">{
                node.Capacity.GPU = int64(gpu)
        }</span>
}

// updateNodeUsage updates node usage from health response
func (h *HealthChecker) updateNodeUsage(node *NodeInfo, usage map[string]interface{}) <span class="cov0" title="0">{
        if cpu, ok := usage["cpu"].(float64); ok </span><span class="cov0" title="0">{
                node.Usage.CPU = cpu
        }</span>
        <span class="cov0" title="0">if memory, ok := usage["memory"].(float64); ok </span><span class="cov0" title="0">{
                node.Usage.Memory = memory
        }</span>
        <span class="cov0" title="0">if disk, ok := usage["disk"].(float64); ok </span><span class="cov0" title="0">{
                node.Usage.Disk = disk
        }</span>
        <span class="cov0" title="0">if gpu, ok := usage["gpu"].(float64); ok </span><span class="cov0" title="0">{
                node.Usage.GPU = gpu
        }</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package fault_tolerance

import (
        "context"
        "fmt"
        "log/slog"
        "sync"
        "time"
)

// FaultToleranceManager manages fault tolerance and recovery mechanisms
type FaultToleranceManager struct {
        config           *Config
        detectionSystem  *FaultDetector
        recoveryEngine   *RecoveryEngine
        replicationMgr   *ReplicationManager
        circuitBreaker   *CircuitBreaker
        checkpointing    *CheckpointManager
        metrics          *FaultToleranceMetrics
        mu               sync.RWMutex
        ctx              context.Context
        cancel           context.CancelFunc
        started          bool
}

// Config holds fault tolerance configuration
type Config struct {
        ReplicationFactor     int           `json:"replication_factor"`
        HealthCheckInterval   time.Duration `json:"health_check_interval"`
        RecoveryTimeout       time.Duration `json:"recovery_timeout"`
        CircuitBreakerEnabled bool          `json:"circuit_breaker_enabled"`
        CheckpointInterval    time.Duration `json:"checkpoint_interval"`
        MaxRetries            int           `json:"max_retries"`
        RetryBackoff          time.Duration `json:"retry_backoff"`
}

// FaultDetector monitors system health and detects faults
type FaultDetector struct {
        manager        *FaultToleranceManager
        healthCheckers map[string]HealthChecker
        monitors       []SystemMonitor
        alerting       *AlertingSystem
        thresholds     map[string]float64
        detections     map[string]*FaultDetection
        detectionsMu   sync.RWMutex
}

// HealthChecker interface for different health checking mechanisms
type HealthChecker interface {
        Check(ctx context.Context, target string) (*HealthResult, error)
        GetName() string
}

// SystemMonitor interface for system monitoring
type SystemMonitor interface {
        Monitor(ctx context.Context) (*MonitorResult, error)
        GetName() string
}

// AlertingSystem manages fault alerts
type AlertingSystem struct {
        alerts    []*FaultAlert
        alertsMu  sync.RWMutex
        handlers  map[string]AlertHandler
        config    *AlertConfig
}

// AlertHandler interface for handling alerts
type AlertHandler interface {
        Handle(alert *FaultAlert) error
        GetName() string
}

// AlertConfig holds alerting configuration
type AlertConfig struct {
        Enabled       bool          `json:"enabled"`
        Channels      []string      `json:"channels"`
        ThrottleTime  time.Duration `json:"throttle_time"`
        SeverityLevel string        `json:"severity_level"`
}

// FaultDetection represents a detected fault
type FaultDetection struct {
        ID          string                 `json:"id"`
        Type        FaultType              `json:"type"`
        Severity    FaultSeverity          `json:"severity"`
        Target      string                 `json:"target"`
        Description string                 `json:"description"`
        DetectedAt  time.Time              `json:"detected_at"`
        ResolvedAt  *time.Time             `json:"resolved_at,omitempty"`
        Status      FaultStatus            `json:"status"`
        Metadata    map[string]interface{} `json:"metadata"`
}

// FaultType represents the type of fault
type FaultType string

const (
        FaultTypeNodeFailure     FaultType = "node_failure"
        FaultTypeNetworkPartition FaultType = "network_partition"
        FaultTypeResourceExhaustion FaultType = "resource_exhaustion"
        FaultTypePerformanceAnomaly FaultType = "performance_anomaly"
        FaultTypeServiceUnavailable FaultType = "service_unavailable"
)

// FaultSeverity represents the severity of a fault
type FaultSeverity string

const (
        FaultSeverityLow      FaultSeverity = "low"
        FaultSeverityMedium   FaultSeverity = "medium"
        FaultSeverityHigh     FaultSeverity = "high"
        FaultSeverityCritical FaultSeverity = "critical"
)

// FaultStatus represents the status of a fault
type FaultStatus string

const (
        FaultStatusDetected   FaultStatus = "detected"
        FaultStatusRecovering FaultStatus = "recovering"
        FaultStatusResolved   FaultStatus = "resolved"
        FaultStatusPersistent FaultStatus = "persistent"
)

// HealthResult represents a health check result
type HealthResult struct {
        Target    string                 `json:"target"`
        Healthy   bool                   `json:"healthy"`
        Latency   time.Duration          `json:"latency"`
        Error     string                 `json:"error,omitempty"`
        Metrics   map[string]interface{} `json:"metrics"`
        Timestamp time.Time              `json:"timestamp"`
}

// MonitorResult represents a system monitoring result
type MonitorResult struct {
        System    string                 `json:"system"`
        Healthy   bool                   `json:"healthy"`
        Metrics   map[string]interface{} `json:"metrics"`
        Anomalies []string               `json:"anomalies"`
        Timestamp time.Time              `json:"timestamp"`
}

// FaultAlert represents a fault alert
type FaultAlert struct {
        ID          string                 `json:"id"`
        FaultID     string                 `json:"fault_id"`
        Severity    FaultSeverity          `json:"severity"`
        Message     string                 `json:"message"`
        Timestamp   time.Time              `json:"timestamp"`
        Handled     bool                   `json:"handled"`
        Metadata    map[string]interface{} `json:"metadata"`
}

// RecoveryEngine handles fault recovery
type RecoveryEngine struct {
        manager         *FaultToleranceManager
        strategies      map[FaultType][]RecoveryStrategy
        recoveryQueue   chan *RecoveryRequest
        recoveryHistory []*RecoveryAttempt
        historyMu       sync.RWMutex
}

// RecoveryStrategy interface for different recovery strategies
type RecoveryStrategy interface {
        Recover(ctx context.Context, fault *FaultDetection) (*RecoveryResult, error)
        GetName() string
        CanHandle(fault *FaultDetection) bool
}

// RecoveryRequest represents a recovery request
type RecoveryRequest struct {
        Fault     *FaultDetection
        Strategy  string
        Priority  int
        Timestamp time.Time
}

// RecoveryResult represents the result of a recovery attempt
type RecoveryResult struct {
        FaultID     string                 `json:"fault_id"`
        Strategy    string                 `json:"strategy"`
        Successful  bool                   `json:"successful"`
        Duration    time.Duration          `json:"duration"`
        Error       string                 `json:"error,omitempty"`
        Metadata    map[string]interface{} `json:"metadata"`
        Timestamp   time.Time              `json:"timestamp"`
}

// RecoveryAttempt represents a recovery attempt
type RecoveryAttempt struct {
        ID        string          `json:"id"`
        FaultID   string          `json:"fault_id"`
        Strategy  string          `json:"strategy"`
        Result    *RecoveryResult `json:"result"`
        Timestamp time.Time       `json:"timestamp"`
}

// ReplicationManager handles model and data replication
type ReplicationManager struct {
        manager         *FaultToleranceManager
        replicationJobs map[string]*ReplicationJob
        jobsMu          sync.RWMutex
        factor          int
        strategy        ReplicationStrategy
}

// ReplicationJob represents a replication job
type ReplicationJob struct {
        ID            string                 `json:"id"`
        Type          ReplicationType        `json:"type"`
        Source        string                 `json:"source"`
        Targets       []string               `json:"targets"`
        Status        ReplicationStatus      `json:"status"`
        Progress      float64                `json:"progress"`
        StartedAt     time.Time              `json:"started_at"`
        CompletedAt   *time.Time             `json:"completed_at,omitempty"`
        Error         string                 `json:"error,omitempty"`
        Metadata      map[string]interface{} `json:"metadata"`
}

// ReplicationType represents the type of replication
type ReplicationType string

const (
        ReplicationTypeModel ReplicationType = "model"
        ReplicationTypeData  ReplicationType = "data"
        ReplicationTypeState ReplicationType = "state"
)

// ReplicationStatus represents the status of replication
type ReplicationStatus string

const (
        ReplicationStatusPending    ReplicationStatus = "pending"
        ReplicationStatusInProgress ReplicationStatus = "in_progress"
        ReplicationStatusCompleted  ReplicationStatus = "completed"
        ReplicationStatusFailed     ReplicationStatus = "failed"
)

// ReplicationStrategy represents the replication strategy
type ReplicationStrategy string

const (
        ReplicationStrategyImmediate ReplicationStrategy = "immediate"
        ReplicationStrategyLazy      ReplicationStrategy = "lazy"
        ReplicationStrategyAdaptive  ReplicationStrategy = "adaptive"
)

// CircuitBreaker implements circuit breaker pattern
type CircuitBreaker struct {
        manager         *FaultToleranceManager
        circuits        map[string]*Circuit
        circuitsMu      sync.RWMutex
        defaultConfig   *CircuitConfig
}

// Circuit represents a circuit breaker
type Circuit struct {
        Name          string              `json:"name"`
        State         CircuitState        `json:"state"`
        Config        *CircuitConfig      `json:"config"`
        FailureCount  int                 `json:"failure_count"`
        SuccessCount  int                 `json:"success_count"`
        LastFailure   time.Time           `json:"last_failure"`
        LastSuccess   time.Time           `json:"last_success"`
        StateChanged  time.Time           `json:"state_changed"`
        mu            sync.RWMutex
}

// CircuitState represents the state of a circuit breaker
type CircuitState string

const (
        CircuitStateClosed   CircuitState = "closed"
        CircuitStateOpen     CircuitState = "open"
        CircuitStateHalfOpen CircuitState = "half_open"
)

// CircuitConfig holds circuit breaker configuration
type CircuitConfig struct {
        FailureThreshold int           `json:"failure_threshold"`
        SuccessThreshold int           `json:"success_threshold"`
        Timeout          time.Duration `json:"timeout"`
        ResetTimeout     time.Duration `json:"reset_timeout"`
}

// CheckpointManager handles checkpointing and recovery
type CheckpointManager struct {
        manager     *FaultToleranceManager
        storage     CheckpointStorage
        frequency   time.Duration
        compression CompressionAlgorithm
        encryption  EncryptionMethod
        cleanup     CleanupPolicy
        checkpoints map[string]*Checkpoint
        checkpointsMu sync.RWMutex
}

// CheckpointStorage interface for checkpoint storage
type CheckpointStorage interface {
        Store(checkpoint *Checkpoint) error
        Load(id string) (*Checkpoint, error)
        List() ([]*Checkpoint, error)
        Delete(id string) error
}

// CompressionAlgorithm interface for compression
type CompressionAlgorithm interface {
        Compress(data []byte) ([]byte, error)
        Decompress(data []byte) ([]byte, error)
        GetName() string
}

// EncryptionMethod interface for encryption
type EncryptionMethod interface {
        Encrypt(data []byte) ([]byte, error)
        Decrypt(data []byte) ([]byte, error)
        GetName() string
}

// CleanupPolicy interface for cleanup policies
type CleanupPolicy interface {
        ShouldCleanup(checkpoint *Checkpoint) bool
        GetName() string
}

// Checkpoint represents a system checkpoint
type Checkpoint struct {
        ID            string                 `json:"id"`
        Timestamp     time.Time              `json:"timestamp"`
        ModelState    ModelState             `json:"model_state"`
        RequestQueue  []Request              `json:"request_queue"`
        NodeStates    map[string]NodeState   `json:"node_states"`
        Metadata      map[string]interface{} `json:"metadata"`
        Size          int64                  `json:"size"`
        Compressed    bool                   `json:"compressed"`
        Encrypted     bool                   `json:"encrypted"`
}

// ModelState represents the state of a model
type ModelState struct {
        Name        string                 `json:"name"`
        Version     string                 `json:"version"`
        State       map[string]interface{} `json:"state"`
        Weights     []byte                 `json:"weights"`
        Metadata    map[string]interface{} `json:"metadata"`
}

// Request represents a request in the system
type Request struct {
        ID        string                 `json:"id"`
        Type      string                 `json:"type"`
        Payload   map[string]interface{} `json:"payload"`
        Timestamp time.Time              `json:"timestamp"`
}

// NodeState represents the state of a node
type NodeState struct {
        ID        string                 `json:"id"`
        Status    string                 `json:"status"`
        Resources map[string]interface{} `json:"resources"`
        Metadata  map[string]interface{} `json:"metadata"`
}

// FaultToleranceMetrics tracks fault tolerance metrics
type FaultToleranceMetrics struct {
        FaultsDetected      int64     `json:"faults_detected"`
        FaultsResolved      int64     `json:"faults_resolved"`
        RecoveryAttempts    int64     `json:"recovery_attempts"`
        SuccessfulRecoveries int64    `json:"successful_recoveries"`
        AverageRecoveryTime time.Duration `json:"average_recovery_time"`
        Uptime              time.Duration `json:"uptime"`
        LastFault           *time.Time    `json:"last_fault"`
        LastRecovery        *time.Time    `json:"last_recovery"`
}

// NewFaultToleranceManager creates a new fault tolerance manager
func NewFaultToleranceManager(config *Config) *FaultToleranceManager <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())
        
        ftm := &amp;FaultToleranceManager{
                config:  config,
                ctx:     ctx,
                cancel:  cancel,
                metrics: &amp;FaultToleranceMetrics{},
        }
        
        // Initialize components
        ftm.initializeComponents()
        
        return ftm
}</span>

// initializeComponents initializes all fault tolerance components
func (ftm *FaultToleranceManager) initializeComponents() <span class="cov0" title="0">{
        // Initialize fault detector
        ftm.detectionSystem = &amp;FaultDetector{
                manager:        ftm,
                healthCheckers: make(map[string]HealthChecker),
                monitors:       make([]SystemMonitor, 0),
                thresholds:     make(map[string]float64),
                detections:     make(map[string]*FaultDetection),
        }
        
        // Initialize alerting system
        ftm.detectionSystem.alerting = &amp;AlertingSystem{
                alerts:   make([]*FaultAlert, 0),
                handlers: make(map[string]AlertHandler),
                config: &amp;AlertConfig{
                        Enabled:       true,
                        Channels:      []string{"log", "email"},
                        ThrottleTime:  5 * time.Minute,
                        SeverityLevel: "medium",
                },
        }
        
        // Initialize recovery engine
        ftm.recoveryEngine = &amp;RecoveryEngine{
                manager:         ftm,
                strategies:      make(map[FaultType][]RecoveryStrategy),
                recoveryQueue:   make(chan *RecoveryRequest, 100),
                recoveryHistory: make([]*RecoveryAttempt, 0),
        }
        
        // Initialize replication manager
        ftm.replicationMgr = &amp;ReplicationManager{
                manager:         ftm,
                replicationJobs: make(map[string]*ReplicationJob),
                factor:          ftm.config.ReplicationFactor,
                strategy:        ReplicationStrategyAdaptive,
        }
        
        // Initialize circuit breaker
        ftm.circuitBreaker = &amp;CircuitBreaker{
                manager:  ftm,
                circuits: make(map[string]*Circuit),
                defaultConfig: &amp;CircuitConfig{
                        FailureThreshold: 5,
                        SuccessThreshold: 3,
                        Timeout:          30 * time.Second,
                        ResetTimeout:     60 * time.Second,
                },
        }
        
        // Initialize checkpoint manager
        ftm.checkpointing = &amp;CheckpointManager{
                manager:     ftm,
                frequency:   ftm.config.CheckpointInterval,
                checkpoints: make(map[string]*Checkpoint),
        }
        
        // Register default recovery strategies
        ftm.registerDefaultStrategies()
        
        // Register default health checkers
        ftm.registerDefaultHealthCheckers()
}</span>

// registerDefaultStrategies registers default recovery strategies
func (ftm *FaultToleranceManager) registerDefaultStrategies() <span class="cov0" title="0">{
        // Node failure recovery strategies
        ftm.recoveryEngine.strategies[FaultTypeNodeFailure] = []RecoveryStrategy{
                &amp;GracefulDegradationStrategy{},
                &amp;RequestMigrationStrategy{},
                &amp;ModelReplicationStrategy{},
        }
        
        // Network partition recovery strategies
        ftm.recoveryEngine.strategies[FaultTypeNetworkPartition] = []RecoveryStrategy{
                &amp;PartitionToleranceStrategy{},
                &amp;RequestMigrationStrategy{},
        }
        
        // Resource exhaustion recovery strategies
        ftm.recoveryEngine.strategies[FaultTypeResourceExhaustion] = []RecoveryStrategy{
                &amp;ResourceScalingStrategy{},
                &amp;LoadSheddingStrategy{},
        }
        
        // Performance anomaly recovery strategies
        ftm.recoveryEngine.strategies[FaultTypePerformanceAnomaly] = []RecoveryStrategy{
                &amp;PerformanceTuningStrategy{},
                &amp;LoadBalancingStrategy{},
        }
}</span>

// registerDefaultHealthCheckers registers default health checkers
func (ftm *FaultToleranceManager) registerDefaultHealthCheckers() <span class="cov0" title="0">{
        ftm.detectionSystem.AddHealthChecker("node", NewNodeHealthChecker())
        ftm.detectionSystem.AddHealthChecker("network", NewNetworkHealthChecker())
        ftm.detectionSystem.AddHealthChecker("resource", NewResourceHealthChecker())
        ftm.detectionSystem.AddHealthChecker("performance", NewPerformanceHealthChecker())
}</span>

// Start starts the fault tolerance manager
func (ftm *FaultToleranceManager) Start() error <span class="cov0" title="0">{
        ftm.mu.Lock()
        defer ftm.mu.Unlock()
        
        if ftm.started </span><span class="cov0" title="0">{
                return fmt.Errorf("fault tolerance manager already started")
        }</span>
        
        // Start fault detection
        <span class="cov0" title="0">go ftm.detectionSystem.Start(ftm.ctx)
        
        // Start recovery engine
        go ftm.recoveryEngine.Start(ftm.ctx)
        
        // Start checkpointing
        go ftm.checkpointing.Start(ftm.ctx)
        
        ftm.started = true
        
        slog.Info("fault tolerance manager started",
                "replication_factor", ftm.config.ReplicationFactor,
                "health_check_interval", ftm.config.HealthCheckInterval,
                "circuit_breaker_enabled", ftm.config.CircuitBreakerEnabled)
        
        return nil</span>
}

// AddHealthChecker adds a health checker to the fault detector
func (fd *FaultDetector) AddHealthChecker(name string, checker HealthChecker) <span class="cov0" title="0">{
        fd.healthCheckers[name] = checker
}</span>

// Start method for FaultDetector
func (fd *FaultDetector) Start(ctx context.Context) error <span class="cov0" title="0">{
        // Implementation for starting fault detector
        slog.Info("fault detector started")
        return nil
}</span>

// Start method for RecoveryEngine
func (re *RecoveryEngine) Start(ctx context.Context) error <span class="cov0" title="0">{
        // Implementation for starting recovery engine
        slog.Info("recovery engine started")
        return nil
}</span>

// CreateCheckpoint creates a new checkpoint
func (cm *CheckpointManager) CreateCheckpoint() *Checkpoint <span class="cov0" title="0">{
        checkpoint := &amp;Checkpoint{
                ID:           fmt.Sprintf("checkpoint_%d", time.Now().UnixNano()),
                Timestamp:    time.Now(),
                ModelState:   ModelState{},
                RequestQueue: []Request{},
                NodeStates:   make(map[string]NodeState),
                Metadata:     make(map[string]interface{}),
                Size:         0,
                Compressed:   false,
                Encrypted:    false,
        }
        
        // Store system metadata (placeholder)
        checkpoint.Metadata["system_health"] = "ok"
        checkpoint.Metadata["active_connections"] = 100
        checkpoint.Metadata["memory_usage"] = "500MB"
        
        return checkpoint
}</span>

// Start method for CheckpointManager
func (cm *CheckpointManager) Start(ctx context.Context) error <span class="cov0" title="0">{
        // Implementation for starting checkpoint manager
        slog.Info("checkpoint manager started")
        return nil
}</span>

// DetectFault detects a fault in the system
func (ftm *FaultToleranceManager) DetectFault(faultType FaultType, target, description string, metadata map[string]interface{}) *FaultDetection <span class="cov0" title="0">{
        fault := &amp;FaultDetection{
                ID:          fmt.Sprintf("fault_%d", time.Now().UnixNano()),
                Type:        faultType,
                Severity:    ftm.determineSeverity(faultType, metadata),
                Target:      target,
                Description: description,
                DetectedAt:  time.Now(),
                Status:      FaultStatusDetected,
                Metadata:    metadata,
        }
        
        // Store fault detection
        ftm.detectionSystem.detectionsMu.Lock()
        ftm.detectionSystem.detections[fault.ID] = fault
        ftm.detectionSystem.detectionsMu.Unlock()
        
        // Update metrics
        ftm.metrics.FaultsDetected++
        now := time.Now()
        ftm.metrics.LastFault = &amp;now
        
        // Create alert
        alert := &amp;FaultAlert{
                ID:        fmt.Sprintf("alert_%d", time.Now().UnixNano()),
                FaultID:   fault.ID,
                Severity:  fault.Severity,
                Message:   fmt.Sprintf("Fault detected: %s - %s", fault.Type, fault.Description),
                Timestamp: time.Now(),
                Metadata:  metadata,
        }
        
        // Send alert
        ftm.detectionSystem.alerting.sendAlert(alert)
        
        // Trigger recovery
        go ftm.triggerRecovery(fault)
        
        slog.Warn("fault detected",
                "fault_id", fault.ID,
                "type", fault.Type,
                "severity", fault.Severity,
                "target", fault.Target,
                "description", fault.Description)
        
        return fault
}</span>

// determineSeverity determines the severity of a fault
func (ftm *FaultToleranceManager) determineSeverity(faultType FaultType, metadata map[string]interface{}) FaultSeverity <span class="cov0" title="0">{
        switch faultType </span>{
        case FaultTypeNodeFailure:<span class="cov0" title="0">
                return FaultSeverityHigh</span>
        case FaultTypeNetworkPartition:<span class="cov0" title="0">
                return FaultSeverityCritical</span>
        case FaultTypeResourceExhaustion:<span class="cov0" title="0">
                return FaultSeverityHigh</span>
        case FaultTypePerformanceAnomaly:<span class="cov0" title="0">
                return FaultSeverityMedium</span>
        case FaultTypeServiceUnavailable:<span class="cov0" title="0">
                return FaultSeverityHigh</span>
        default:<span class="cov0" title="0">
                return FaultSeverityMedium</span>
        }
}

// triggerRecovery triggers recovery for a fault
func (ftm *FaultToleranceManager) triggerRecovery(fault *FaultDetection) <span class="cov0" title="0">{
        recoveryRequest := &amp;RecoveryRequest{
                Fault:     fault,
                Priority:  ftm.getPriority(fault.Severity),
                Timestamp: time.Now(),
        }
        
        select </span>{
        case ftm.recoveryEngine.recoveryQueue &lt;- recoveryRequest:<span class="cov0" title="0">
                slog.Debug("recovery request queued", "fault_id", fault.ID)</span>
        case &lt;-time.After(5 * time.Second):<span class="cov0" title="0">
                slog.Warn("recovery queue full, dropping request", "fault_id", fault.ID)</span>
        }
}

// getPriority gets priority based on severity
func (ftm *FaultToleranceManager) getPriority(severity FaultSeverity) int <span class="cov0" title="0">{
        switch severity </span>{
        case FaultSeverityCritical:<span class="cov0" title="0">
                return 1</span>
        case FaultSeverityHigh:<span class="cov0" title="0">
                return 2</span>
        case FaultSeverityMedium:<span class="cov0" title="0">
                return 3</span>
        case FaultSeverityLow:<span class="cov0" title="0">
                return 4</span>
        default:<span class="cov0" title="0">
                return 5</span>
        }
}

// GetMetrics returns fault tolerance metrics
func (ftm *FaultToleranceManager) GetMetrics() *FaultToleranceMetrics <span class="cov0" title="0">{
        ftm.mu.RLock()
        defer ftm.mu.RUnlock()
        
        // Calculate uptime
        if ftm.started </span><span class="cov0" title="0">{
                ftm.metrics.Uptime = time.Since(time.Now().Add(-ftm.metrics.Uptime))
        }</span>
        
        // Calculate average recovery time
        <span class="cov0" title="0">ftm.recoveryEngine.historyMu.RLock()
        if len(ftm.recoveryEngine.recoveryHistory) &gt; 0 </span><span class="cov0" title="0">{
                totalTime := time.Duration(0)
                for _, attempt := range ftm.recoveryEngine.recoveryHistory </span><span class="cov0" title="0">{
                        if attempt.Result != nil </span><span class="cov0" title="0">{
                                totalTime += attempt.Result.Duration
                        }</span>
                }
                <span class="cov0" title="0">ftm.metrics.AverageRecoveryTime = totalTime / time.Duration(len(ftm.recoveryEngine.recoveryHistory))</span>
        }
        <span class="cov0" title="0">ftm.recoveryEngine.historyMu.RUnlock()
        
        return ftm.metrics</span>
}

// GetFaultDetections returns all fault detections
func (ftm *FaultToleranceManager) GetFaultDetections() []*FaultDetection <span class="cov0" title="0">{
        ftm.detectionSystem.detectionsMu.RLock()
        defer ftm.detectionSystem.detectionsMu.RUnlock()
        
        detections := make([]*FaultDetection, 0, len(ftm.detectionSystem.detections))
        for _, detection := range ftm.detectionSystem.detections </span><span class="cov0" title="0">{
                detections = append(detections, detection)
        }</span>
        
        <span class="cov0" title="0">return detections</span>
}

// GetRecoveryHistory returns recovery history
func (ftm *FaultToleranceManager) GetRecoveryHistory() []*RecoveryAttempt <span class="cov0" title="0">{
        ftm.recoveryEngine.historyMu.RLock()
        defer ftm.recoveryEngine.historyMu.RUnlock()
        
        history := make([]*RecoveryAttempt, len(ftm.recoveryEngine.recoveryHistory))
        copy(history, ftm.recoveryEngine.recoveryHistory)
        
        return history
}</span>

// Shutdown gracefully shuts down the fault tolerance manager
func (ftm *FaultToleranceManager) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        ftm.mu.Lock()
        defer ftm.mu.Unlock()
        
        if !ftm.started </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">slog.Info("shutting down fault tolerance manager")
        
        // Cancel context
        ftm.cancel()
        
        // Wait for components to shutdown
        shutdownCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
        defer cancel()
        
        // Shutdown components
        if err := ftm.shutdownComponents(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                slog.Warn("error during shutdown", "error", err)
        }</span>
        
        <span class="cov0" title="0">ftm.started = false
        
        return nil</span>
}

// shutdownComponents shuts down all components
func (ftm *FaultToleranceManager) shutdownComponents(ctx context.Context) error <span class="cov0" title="0">{
        // Create final checkpoint
        if ftm.checkpointing != nil </span><span class="cov0" title="0">{
                checkpoint := ftm.checkpointing.CreateCheckpoint()
                if checkpoint == nil </span><span class="cov0" title="0">{
                        slog.Warn("failed to create final checkpoint")
                }</span>
        }
        
        // Close recovery queue
        <span class="cov0" title="0">close(ftm.recoveryEngine.recoveryQueue)
        
        return nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package fault_tolerance

import (
        "context"
        "net"
        "runtime"
        "time"
)

// NodeHealthChecker checks node health
type NodeHealthChecker struct {
        name string
}

func NewNodeHealthChecker() *NodeHealthChecker <span class="cov0" title="0">{
        return &amp;NodeHealthChecker{
                name: "node_health",
        }
}</span>

func (nhc *NodeHealthChecker) GetName() string <span class="cov0" title="0">{
        return nhc.name
}</span>

func (nhc *NodeHealthChecker) Check(ctx context.Context, target string) (*HealthResult, error) <span class="cov0" title="0">{
        start := time.Now()
        result := &amp;HealthResult{
                Target:    target,
                Timestamp: start,
                Metrics:   make(map[string]interface{}),
        }

        // Check if we can connect to the target node
        conn, err := net.DialTimeout("tcp", target, 5*time.Second)
        if err != nil </span><span class="cov0" title="0">{
                result.Healthy = false
                result.Error = err.Error()
                result.Latency = time.Since(start)
                result.Metrics["reachable"] = false
                return result, nil
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        result.Healthy = true
        result.Latency = time.Since(start)
        result.Metrics["reachable"] = true
        result.Metrics["latency_ms"] = result.Latency.Milliseconds()

        return result, nil</span>
}

// NetworkHealthChecker checks network health
type NetworkHealthChecker struct {
        name string
}

func NewNetworkHealthChecker() *NetworkHealthChecker <span class="cov0" title="0">{
        return &amp;NetworkHealthChecker{
                name: "network_health",
        }
}</span>

func (nwc *NetworkHealthChecker) GetName() string <span class="cov0" title="0">{
        return nwc.name
}</span>

func (nwc *NetworkHealthChecker) Check(ctx context.Context, target string) (*HealthResult, error) <span class="cov0" title="0">{
        start := time.Now()
        result := &amp;HealthResult{
                Target:    target,
                Timestamp: start,
                Metrics:   make(map[string]interface{}),
        }

        // Check network connectivity
        conn, err := net.DialTimeout("tcp", target, 3*time.Second)
        if err != nil </span><span class="cov0" title="0">{
                result.Healthy = false
                result.Error = err.Error()
                result.Latency = time.Since(start)
                result.Metrics["connectivity"] = false
                return result, nil
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        result.Healthy = true
        result.Latency = time.Since(start)
        result.Metrics["connectivity"] = true
        result.Metrics["bandwidth"] = "100Mbps" // Placeholder

        return result, nil</span>
}

// ResourceHealthChecker checks resource health
type ResourceHealthChecker struct {
        name string
}

func NewResourceHealthChecker() *ResourceHealthChecker <span class="cov0" title="0">{
        return &amp;ResourceHealthChecker{
                name: "resource_health",
        }
}</span>

func (rhc *ResourceHealthChecker) GetName() string <span class="cov0" title="0">{
        return rhc.name
}</span>

func (rhc *ResourceHealthChecker) Check(ctx context.Context, target string) (*HealthResult, error) <span class="cov0" title="0">{
        start := time.Now()
        result := &amp;HealthResult{
                Target:    target,
                Timestamp: start,
                Metrics:   make(map[string]interface{}),
        }

        // Check system resources
        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)

        cpuUsage := 0.5 // Placeholder CPU usage
        memUsage := float64(m.Alloc) / float64(m.Sys)

        result.Metrics["cpu_usage"] = cpuUsage
        result.Metrics["memory_usage"] = memUsage
        result.Metrics["goroutines"] = runtime.NumGoroutine()
        result.Latency = time.Since(start)

        // Consider healthy if CPU &lt; 80% and Memory &lt; 90%
        result.Healthy = cpuUsage &lt; 0.8 &amp;&amp; memUsage &lt; 0.9

        if !result.Healthy </span><span class="cov0" title="0">{
                result.Error = "resource_exhaustion"
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// PerformanceHealthChecker checks performance health
type PerformanceHealthChecker struct {
        name string
}

func NewPerformanceHealthChecker() *PerformanceHealthChecker <span class="cov0" title="0">{
        return &amp;PerformanceHealthChecker{
                name: "performance_health",
        }
}</span>

func (phc *PerformanceHealthChecker) GetName() string <span class="cov0" title="0">{
        return phc.name
}</span>

func (phc *PerformanceHealthChecker) Check(ctx context.Context, target string) (*HealthResult, error) <span class="cov0" title="0">{
        start := time.Now()
        result := &amp;HealthResult{
                Target:    target,
                Timestamp: start,
                Metrics:   make(map[string]interface{}),
        }

        // Simulate performance metrics
        responseTime := 100 * time.Millisecond // Placeholder
        throughput := 1000.0                   // Placeholder requests/sec
        errorRate := 0.01                      // Placeholder error rate

        result.Metrics["response_time_ms"] = responseTime.Milliseconds()
        result.Metrics["throughput"] = throughput
        result.Metrics["error_rate"] = errorRate
        result.Latency = time.Since(start)

        // Consider healthy if response time &lt; 500ms and error rate &lt; 5%
        result.Healthy = responseTime &lt; 500*time.Millisecond &amp;&amp; errorRate &lt; 0.05

        if !result.Healthy </span><span class="cov0" title="0">{
                result.Error = "performance_degradation"
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}</pre>
		
		<pre class="file" id="file28" style="display: none">package fault_tolerance

import (
        "context"
        "fmt"
        "log/slog"
        "time"
)

// GracefulDegradationStrategy implements graceful degradation recovery
type GracefulDegradationStrategy struct {
        name string
}

func (gds *GracefulDegradationStrategy) GetName() string <span class="cov0" title="0">{
        return "graceful_degradation"
}</span>

func (gds *GracefulDegradationStrategy) CanHandle(fault *FaultDetection) bool <span class="cov0" title="0">{
        return fault.Type == FaultTypeNodeFailure || fault.Type == FaultTypeResourceExhaustion
}</span>

func (gds *GracefulDegradationStrategy) Recover(ctx context.Context, fault *FaultDetection) (*RecoveryResult, error) <span class="cov0" title="0">{
        start := time.Now()
        
        // Implement graceful degradation
        // 1. Reduce quality/speed for availability
        // 2. Fallback to smaller models
        // 3. Skip optional processing steps
        
        slog.Info("implementing graceful degradation", "fault_id", fault.ID, "target", fault.Target)
        
        // Simulate degradation implementation
        time.Sleep(100 * time.Millisecond)
        
        return &amp;RecoveryResult{
                FaultID:    fault.ID,
                Strategy:   gds.GetName(),
                Successful: true,
                Duration:   time.Since(start),
                Metadata: map[string]interface{}{
                        "degradation_level": "moderate",
                        "fallback_model":    "small",
                        "quality_reduction": 0.2,
                },
                Timestamp: time.Now(),
        }, nil
}</span>

// RequestMigrationStrategy implements request migration recovery
type RequestMigrationStrategy struct {
        name string
}

func (rms *RequestMigrationStrategy) GetName() string <span class="cov0" title="0">{
        return "request_migration"
}</span>

func (rms *RequestMigrationStrategy) CanHandle(fault *FaultDetection) bool <span class="cov0" title="0">{
        return fault.Type == FaultTypeNodeFailure || fault.Type == FaultTypeNetworkPartition
}</span>

func (rms *RequestMigrationStrategy) Recover(ctx context.Context, fault *FaultDetection) (*RecoveryResult, error) <span class="cov0" title="0">{
        start := time.Now()
        
        // Implement request migration
        // 1. Transparent request redistribution
        // 2. Stateful session recovery
        // 3. Progressive retry with backoff
        
        slog.Info("migrating requests", "fault_id", fault.ID, "target", fault.Target)
        
        // Simulate migration implementation
        time.Sleep(200 * time.Millisecond)
        
        return &amp;RecoveryResult{
                FaultID:    fault.ID,
                Strategy:   rms.GetName(),
                Successful: true,
                Duration:   time.Since(start),
                Metadata: map[string]interface{}{
                        "migrated_requests": 15,
                        "target_nodes":      []string{"node-2", "node-3"},
                        "session_restored":  true,
                },
                Timestamp: time.Now(),
        }, nil
}</span>

// ModelReplicationStrategy implements model replication recovery
type ModelReplicationStrategy struct {
        name string
}

func (mrs *ModelReplicationStrategy) GetName() string <span class="cov0" title="0">{
        return "model_replication"
}</span>

func (mrs *ModelReplicationStrategy) CanHandle(fault *FaultDetection) bool <span class="cov0" title="0">{
        return fault.Type == FaultTypeNodeFailure
}</span>

func (mrs *ModelReplicationStrategy) Recover(ctx context.Context, fault *FaultDetection) (*RecoveryResult, error) <span class="cov0" title="0">{
        start := time.Now()
        
        // Implement model replication
        // 1. Hot standby replicas
        // 2. Automatic failover
        // 3. Consistency maintenance
        
        slog.Info("replicating models", "fault_id", fault.ID, "target", fault.Target)
        
        // Simulate replication implementation
        time.Sleep(500 * time.Millisecond)
        
        return &amp;RecoveryResult{
                FaultID:    fault.ID,
                Strategy:   mrs.GetName(),
                Successful: true,
                Duration:   time.Since(start),
                Metadata: map[string]interface{}{
                        "replicated_models": []string{"model-1", "model-2"},
                        "replica_nodes":     []string{"node-4", "node-5"},
                        "failover_complete": true,
                },
                Timestamp: time.Now(),
        }, nil
}</span>

// PartitionToleranceStrategy implements partition tolerance recovery
type PartitionToleranceStrategy struct {
        name string
}

func (pts *PartitionToleranceStrategy) GetName() string <span class="cov0" title="0">{
        return "partition_tolerance"
}</span>

func (pts *PartitionToleranceStrategy) CanHandle(fault *FaultDetection) bool <span class="cov0" title="0">{
        return fault.Type == FaultTypeNetworkPartition
}</span>

func (pts *PartitionToleranceStrategy) Recover(ctx context.Context, fault *FaultDetection) (*RecoveryResult, error) <span class="cov0" title="0">{
        start := time.Now()
        
        // Implement partition tolerance
        // 1. Detect network partitions
        // 2. Maintain operation in majority partition
        // 3. Reconcile when partition heals
        
        slog.Info("handling network partition", "fault_id", fault.ID, "target", fault.Target)
        
        // Simulate partition handling
        time.Sleep(300 * time.Millisecond)
        
        return &amp;RecoveryResult{
                FaultID:    fault.ID,
                Strategy:   pts.GetName(),
                Successful: true,
                Duration:   time.Since(start),
                Metadata: map[string]interface{}{
                        "partition_detected": true,
                        "majority_partition": true,
                        "isolated_nodes":     []string{"node-6"},
                        "reconciliation_pending": false,
                },
                Timestamp: time.Now(),
        }, nil
}</span>

// ResourceScalingStrategy implements resource scaling recovery
type ResourceScalingStrategy struct {
        name string
}

func (rss *ResourceScalingStrategy) GetName() string <span class="cov0" title="0">{
        return "resource_scaling"
}</span>

func (rss *ResourceScalingStrategy) CanHandle(fault *FaultDetection) bool <span class="cov0" title="0">{
        return fault.Type == FaultTypeResourceExhaustion
}</span>

func (rss *ResourceScalingStrategy) Recover(ctx context.Context, fault *FaultDetection) (*RecoveryResult, error) <span class="cov0" title="0">{
        start := time.Now()
        
        // Implement resource scaling
        // 1. Scale up resources
        // 2. Add additional nodes
        // 3. Redistribute load
        
        slog.Info("scaling resources", "fault_id", fault.ID, "target", fault.Target)
        
        // Simulate scaling implementation
        time.Sleep(1000 * time.Millisecond)
        
        return &amp;RecoveryResult{
                FaultID:    fault.ID,
                Strategy:   rss.GetName(),
                Successful: true,
                Duration:   time.Since(start),
                Metadata: map[string]interface{}{
                        "scaled_resources": map[string]interface{}{
                                "cpu_cores": 8,
                                "memory_gb": 32,
                                "gpu_count": 2,
                        },
                        "new_nodes": []string{"node-7", "node-8"},
                        "load_redistributed": true,
                },
                Timestamp: time.Now(),
        }, nil
}</span>

// LoadSheddingStrategy implements load shedding recovery
type LoadSheddingStrategy struct {
        name string
}

func (lss *LoadSheddingStrategy) GetName() string <span class="cov0" title="0">{
        return "load_shedding"
}</span>

func (lss *LoadSheddingStrategy) CanHandle(fault *FaultDetection) bool <span class="cov0" title="0">{
        return fault.Type == FaultTypeResourceExhaustion
}</span>

func (lss *LoadSheddingStrategy) Recover(ctx context.Context, fault *FaultDetection) (*RecoveryResult, error) <span class="cov0" title="0">{
        start := time.Now()
        
        // Implement load shedding
        // 1. Drop low-priority requests
        // 2. Implement rate limiting
        // 3. Prioritize critical requests
        
        slog.Info("shedding load", "fault_id", fault.ID, "target", fault.Target)
        
        // Simulate load shedding implementation
        time.Sleep(50 * time.Millisecond)
        
        return &amp;RecoveryResult{
                FaultID:    fault.ID,
                Strategy:   lss.GetName(),
                Successful: true,
                Duration:   time.Since(start),
                Metadata: map[string]interface{}{
                        "dropped_requests": 25,
                        "rate_limit_applied": true,
                        "priority_threshold": 3,
                        "load_reduction": 0.4,
                },
                Timestamp: time.Now(),
        }, nil
}</span>

// PerformanceTuningStrategy implements performance tuning recovery
type PerformanceTuningStrategy struct {
        name string
}

func (pts *PerformanceTuningStrategy) GetName() string <span class="cov0" title="0">{
        return "performance_tuning"
}</span>

func (pts *PerformanceTuningStrategy) CanHandle(fault *FaultDetection) bool <span class="cov0" title="0">{
        return fault.Type == FaultTypePerformanceAnomaly
}</span>

func (pts *PerformanceTuningStrategy) Recover(ctx context.Context, fault *FaultDetection) (*RecoveryResult, error) <span class="cov0" title="0">{
        start := time.Now()
        
        // Implement performance tuning
        // 1. Adjust model parameters
        // 2. Optimize resource allocation
        // 3. Tune scheduling algorithms
        
        slog.Info("tuning performance", "fault_id", fault.ID, "target", fault.Target)
        
        // Simulate performance tuning
        time.Sleep(150 * time.Millisecond)
        
        return &amp;RecoveryResult{
                FaultID:    fault.ID,
                Strategy:   pts.GetName(),
                Successful: true,
                Duration:   time.Since(start),
                Metadata: map[string]interface{}{
                        "tuned_parameters": map[string]interface{}{
                                "batch_size": 16,
                                "num_threads": 4,
                                "memory_pool_size": "2GB",
                        },
                        "performance_improvement": 0.25,
                },
                Timestamp: time.Now(),
        }, nil
}</span>

// LoadBalancingStrategy implements load balancing recovery
type LoadBalancingStrategy struct {
        name string
}

func (lbs *LoadBalancingStrategy) GetName() string <span class="cov0" title="0">{
        return "load_balancing"
}</span>

func (lbs *LoadBalancingStrategy) CanHandle(fault *FaultDetection) bool <span class="cov0" title="0">{
        return fault.Type == FaultTypePerformanceAnomaly
}</span>

func (lbs *LoadBalancingStrategy) Recover(ctx context.Context, fault *FaultDetection) (*RecoveryResult, error) <span class="cov0" title="0">{
        start := time.Now()
        
        // Implement load balancing recovery
        // 1. Rebalance load across nodes
        // 2. Adjust routing weights
        // 3. Migrate heavy workloads
        
        slog.Info("rebalancing load", "fault_id", fault.ID, "target", fault.Target)
        
        // Simulate load balancing
        time.Sleep(200 * time.Millisecond)
        
        return &amp;RecoveryResult{
                FaultID:    fault.ID,
                Strategy:   lbs.GetName(),
                Successful: true,
                Duration:   time.Since(start),
                Metadata: map[string]interface{}{
                        "rebalanced_load": true,
                        "adjusted_weights": map[string]float64{
                                "node-1": 0.3,
                                "node-2": 0.4,
                                "node-3": 0.3,
                        },
                        "migrated_workloads": 3,
                },
                Timestamp: time.Now(),
        }, nil
}</span>

// RecoveryEngine methods

// start starts the recovery engine
func (re *RecoveryEngine) start(ctx context.Context) <span class="cov0" title="0">{
        slog.Info("recovery engine started")
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        slog.Info("recovery engine shutting down")
                        return</span>
                case request := &lt;-re.recoveryQueue:<span class="cov0" title="0">
                        go re.processRecoveryRequest(ctx, request)</span>
                }
        }
}

// processRecoveryRequest processes a recovery request
func (re *RecoveryEngine) processRecoveryRequest(ctx context.Context, request *RecoveryRequest) <span class="cov0" title="0">{
        attemptID := fmt.Sprintf("attempt_%d", time.Now().UnixNano())
        
        slog.Info("processing recovery request",
                "attempt_id", attemptID,
                "fault_id", request.Fault.ID,
                "fault_type", request.Fault.Type,
                "priority", request.Priority)
        
        // Get strategies for this fault type
        strategies, exists := re.strategies[request.Fault.Type]
        if !exists </span><span class="cov0" title="0">{
                slog.Warn("no recovery strategies available", "fault_type", request.Fault.Type)
                return
        }</span>
        
        // Try each strategy until one succeeds
        <span class="cov0" title="0">for _, strategy := range strategies </span><span class="cov0" title="0">{
                if !strategy.CanHandle(request.Fault) </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                // Attempt recovery
                <span class="cov0" title="0">result, err := strategy.Recover(ctx, request.Fault)
                if err != nil </span><span class="cov0" title="0">{
                        slog.Warn("recovery strategy failed",
                                "strategy", strategy.GetName(),
                                "fault_id", request.Fault.ID,
                                "error", err)
                        continue</span>
                }
                
                // Record attempt
                <span class="cov0" title="0">attempt := &amp;RecoveryAttempt{
                        ID:        attemptID,
                        FaultID:   request.Fault.ID,
                        Strategy:  strategy.GetName(),
                        Result:    result,
                        Timestamp: time.Now(),
                }
                
                re.historyMu.Lock()
                re.recoveryHistory = append(re.recoveryHistory, attempt)
                
                // Keep only last 1000 attempts
                if len(re.recoveryHistory) &gt; 1000 </span><span class="cov0" title="0">{
                        re.recoveryHistory = re.recoveryHistory[len(re.recoveryHistory)-1000:]
                }</span>
                <span class="cov0" title="0">re.historyMu.Unlock()
                
                // Update metrics
                re.manager.metrics.RecoveryAttempts++
                if result.Successful </span><span class="cov0" title="0">{
                        re.manager.metrics.SuccessfulRecoveries++
                        re.manager.metrics.FaultsResolved++
                        now := time.Now()
                        re.manager.metrics.LastRecovery = &amp;now
                        
                        // Mark fault as resolved
                        re.manager.detectionSystem.detectionsMu.Lock()
                        if fault, exists := re.manager.detectionSystem.detections[request.Fault.ID]; exists </span><span class="cov0" title="0">{
                                fault.Status = FaultStatusResolved
                                resolvedAt := time.Now()
                                fault.ResolvedAt = &amp;resolvedAt
                        }</span>
                        <span class="cov0" title="0">re.manager.detectionSystem.detectionsMu.Unlock()
                        
                        slog.Info("recovery successful",
                                "attempt_id", attemptID,
                                "strategy", strategy.GetName(),
                                "fault_id", request.Fault.ID,
                                "duration", result.Duration)
                        return</span>
                }
        }
        
        // All strategies failed
        <span class="cov0" title="0">slog.Error("all recovery strategies failed", "fault_id", request.Fault.ID)
        
        // Mark fault as persistent
        re.manager.detectionSystem.detectionsMu.Lock()
        if fault, exists := re.manager.detectionSystem.detections[request.Fault.ID]; exists </span><span class="cov0" title="0">{
                fault.Status = FaultStatusPersistent
        }</span>
        <span class="cov0" title="0">re.manager.detectionSystem.detectionsMu.Unlock()</span>
}

// AlertingSystem methods

// sendAlert sends an alert
func (as *AlertingSystem) sendAlert(alert *FaultAlert) <span class="cov0" title="0">{
        if !as.config.Enabled </span><span class="cov0" title="0">{
                return
        }</span>
        
        // Check if alert should be throttled
        <span class="cov0" title="0">if as.shouldThrottle(alert) </span><span class="cov0" title="0">{
                return
        }</span>
        
        // Store alert
        <span class="cov0" title="0">as.alertsMu.Lock()
        as.alerts = append(as.alerts, alert)
        
        // Keep only last 1000 alerts
        if len(as.alerts) &gt; 1000 </span><span class="cov0" title="0">{
                as.alerts = as.alerts[len(as.alerts)-1000:]
        }</span>
        <span class="cov0" title="0">as.alertsMu.Unlock()
        
        // Send to handlers
        for _, handler := range as.handlers </span><span class="cov0" title="0">{
                go func(h AlertHandler) </span><span class="cov0" title="0">{
                        if err := h.Handle(alert); err != nil </span><span class="cov0" title="0">{
                                slog.Warn("alert handler failed",
                                        "handler", h.GetName(),
                                        "alert_id", alert.ID,
                                        "error", err)
                        }</span>
                }(handler)
        }
        
        <span class="cov0" title="0">slog.Info("alert sent",
                "alert_id", alert.ID,
                "fault_id", alert.FaultID,
                "severity", alert.Severity,
                "message", alert.Message)</span>
}

// shouldThrottle checks if an alert should be throttled
func (as *AlertingSystem) shouldThrottle(alert *FaultAlert) bool <span class="cov0" title="0">{
        if as.config.ThrottleTime == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // Check for similar recent alerts
        <span class="cov0" title="0">as.alertsMu.RLock()
        defer as.alertsMu.RUnlock()
        
        for _, existingAlert := range as.alerts </span><span class="cov0" title="0">{
                if existingAlert.FaultID == alert.FaultID &amp;&amp;
                        time.Since(existingAlert.Timestamp) &lt; as.config.ThrottleTime </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package loadbalancer

import (
        "fmt"
        "math"
        "math/rand"
        "sort"
        "time"
)

// WeightedRoundRobinAlgorithm implements weighted round-robin with prediction
type WeightedRoundRobinAlgorithm struct {
        name    string
        metrics *AlgorithmMetrics
        counter int
        weights map[string]float64
}

// NewWeightedRoundRobinAlgorithm creates a new weighted round-robin algorithm
func NewWeightedRoundRobinAlgorithm() *WeightedRoundRobinAlgorithm <span class="cov0" title="0">{
        return &amp;WeightedRoundRobinAlgorithm{
                name:    "weighted_round_robin",
                metrics: &amp;AlgorithmMetrics{LastUsed: time.Now()},
                weights: make(map[string]float64),
        }
}</span>

func (wrr *WeightedRoundRobinAlgorithm) GetName() string <span class="cov0" title="0">{
        return wrr.name
}</span>

func (wrr *WeightedRoundRobinAlgorithm) GetMetrics() *AlgorithmMetrics <span class="cov0" title="0">{
        return wrr.metrics
}</span>

func (wrr *WeightedRoundRobinAlgorithm) SelectNodes(task interface{}, nodes []*NodeInfo) ([]*NodeInfo, error) <span class="cov0" title="0">{
        if len(nodes) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no nodes available")
        }</span>
        
        // Update weights based on current node performance
        <span class="cov0" title="0">for _, node := range nodes </span><span class="cov0" title="0">{
                weight := wrr.calculateWeight(node)
                wrr.weights[node.ID] = weight
        }</span>
        
        // Select node using weighted round-robin
        <span class="cov0" title="0">totalWeight := 0.0
        for _, weight := range wrr.weights </span><span class="cov0" title="0">{
                totalWeight += weight
        }</span>
        
        <span class="cov0" title="0">if totalWeight == 0 </span><span class="cov0" title="0">{
                // Fallback to simple round-robin
                selectedIndex := wrr.counter % len(nodes)
                wrr.counter++
                return []*NodeInfo{nodes[selectedIndex]}, nil
        }</span>
        
        // Weighted selection
        <span class="cov0" title="0">target := rand.Float64() * totalWeight
        currentSum := 0.0
        
        for _, node := range nodes </span><span class="cov0" title="0">{
                currentSum += wrr.weights[node.ID]
                if currentSum &gt;= target </span><span class="cov0" title="0">{
                        return []*NodeInfo{node}, nil
                }</span>
        }
        
        // Fallback to first node
        <span class="cov0" title="0">return []*NodeInfo{nodes[0]}, nil</span>
}

func (wrr *WeightedRoundRobinAlgorithm) calculateWeight(node *NodeInfo) float64 <span class="cov0" title="0">{
        // Weight based on capacity and inverse of utilization
        capacityScore := node.PerformanceScore
        utilizationPenalty := (node.Usage.CPUUtilization + node.Usage.MemoryUtilization) / 2.0
        healthBonus := node.HealthScore
        
        weight := capacityScore * healthBonus * (1.0 - utilizationPenalty)
        return math.Max(weight, 0.1) // Minimum weight
}</span>

func (wrr *WeightedRoundRobinAlgorithm) UpdateMetrics(result *SelectionResult) <span class="cov0" title="0">{
        wrr.metrics.Selections++
        wrr.metrics.LastUsed = time.Now()
        
        if result.Successful </span><span class="cov0" title="0">{
                wrr.metrics.SuccessRate = float64(wrr.metrics.Selections) / float64(wrr.metrics.Selections)
                wrr.metrics.AverageLatency = (wrr.metrics.AverageLatency + result.ExecutionLatency) / 2
                wrr.metrics.Throughput = (wrr.metrics.Throughput + result.Throughput) / 2
        }</span>
}

// LeastEffectiveLoadAlgorithm implements least effective load balancing
type LeastEffectiveLoadAlgorithm struct {
        name    string
        metrics *AlgorithmMetrics
}

// NewLeastEffectiveLoadAlgorithm creates a new least effective load algorithm
func NewLeastEffectiveLoadAlgorithm() *LeastEffectiveLoadAlgorithm <span class="cov0" title="0">{
        return &amp;LeastEffectiveLoadAlgorithm{
                name:    "least_effective_load",
                metrics: &amp;AlgorithmMetrics{LastUsed: time.Now()},
        }
}</span>

func (lel *LeastEffectiveLoadAlgorithm) GetName() string <span class="cov0" title="0">{
        return lel.name
}</span>

func (lel *LeastEffectiveLoadAlgorithm) GetMetrics() *AlgorithmMetrics <span class="cov0" title="0">{
        return lel.metrics
}</span>

func (lel *LeastEffectiveLoadAlgorithm) SelectNodes(task interface{}, nodes []*NodeInfo) ([]*NodeInfo, error) <span class="cov0" title="0">{
        if len(nodes) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no nodes available")
        }</span>
        
        // Calculate effective load for each node
        <span class="cov0" title="0">type nodeScore struct {
                node         *NodeInfo
                effectiveLoad float64
        }
        
        scores := make([]nodeScore, len(nodes))
        for i, node := range nodes </span><span class="cov0" title="0">{
                scores[i] = nodeScore{
                        node:         node,
                        effectiveLoad: lel.calculateEffectiveLoad(node),
                }
        }</span>
        
        // Sort by effective load (ascending)
        <span class="cov0" title="0">sort.Slice(scores, func(i, j int) bool </span><span class="cov0" title="0">{
                return scores[i].effectiveLoad &lt; scores[j].effectiveLoad
        }</span>)
        
        // Select the node with least effective load
        <span class="cov0" title="0">return []*NodeInfo{scores[0].node}, nil</span>
}

func (lel *LeastEffectiveLoadAlgorithm) calculateEffectiveLoad(node *NodeInfo) float64 <span class="cov0" title="0">{
        // Effective load considers both utilization and capacity
        cpuLoad := node.Usage.CPUUtilization / math.Max(float64(node.Capacity.CPUCores), 1.0)
        memoryLoad := node.Usage.MemoryUtilization
        gpuLoad := node.Usage.GPUUtilization
        networkLoad := node.Usage.NetworkUtilization
        
        // Queue load
        queueLoad := float64(node.Usage.ActiveRequests+node.Usage.QueuedRequests) / 10.0
        
        // Weighted effective load
        effectiveLoad := 0.3*cpuLoad + 0.3*memoryLoad + 0.2*gpuLoad + 0.1*networkLoad + 0.1*queueLoad
        
        // Adjust for health score
        effectiveLoad = effectiveLoad / math.Max(node.HealthScore, 0.1)
        
        return effectiveLoad
}</span>

func (lel *LeastEffectiveLoadAlgorithm) UpdateMetrics(result *SelectionResult) <span class="cov0" title="0">{
        lel.metrics.Selections++
        lel.metrics.LastUsed = time.Now()
        
        if result.Successful </span><span class="cov0" title="0">{
                lel.metrics.SuccessRate = float64(lel.metrics.Selections) / float64(lel.metrics.Selections)
                lel.metrics.AverageLatency = (lel.metrics.AverageLatency + result.ExecutionLatency) / 2
                lel.metrics.Throughput = (lel.metrics.Throughput + result.Throughput) / 2
        }</span>
}

// LocalityAwareAlgorithm implements locality-aware scheduling
type LocalityAwareAlgorithm struct {
        name    string
        metrics *AlgorithmMetrics
        cache   map[string][]string // model -&gt; preferred nodes
}

// NewLocalityAwareAlgorithm creates a new locality-aware algorithm
func NewLocalityAwareAlgorithm() *LocalityAwareAlgorithm <span class="cov0" title="0">{
        return &amp;LocalityAwareAlgorithm{
                name:    "locality_aware",
                metrics: &amp;AlgorithmMetrics{LastUsed: time.Now()},
                cache:   make(map[string][]string),
        }
}</span>

func (laa *LocalityAwareAlgorithm) GetName() string <span class="cov0" title="0">{
        return laa.name
}</span>

func (laa *LocalityAwareAlgorithm) GetMetrics() *AlgorithmMetrics <span class="cov0" title="0">{
        return laa.metrics
}</span>

func (laa *LocalityAwareAlgorithm) SelectNodes(task interface{}, nodes []*NodeInfo) ([]*NodeInfo, error) <span class="cov0" title="0">{
        if len(nodes) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no nodes available")
        }</span>
        
        // Try to determine model name from task
        <span class="cov0" title="0">modelName := laa.getModelName(task)
        
        // Check cache for preferred nodes
        if preferredNodes, exists := laa.cache[modelName]; exists </span><span class="cov0" title="0">{
                for _, preferredNodeID := range preferredNodes </span><span class="cov0" title="0">{
                        for _, node := range nodes </span><span class="cov0" title="0">{
                                if node.ID == preferredNodeID </span><span class="cov0" title="0">{
                                        // Check if node is still suitable
                                        if laa.isSuitableNode(node) </span><span class="cov0" title="0">{
                                                return []*NodeInfo{node}, nil
                                        }</span>
                                }
                        }
                }
        }
        
        // No cached preference or preferred nodes unavailable
        // Select based on locality factors
        <span class="cov0" title="0">type nodeScore struct {
                node         *NodeInfo
                localityScore float64
        }
        
        scores := make([]nodeScore, len(nodes))
        for i, node := range nodes </span><span class="cov0" title="0">{
                scores[i] = nodeScore{
                        node:         node,
                        localityScore: laa.calculateLocalityScore(node, modelName),
                }
        }</span>
        
        // Sort by locality score (descending)
        <span class="cov0" title="0">sort.Slice(scores, func(i, j int) bool </span><span class="cov0" title="0">{
                return scores[i].localityScore &gt; scores[j].localityScore
        }</span>)
        
        // Update cache with selected node
        <span class="cov0" title="0">selectedNode := scores[0].node
        laa.updateCache(modelName, selectedNode.ID)
        
        return []*NodeInfo{selectedNode}, nil</span>
}

func (laa *LocalityAwareAlgorithm) getModelName(task interface{}) string <span class="cov0" title="0">{
        // Extract model name from task
        // This is a simplified implementation
        return "default_model"
}</span>

func (laa *LocalityAwareAlgorithm) isSuitableNode(node *NodeInfo) bool <span class="cov0" title="0">{
        // Check if node is suitable for execution
        return node.HealthScore &gt; 0.5 &amp;&amp; 
                   node.Usage.CPUUtilization &lt; 0.9 &amp;&amp; 
                   node.Usage.MemoryUtilization &lt; 0.9
}</span>

func (laa *LocalityAwareAlgorithm) calculateLocalityScore(node *NodeInfo, modelName string) float64 <span class="cov0" title="0">{
        // Locality score based on:
        // 1. Model cache hit (if model is already loaded)
        // 2. Network latency
        // 3. Data locality
        // 4. Session affinity
        
        // Check if model is cached on this node
        modelCacheHit := laa.hasModelCached(node, modelName)
        
        // Network latency score (inverse of latency)
        latencyScore := 1.0 / (1.0 + float64(node.Latency)/float64(time.Millisecond))
        
        // Data locality score (placeholder)
        dataLocalityScore := 0.8
        
        // Session affinity score (placeholder)
        sessionAffinityScore := 0.7
        
        // Combine scores
        localityScore := 0.4*modelCacheHit + 0.3*latencyScore + 0.2*dataLocalityScore + 0.1*sessionAffinityScore
        
        return localityScore
}</span>

func (laa *LocalityAwareAlgorithm) hasModelCached(node *NodeInfo, modelName string) float64 <span class="cov0" title="0">{
        // Check if model is cached on the node
        // This would interface with the actual model cache
        // For now, return a placeholder value
        return 0.5
}</span>

func (laa *LocalityAwareAlgorithm) updateCache(modelName, nodeID string) <span class="cov0" title="0">{
        if _, exists := laa.cache[modelName]; !exists </span><span class="cov0" title="0">{
                laa.cache[modelName] = make([]string, 0)
        }</span>
        
        // Add node to preferred list if not already present
        <span class="cov0" title="0">for _, id := range laa.cache[modelName] </span><span class="cov0" title="0">{
                if id == nodeID </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        
        <span class="cov0" title="0">laa.cache[modelName] = append(laa.cache[modelName], nodeID)
        
        // Keep only top 3 preferred nodes
        if len(laa.cache[modelName]) &gt; 3 </span><span class="cov0" title="0">{
                laa.cache[modelName] = laa.cache[modelName][:3]
        }</span>
}

func (laa *LocalityAwareAlgorithm) UpdateMetrics(result *SelectionResult) <span class="cov0" title="0">{
        laa.metrics.Selections++
        laa.metrics.LastUsed = time.Now()
        
        if result.Successful </span><span class="cov0" title="0">{
                laa.metrics.SuccessRate = float64(laa.metrics.Selections) / float64(laa.metrics.Selections)
                laa.metrics.AverageLatency = (laa.metrics.AverageLatency + result.ExecutionLatency) / 2
                laa.metrics.Throughput = (laa.metrics.Throughput + result.Throughput) / 2
        }</span>
}

// PredictiveAlgorithm implements predictive load balancing
type PredictiveAlgorithm struct {
        name      string
        metrics   *AlgorithmMetrics
        predictor *PerformancePredictor
}

// NewPredictiveAlgorithm creates a new predictive algorithm
func NewPredictiveAlgorithm(predictor *PerformancePredictor) *PredictiveAlgorithm <span class="cov0" title="0">{
        return &amp;PredictiveAlgorithm{
                name:      "predictive",
                metrics:   &amp;AlgorithmMetrics{LastUsed: time.Now()},
                predictor: predictor,
        }
}</span>

func (pa *PredictiveAlgorithm) GetName() string <span class="cov0" title="0">{
        return pa.name
}</span>

func (pa *PredictiveAlgorithm) GetMetrics() *AlgorithmMetrics <span class="cov0" title="0">{
        return pa.metrics
}</span>

func (pa *PredictiveAlgorithm) SelectNodes(task interface{}, nodes []*NodeInfo) ([]*NodeInfo, error) <span class="cov0" title="0">{
        if len(nodes) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no nodes available")
        }</span>
        
        <span class="cov0" title="0">taskType := pa.getTaskType(task)
        
        // Get predictions for all nodes
        type nodePrediction struct {
                node               *NodeInfo
                predictedLatency   time.Duration
                predictedThroughput float64
                predictionScore    float64
        }
        
        predictions := make([]nodePrediction, len(nodes))
        for i, node := range nodes </span><span class="cov0" title="0">{
                latency, throughput := pa.predictor.PredictPerformance(node, taskType)
                score := pa.calculatePredictionScore(latency, throughput)
                
                predictions[i] = nodePrediction{
                        node:               node,
                        predictedLatency:   latency,
                        predictedThroughput: throughput,
                        predictionScore:    score,
                }
        }</span>
        
        // Sort by prediction score (descending)
        <span class="cov0" title="0">sort.Slice(predictions, func(i, j int) bool </span><span class="cov0" title="0">{
                return predictions[i].predictionScore &gt; predictions[j].predictionScore
        }</span>)
        
        // Select the node with best predicted performance
        <span class="cov0" title="0">return []*NodeInfo{predictions[0].node}, nil</span>
}

func (pa *PredictiveAlgorithm) getTaskType(task interface{}) string <span class="cov0" title="0">{
        // Extract task type from task
        // This is a simplified implementation
        return "inference"
}</span>

func (pa *PredictiveAlgorithm) calculatePredictionScore(latency time.Duration, throughput float64) float64 <span class="cov0" title="0">{
        // Score based on predicted performance
        latencyScore := 1.0 / (1.0 + float64(latency)/float64(time.Second))
        throughputScore := throughput / 100.0 // Normalize to 100 ops/sec
        
        // Weighted combination
        return 0.6*latencyScore + 0.4*throughputScore
}</span>

func (pa *PredictiveAlgorithm) UpdateMetrics(result *SelectionResult) <span class="cov0" title="0">{
        pa.metrics.Selections++
        pa.metrics.LastUsed = time.Now()
        
        if result.Successful </span><span class="cov0" title="0">{
                pa.metrics.SuccessRate = float64(pa.metrics.Selections) / float64(pa.metrics.Selections)
                pa.metrics.AverageLatency = (pa.metrics.AverageLatency + result.ExecutionLatency) / 2
                pa.metrics.Throughput = (pa.metrics.Throughput + result.Throughput) / 2
        }</span>
}

// AdaptiveAlgorithm implements adaptive load balancing
type AdaptiveAlgorithm struct {
        name    string
        metrics *AlgorithmMetrics
        history *RequestHistory
        strategies []string
        currentStrategy string
}

// NewAdaptiveAlgorithm creates a new adaptive algorithm
func NewAdaptiveAlgorithm(history *RequestHistory) *AdaptiveAlgorithm <span class="cov0" title="0">{
        return &amp;AdaptiveAlgorithm{
                name:    "adaptive",
                metrics: &amp;AlgorithmMetrics{LastUsed: time.Now()},
                history: history,
                strategies: []string{"round_robin", "least_load", "locality_aware"},
                currentStrategy: "round_robin",
        }
}</span>

func (aa *AdaptiveAlgorithm) GetName() string <span class="cov0" title="0">{
        return aa.name
}</span>

func (aa *AdaptiveAlgorithm) GetMetrics() *AlgorithmMetrics <span class="cov0" title="0">{
        return aa.metrics
}</span>

func (aa *AdaptiveAlgorithm) SelectNodes(task interface{}, nodes []*NodeInfo) ([]*NodeInfo, error) <span class="cov0" title="0">{
        if len(nodes) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no nodes available")
        }</span>
        
        // Adapt strategy based on current conditions
        <span class="cov0" title="0">aa.adaptStrategy(nodes)
        
        // Select node based on current strategy
        switch aa.currentStrategy </span>{
        case "round_robin":<span class="cov0" title="0">
                return aa.selectRoundRobin(nodes)</span>
        case "least_load":<span class="cov0" title="0">
                return aa.selectLeastLoad(nodes)</span>
        case "locality_aware":<span class="cov0" title="0">
                return aa.selectLocalityAware(nodes)</span>
        default:<span class="cov0" title="0">
                return []*NodeInfo{nodes[0]}, nil</span>
        }
}

func (aa *AdaptiveAlgorithm) adaptStrategy(nodes []*NodeInfo) <span class="cov0" title="0">{
        // Analyze current system state
        loadVariance := aa.calculateLoadVariance(nodes)
        latencyVariance := aa.calculateLatencyVariance(nodes)
        
        // Adapt strategy based on conditions
        if loadVariance &gt; 0.5 </span><span class="cov0" title="0">{
                aa.currentStrategy = "least_load"
        }</span> else<span class="cov0" title="0"> if latencyVariance &gt; 0.3 </span><span class="cov0" title="0">{
                aa.currentStrategy = "locality_aware"
        }</span> else<span class="cov0" title="0"> {
                aa.currentStrategy = "round_robin"
        }</span>
}

func (aa *AdaptiveAlgorithm) calculateLoadVariance(nodes []*NodeInfo) float64 <span class="cov0" title="0">{
        if len(nodes) == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>
        
        // Calculate average load
        <span class="cov0" title="0">totalLoad := 0.0
        for _, node := range nodes </span><span class="cov0" title="0">{
                totalLoad += node.LoadScore
        }</span>
        <span class="cov0" title="0">averageLoad := totalLoad / float64(len(nodes))
        
        // Calculate variance
        variance := 0.0
        for _, node := range nodes </span><span class="cov0" title="0">{
                deviation := node.LoadScore - averageLoad
                variance += deviation * deviation
        }</span>
        
        <span class="cov0" title="0">return variance / float64(len(nodes))</span>
}

func (aa *AdaptiveAlgorithm) calculateLatencyVariance(nodes []*NodeInfo) float64 <span class="cov0" title="0">{
        if len(nodes) == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>
        
        // Calculate average latency
        <span class="cov0" title="0">totalLatency := time.Duration(0)
        for _, node := range nodes </span><span class="cov0" title="0">{
                totalLatency += node.Latency
        }</span>
        <span class="cov0" title="0">averageLatency := totalLatency / time.Duration(len(nodes))
        
        // Calculate variance
        variance := 0.0
        for _, node := range nodes </span><span class="cov0" title="0">{
                deviation := float64(node.Latency - averageLatency)
                variance += deviation * deviation
        }</span>
        
        <span class="cov0" title="0">return variance / float64(len(nodes))</span>
}

func (aa *AdaptiveAlgorithm) selectRoundRobin(nodes []*NodeInfo) ([]*NodeInfo, error) <span class="cov0" title="0">{
        // Simple round-robin selection
        static := struct {
                counter int
        }{}
        selectedIndex := static.counter % len(nodes)
        static.counter++
        return []*NodeInfo{nodes[selectedIndex]}, nil
}</span>

func (aa *AdaptiveAlgorithm) selectLeastLoad(nodes []*NodeInfo) ([]*NodeInfo, error) <span class="cov0" title="0">{
        // Select node with least load
        minLoad := math.MaxFloat64
        var selectedNode *NodeInfo
        
        for _, node := range nodes </span><span class="cov0" title="0">{
                if node.LoadScore &lt; minLoad </span><span class="cov0" title="0">{
                        minLoad = node.LoadScore
                        selectedNode = node
                }</span>
        }
        
        <span class="cov0" title="0">return []*NodeInfo{selectedNode}, nil</span>
}

func (aa *AdaptiveAlgorithm) selectLocalityAware(nodes []*NodeInfo) ([]*NodeInfo, error) <span class="cov0" title="0">{
        // Select node with lowest latency
        minLatency := time.Duration(math.MaxInt64)
        var selectedNode *NodeInfo
        
        for _, node := range nodes </span><span class="cov0" title="0">{
                if node.Latency &lt; minLatency </span><span class="cov0" title="0">{
                        minLatency = node.Latency
                        selectedNode = node
                }</span>
        }
        
        <span class="cov0" title="0">return []*NodeInfo{selectedNode}, nil</span>
}

func (aa *AdaptiveAlgorithm) UpdateMetrics(result *SelectionResult) <span class="cov0" title="0">{
        aa.metrics.Selections++
        aa.metrics.LastUsed = time.Now()
        
        if result.Successful </span><span class="cov0" title="0">{
                aa.metrics.SuccessRate = float64(aa.metrics.Selections) / float64(aa.metrics.Selections)
                aa.metrics.AverageLatency = (aa.metrics.AverageLatency + result.ExecutionLatency) / 2
                aa.metrics.Throughput = (aa.metrics.Throughput + result.Throughput) / 2
        }</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package loadbalancer

import (
        "fmt"
        "log/slog"
        "math"
        "sort"
        "sync"
        "time"
)

// IntelligentLoadBalancer implements intelligent load balancing with prediction
type IntelligentLoadBalancer struct {
        config      *Config
        algorithms  map[string]LoadBalancingAlgorithm
        predictor   *PerformancePredictor
        history     *RequestHistory
        constraints []LoadBalancingConstraint
        metrics     *LoadBalancerMetrics
        mu          sync.RWMutex
}

// Config holds load balancer configuration
type Config struct {
        Algorithm     string                 `json:"algorithm"`
        LatencyTarget time.Duration          `json:"latency_target"`
        WeightFactors map[string]float64     `json:"weight_factors"`
        Adaptive      bool                   `json:"adaptive"`
        PredictionEnabled bool               `json:"prediction_enabled"`
        HistorySize   int                    `json:"history_size"`
}

// LoadBalancingAlgorithm defines the interface for load balancing algorithms
type LoadBalancingAlgorithm interface {
        SelectNodes(task interface{}, nodes []*NodeInfo) ([]*NodeInfo, error)
        GetName() string
        GetMetrics() *AlgorithmMetrics
        UpdateMetrics(result *SelectionResult)
}

// NodeInfo represents node information for load balancing
type NodeInfo struct {
        ID               string                 `json:"id"`
        Address          string                 `json:"address"`
        Capacity         *ResourceCapacity      `json:"capacity"`
        Usage            *ResourceUsage         `json:"usage"`
        Latency          time.Duration          `json:"latency"`
        Bandwidth        int64                  `json:"bandwidth"`
        HealthScore      float64                `json:"health_score"`
        LoadScore        float64                `json:"load_score"`
        PerformanceScore float64                `json:"performance_score"`
        Capabilities     []string               `json:"capabilities"`
        Metadata         map[string]interface{} `json:"metadata"`
}

// ResourceCapacity represents node resource capacity
type ResourceCapacity struct {
        CPUCores         int64   `json:"cpu_cores"`
        MemoryBytes      int64   `json:"memory_bytes"`
        GPUCount         int     `json:"gpu_count"`
        GPUMemoryBytes   int64   `json:"gpu_memory_bytes"`
        NetworkBandwidth int64   `json:"network_bandwidth"`
        ComputeScore     float64 `json:"compute_score"`
}

// ResourceUsage represents node resource usage
type ResourceUsage struct {
        CPUUtilization    float64 `json:"cpu_utilization"`
        MemoryUtilization float64 `json:"memory_utilization"`
        GPUUtilization    float64 `json:"gpu_utilization"`
        NetworkUtilization float64 `json:"network_utilization"`
        ActiveRequests    int     `json:"active_requests"`
        QueuedRequests    int     `json:"queued_requests"`
        LoadAverage       float64 `json:"load_average"`
}

// LoadBalancingConstraint represents a constraint for load balancing
type LoadBalancingConstraint struct {
        Type     string      `json:"type"`     // "memory", "gpu", "latency", "cost"
        Value    interface{} `json:"value"`
        Operator string      `json:"operator"` // "&lt;", "&gt;", "=", "&lt;=", "&gt;="
        Priority int         `json:"priority"`
}

// PerformancePredictor predicts node performance
type PerformancePredictor struct {
        models     map[string]*PredictionModel
        history    []*PerformanceSample
        historyMu  sync.RWMutex
        learning   bool
        accuracy   float64
}

// PredictionModel represents a performance prediction model
type PredictionModel struct {
        Name       string                 `json:"name"`
        Type       string                 `json:"type"`
        Weights    map[string]float64     `json:"weights"`
        Accuracy   float64                `json:"accuracy"`
        LastTrained time.Time             `json:"last_trained"`
        Metadata   map[string]interface{} `json:"metadata"`
}

// PerformanceSample represents a performance sample for learning
type PerformanceSample struct {
        NodeID          string        `json:"node_id"`
        TaskType        string        `json:"task_type"`
        ResourceState   *ResourceUsage `json:"resource_state"`
        PredictedLatency time.Duration `json:"predicted_latency"`
        ActualLatency   time.Duration `json:"actual_latency"`
        PredictedThroughput float64   `json:"predicted_throughput"`
        ActualThroughput float64      `json:"actual_throughput"`
        Timestamp       time.Time     `json:"timestamp"`
}

// RequestHistory tracks request history for patterns
type RequestHistory struct {
        requests   []*RequestRecord
        requestsMu sync.RWMutex
        patterns   map[string]*RequestPattern
        patternsMu sync.RWMutex
}

// RequestRecord represents a request record
type RequestRecord struct {
        ID               string                 `json:"id"`
        Type             string                 `json:"type"`
        SelectedNodes    []string               `json:"selected_nodes"`
        Latency          time.Duration          `json:"latency"`
        Throughput       float64                `json:"throughput"`
        ResourceUsage    map[string]interface{} `json:"resource_usage"`
        Timestamp        time.Time              `json:"timestamp"`
        Successful       bool                   `json:"successful"`
}

// RequestPattern represents a request pattern
type RequestPattern struct {
        Type              string        `json:"type"`
        AverageLatency    time.Duration `json:"average_latency"`
        AverageThroughput float64       `json:"average_throughput"`
        PreferredNodes    []string      `json:"preferred_nodes"`
        ResourceProfile   map[string]float64 `json:"resource_profile"`
        Confidence        float64       `json:"confidence"`
        LastUpdated       time.Time     `json:"last_updated"`
}

// LoadBalancerMetrics represents load balancer metrics
type LoadBalancerMetrics struct {
        TotalRequests      int64         `json:"total_requests"`
        SuccessfulRequests int64         `json:"successful_requests"`
        FailedRequests     int64         `json:"failed_requests"`
        AverageLatency     time.Duration `json:"average_latency"`
        Throughput         float64       `json:"throughput"`
        AlgorithmMetrics   map[string]*AlgorithmMetrics `json:"algorithm_metrics"`
        LastUpdated        time.Time     `json:"last_updated"`
}

// AlgorithmMetrics represents metrics for a specific algorithm
type AlgorithmMetrics struct {
        Selections        int64         `json:"selections"`
        SuccessRate       float64       `json:"success_rate"`
        AverageLatency    time.Duration `json:"average_latency"`
        Throughput        float64       `json:"throughput"`
        LastUsed          time.Time     `json:"last_used"`
}

// SelectionResult represents the result of a node selection
type SelectionResult struct {
        Nodes            []*NodeInfo   `json:"nodes"`
        Algorithm        string        `json:"algorithm"`
        SelectionTime    time.Duration `json:"selection_time"`
        ExecutionLatency time.Duration `json:"execution_latency"`
        Throughput       float64       `json:"throughput"`
        Successful       bool          `json:"successful"`
        Timestamp        time.Time     `json:"timestamp"`
}

// NewIntelligentLoadBalancer creates a new intelligent load balancer
func NewIntelligentLoadBalancer(config *Config) *IntelligentLoadBalancer <span class="cov0" title="0">{
        ilb := &amp;IntelligentLoadBalancer{
                config:      config,
                algorithms:  make(map[string]LoadBalancingAlgorithm),
                constraints: make([]LoadBalancingConstraint, 0),
                metrics: &amp;LoadBalancerMetrics{
                        AlgorithmMetrics: make(map[string]*AlgorithmMetrics),
                        LastUpdated:      time.Now(),
                },
        }
        
        // Initialize performance predictor
        ilb.predictor = &amp;PerformancePredictor{
                models:   make(map[string]*PredictionModel),
                history:  make([]*PerformanceSample, 0),
                learning: config.PredictionEnabled,
                accuracy: 0.7, // Initial accuracy
        }
        
        // Initialize request history
        ilb.history = &amp;RequestHistory{
                requests: make([]*RequestRecord, 0),
                patterns: make(map[string]*RequestPattern),
        }
        
        // Register algorithms
        ilb.RegisterAlgorithm(NewWeightedRoundRobinAlgorithm())
        ilb.RegisterAlgorithm(NewLeastEffectiveLoadAlgorithm())
        ilb.RegisterAlgorithm(NewLocalityAwareAlgorithm())
        ilb.RegisterAlgorithm(NewPredictiveAlgorithm(ilb.predictor))
        ilb.RegisterAlgorithm(NewAdaptiveAlgorithm(ilb.history))
        
        return ilb
}</span>

// RegisterAlgorithm registers a load balancing algorithm
func (ilb *IntelligentLoadBalancer) RegisterAlgorithm(algorithm LoadBalancingAlgorithm) <span class="cov0" title="0">{
        ilb.mu.Lock()
        defer ilb.mu.Unlock()
        
        ilb.algorithms[algorithm.GetName()] = algorithm
        ilb.metrics.AlgorithmMetrics[algorithm.GetName()] = &amp;AlgorithmMetrics{
                LastUsed: time.Now(),
        }
}</span>

// SelectNodes selects the best nodes for a task
func (ilb *IntelligentLoadBalancer) SelectNodes(task interface{}, availableNodes []*NodeInfo) ([]*NodeInfo, error) <span class="cov0" title="0">{
        start := time.Now()
        
        // Update metrics
        ilb.metrics.TotalRequests++
        
        // Apply constraints
        constrainedNodes := ilb.applyConstraints(availableNodes)
        if len(constrainedNodes) == 0 </span><span class="cov0" title="0">{
                ilb.metrics.FailedRequests++
                return nil, fmt.Errorf("no nodes satisfy constraints")
        }</span>
        
        // Select algorithm
        <span class="cov0" title="0">algorithm, err := ilb.selectAlgorithm(task, constrainedNodes)
        if err != nil </span><span class="cov0" title="0">{
                ilb.metrics.FailedRequests++
                return nil, fmt.Errorf("failed to select algorithm: %v", err)
        }</span>
        
        // Select nodes using the chosen algorithm
        <span class="cov0" title="0">selectedNodes, err := algorithm.SelectNodes(task, constrainedNodes)
        if err != nil </span><span class="cov0" title="0">{
                ilb.metrics.FailedRequests++
                return nil, fmt.Errorf("algorithm selection failed: %v", err)
        }</span>
        
        // Update metrics
        <span class="cov0" title="0">ilb.metrics.SuccessfulRequests++
        selectionTime := time.Since(start)
        
        // Record selection result
        result := &amp;SelectionResult{
                Nodes:         selectedNodes,
                Algorithm:     algorithm.GetName(),
                SelectionTime: selectionTime,
                Successful:    true,
                Timestamp:     time.Now(),
        }
        
        // Update algorithm metrics
        algorithm.UpdateMetrics(result)
        
        slog.Debug("node selection completed",
                "algorithm", algorithm.GetName(),
                "selected_nodes", len(selectedNodes),
                "selection_time", selectionTime,
                "available_nodes", len(availableNodes))
        
        return selectedNodes, nil</span>
}

// applyConstraints applies load balancing constraints to nodes
func (ilb *IntelligentLoadBalancer) applyConstraints(nodes []*NodeInfo) []*NodeInfo <span class="cov0" title="0">{
        if len(ilb.constraints) == 0 </span><span class="cov0" title="0">{
                return nodes
        }</span>
        
        <span class="cov0" title="0">constrained := make([]*NodeInfo, 0)
        
        for _, node := range nodes </span><span class="cov0" title="0">{
                satisfies := true
                
                for _, constraint := range ilb.constraints </span><span class="cov0" title="0">{
                        if !ilb.satisfiesConstraint(node, constraint) </span><span class="cov0" title="0">{
                                satisfies = false
                                break</span>
                        }
                }
                
                <span class="cov0" title="0">if satisfies </span><span class="cov0" title="0">{
                        constrained = append(constrained, node)
                }</span>
        }
        
        <span class="cov0" title="0">return constrained</span>
}

// satisfiesConstraint checks if a node satisfies a constraint
func (ilb *IntelligentLoadBalancer) satisfiesConstraint(node *NodeInfo, constraint LoadBalancingConstraint) bool <span class="cov0" title="0">{
        switch constraint.Type </span>{
        case "memory":<span class="cov0" title="0">
                memoryUtilization := node.Usage.MemoryUtilization
                threshold := constraint.Value.(float64)
                return ilb.compareValues(memoryUtilization, threshold, constraint.Operator)</span>
                
        case "gpu":<span class="cov0" title="0">
                gpuUtilization := node.Usage.GPUUtilization
                threshold := constraint.Value.(float64)
                return ilb.compareValues(gpuUtilization, threshold, constraint.Operator)</span>
                
        case "latency":<span class="cov0" title="0">
                latency := node.Latency
                threshold := constraint.Value.(time.Duration)
                return ilb.compareLatency(latency, threshold, constraint.Operator)</span>
                
        case "cost":<span class="cov0" title="0">
                // Cost constraint implementation would go here
                return true</span>
                
        default:<span class="cov0" title="0">
                return true</span>
        }
}

// compareValues compares two float64 values using an operator
func (ilb *IntelligentLoadBalancer) compareValues(value, threshold float64, operator string) bool <span class="cov0" title="0">{
        switch operator </span>{
        case "&lt;":<span class="cov0" title="0">
                return value &lt; threshold</span>
        case "&gt;":<span class="cov0" title="0">
                return value &gt; threshold</span>
        case "=":<span class="cov0" title="0">
                return math.Abs(value-threshold) &lt; 0.001</span>
        case "&lt;=":<span class="cov0" title="0">
                return value &lt;= threshold</span>
        case "&gt;=":<span class="cov0" title="0">
                return value &gt;= threshold</span>
        default:<span class="cov0" title="0">
                return true</span>
        }
}

// compareLatency compares two latency values using an operator
func (ilb *IntelligentLoadBalancer) compareLatency(latency, threshold time.Duration, operator string) bool <span class="cov0" title="0">{
        switch operator </span>{
        case "&lt;":<span class="cov0" title="0">
                return latency &lt; threshold</span>
        case "&gt;":<span class="cov0" title="0">
                return latency &gt; threshold</span>
        case "=":<span class="cov0" title="0">
                return latency == threshold</span>
        case "&lt;=":<span class="cov0" title="0">
                return latency &lt;= threshold</span>
        case "&gt;=":<span class="cov0" title="0">
                return latency &gt;= threshold</span>
        default:<span class="cov0" title="0">
                return true</span>
        }
}

// selectAlgorithm selects the best algorithm for a task
func (ilb *IntelligentLoadBalancer) selectAlgorithm(task interface{}, nodes []*NodeInfo) (LoadBalancingAlgorithm, error) <span class="cov0" title="0">{
        // If adaptive mode is disabled, use configured algorithm
        if !ilb.config.Adaptive </span><span class="cov0" title="0">{
                if algorithm, exists := ilb.algorithms[ilb.config.Algorithm]; exists </span><span class="cov0" title="0">{
                        return algorithm, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("algorithm not found: %s", ilb.config.Algorithm)</span>
        }
        
        // Adaptive algorithm selection
        <span class="cov0" title="0">return ilb.selectAdaptiveAlgorithm(task, nodes)</span>
}

// selectAdaptiveAlgorithm selects an algorithm adaptively based on context
func (ilb *IntelligentLoadBalancer) selectAdaptiveAlgorithm(task interface{}, nodes []*NodeInfo) (LoadBalancingAlgorithm, error) <span class="cov0" title="0">{
        // Analyze task characteristics
        taskType := ilb.getTaskType(task)
        nodeCount := len(nodes)
        loadVariance := ilb.calculateLoadVariance(nodes)
        
        // Select algorithm based on context
        if nodeCount &lt;= 2 </span><span class="cov0" title="0">{
                // Simple round-robin for small clusters
                return ilb.algorithms["weighted_round_robin"], nil
        }</span>
        
        <span class="cov0" title="0">if loadVariance &gt; 0.5 </span><span class="cov0" title="0">{
                // Use least effective load for unbalanced clusters
                return ilb.algorithms["least_effective_load"], nil
        }</span>
        
        <span class="cov0" title="0">if taskType == "latency_sensitive" </span><span class="cov0" title="0">{
                // Use locality-aware for latency-sensitive tasks
                return ilb.algorithms["locality_aware"], nil
        }</span>
        
        <span class="cov0" title="0">if ilb.config.PredictionEnabled </span><span class="cov0" title="0">{
                // Use predictive algorithm when prediction is enabled
                return ilb.algorithms["predictive"], nil
        }</span>
        
        // Default to adaptive algorithm
        <span class="cov0" title="0">return ilb.algorithms["adaptive"], nil</span>
}

// getTaskType determines the type of task
func (ilb *IntelligentLoadBalancer) getTaskType(task interface{}) string <span class="cov0" title="0">{
        // This would analyze the task to determine its type
        // For now, return a default type
        return "general"
}</span>

// calculateLoadVariance calculates the variance in load across nodes
func (ilb *IntelligentLoadBalancer) calculateLoadVariance(nodes []*NodeInfo) float64 <span class="cov0" title="0">{
        if len(nodes) == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>
        
        // Calculate average load
        <span class="cov0" title="0">totalLoad := 0.0
        for _, node := range nodes </span><span class="cov0" title="0">{
                totalLoad += node.LoadScore
        }</span>
        <span class="cov0" title="0">averageLoad := totalLoad / float64(len(nodes))
        
        // Calculate variance
        variance := 0.0
        for _, node := range nodes </span><span class="cov0" title="0">{
                deviation := node.LoadScore - averageLoad
                variance += deviation * deviation
        }</span>
        
        <span class="cov0" title="0">return variance / float64(len(nodes))</span>
}

// AddConstraint adds a load balancing constraint
func (ilb *IntelligentLoadBalancer) AddConstraint(constraint LoadBalancingConstraint) <span class="cov0" title="0">{
        ilb.mu.Lock()
        defer ilb.mu.Unlock()
        
        ilb.constraints = append(ilb.constraints, constraint)
        
        // Sort constraints by priority
        sort.Slice(ilb.constraints, func(i, j int) bool </span><span class="cov0" title="0">{
                return ilb.constraints[i].Priority &gt; ilb.constraints[j].Priority
        }</span>)
}

// RemoveConstraint removes a load balancing constraint
func (ilb *IntelligentLoadBalancer) RemoveConstraint(constraintType string) <span class="cov0" title="0">{
        ilb.mu.Lock()
        defer ilb.mu.Unlock()
        
        for i, constraint := range ilb.constraints </span><span class="cov0" title="0">{
                if constraint.Type == constraintType </span><span class="cov0" title="0">{
                        ilb.constraints = append(ilb.constraints[:i], ilb.constraints[i+1:]...)
                        break</span>
                }
        }
}

// GetMetrics returns load balancer metrics
func (ilb *IntelligentLoadBalancer) GetMetrics() *LoadBalancerMetrics <span class="cov0" title="0">{
        ilb.mu.RLock()
        defer ilb.mu.RUnlock()
        
        // Calculate average latency
        if ilb.metrics.SuccessfulRequests &gt; 0 </span><span class="cov0" title="0">{
                // This would be calculated from actual measurements
                ilb.metrics.AverageLatency = 100 * time.Millisecond
        }</span>
        
        // Calculate throughput
        <span class="cov0" title="0">if ilb.metrics.SuccessfulRequests &gt; 0 </span><span class="cov0" title="0">{
                // This would be calculated from actual measurements
                ilb.metrics.Throughput = float64(ilb.metrics.SuccessfulRequests) / time.Since(ilb.metrics.LastUpdated).Seconds()
        }</span>
        
        <span class="cov0" title="0">return ilb.metrics</span>
}

// GetAvailableAlgorithms returns all available algorithms
func (ilb *IntelligentLoadBalancer) GetAvailableAlgorithms() []string <span class="cov0" title="0">{
        ilb.mu.RLock()
        defer ilb.mu.RUnlock()
        
        algorithms := make([]string, 0, len(ilb.algorithms))
        for name := range ilb.algorithms </span><span class="cov0" title="0">{
                algorithms = append(algorithms, name)
        }</span>
        
        <span class="cov0" title="0">return algorithms</span>
}

// UpdateConfig updates the load balancer configuration
func (ilb *IntelligentLoadBalancer) UpdateConfig(config *Config) <span class="cov0" title="0">{
        ilb.mu.Lock()
        defer ilb.mu.Unlock()
        
        ilb.config = config
        ilb.predictor.learning = config.PredictionEnabled
        
        slog.Info("load balancer configuration updated",
                "algorithm", config.Algorithm,
                "adaptive", config.Adaptive,
                "prediction_enabled", config.PredictionEnabled)
}</span>

// RecordResult records the result of a load balancing decision
func (ilb *IntelligentLoadBalancer) RecordResult(result *SelectionResult) <span class="cov0" title="0">{
        // Record in history
        ilb.history.recordRequest(&amp;RequestRecord{
                ID:            fmt.Sprintf("req_%d", time.Now().UnixNano()),
                Type:          "load_balancing",
                SelectedNodes: ilb.getNodeIDs(result.Nodes),
                Latency:       result.ExecutionLatency,
                Throughput:    result.Throughput,
                Timestamp:     result.Timestamp,
                Successful:    result.Successful,
        })
        
        // Update predictor if enabled
        if ilb.config.PredictionEnabled </span><span class="cov0" title="0">{
                ilb.predictor.recordSample(&amp;PerformanceSample{
                        TaskType:         "load_balancing",
                        ActualLatency:    result.ExecutionLatency,
                        ActualThroughput: result.Throughput,
                        Timestamp:        result.Timestamp,
                })
        }</span>
}

// getNodeIDs extracts node IDs from a slice of nodes
func (ilb *IntelligentLoadBalancer) getNodeIDs(nodes []*NodeInfo) []string <span class="cov0" title="0">{
        ids := make([]string, len(nodes))
        for i, node := range nodes </span><span class="cov0" title="0">{
                ids[i] = node.ID
        }</span>
        <span class="cov0" title="0">return ids</span>
}

// RequestHistory methods

// recordRequest records a request in the history
func (rh *RequestHistory) recordRequest(record *RequestRecord) <span class="cov0" title="0">{
        rh.requestsMu.Lock()
        defer rh.requestsMu.Unlock()
        
        rh.requests = append(rh.requests, record)
        
        // Keep only last 1000 requests
        if len(rh.requests) &gt; 1000 </span><span class="cov0" title="0">{
                rh.requests = rh.requests[len(rh.requests)-1000:]
        }</span>
        
        // Update patterns
        <span class="cov0" title="0">go rh.updatePatterns(record)</span>
}

// updatePatterns updates request patterns based on new records
func (rh *RequestHistory) updatePatterns(record *RequestRecord) <span class="cov0" title="0">{
        rh.patternsMu.Lock()
        defer rh.patternsMu.Unlock()
        
        pattern, exists := rh.patterns[record.Type]
        if !exists </span><span class="cov0" title="0">{
                pattern = &amp;RequestPattern{
                        Type:            record.Type,
                        PreferredNodes:  record.SelectedNodes,
                        ResourceProfile: make(map[string]float64),
                        Confidence:      0.5,
                        LastUpdated:     time.Now(),
                }
                rh.patterns[record.Type] = pattern
        }</span>
        
        // Update pattern with new data
        <span class="cov0" title="0">pattern.AverageLatency = (pattern.AverageLatency + record.Latency) / 2
        pattern.AverageThroughput = (pattern.AverageThroughput + record.Throughput) / 2
        pattern.LastUpdated = time.Now()
        
        // Update confidence based on success rate
        if record.Successful </span><span class="cov0" title="0">{
                pattern.Confidence = math.Min(pattern.Confidence*1.1, 1.0)
        }</span> else<span class="cov0" title="0"> {
                pattern.Confidence = math.Max(pattern.Confidence*0.9, 0.1)
        }</span>
}

// PerformancePredictor methods

// recordSample records a performance sample
func (pp *PerformancePredictor) recordSample(sample *PerformanceSample) <span class="cov0" title="0">{
        pp.historyMu.Lock()
        defer pp.historyMu.Unlock()
        
        pp.history = append(pp.history, sample)
        
        // Keep only last 1000 samples
        if len(pp.history) &gt; 1000 </span><span class="cov0" title="0">{
                pp.history = pp.history[len(pp.history)-1000:]
        }</span>
        
        // Update models if learning is enabled
        <span class="cov0" title="0">if pp.learning </span><span class="cov0" title="0">{
                go pp.updateModels()
        }</span>
}

// updateModels updates prediction models based on new samples
func (pp *PerformancePredictor) updateModels() <span class="cov0" title="0">{
        // This would implement actual machine learning model updates
        // For now, just update accuracy based on recent samples
        pp.historyMu.RLock()
        samples := pp.history
        pp.historyMu.RUnlock()
        
        if len(samples) &gt; 10 </span><span class="cov0" title="0">{
                // Calculate accuracy based on recent samples
                recentSamples := samples[len(samples)-10:]
                correctPredictions := 0
                
                for _, sample := range recentSamples </span><span class="cov0" title="0">{
                        // Simple accuracy calculation
                        if sample.PredictedLatency &gt; 0 </span><span class="cov0" title="0">{
                                error := math.Abs(float64(sample.ActualLatency-sample.PredictedLatency)) / float64(sample.ActualLatency)
                                if error &lt; 0.2 </span><span class="cov0" title="0">{ // 20% accuracy threshold
                                        correctPredictions++
                                }</span>
                        }
                }
                
                <span class="cov0" title="0">pp.accuracy = float64(correctPredictions) / float64(len(recentSamples))</span>
        }
}

// PredictPerformance predicts the performance of a node for a task
func (pp *PerformancePredictor) PredictPerformance(node *NodeInfo, taskType string) (time.Duration, float64) <span class="cov0" title="0">{
        if !pp.learning </span><span class="cov0" title="0">{
                // Return simple estimates if prediction is disabled
                return 100 * time.Millisecond, 10.0
        }</span>
        
        // Use historical data and models to predict performance
        <span class="cov0" title="0">pp.historyMu.RLock()
        defer pp.historyMu.RUnlock()
        
        // Find similar samples
        similarSamples := make([]*PerformanceSample, 0)
        for _, sample := range pp.history </span><span class="cov0" title="0">{
                if sample.NodeID == node.ID &amp;&amp; sample.TaskType == taskType </span><span class="cov0" title="0">{
                        similarSamples = append(similarSamples, sample)
                }</span>
        }
        
        <span class="cov0" title="0">if len(similarSamples) == 0 </span><span class="cov0" title="0">{
                // No historical data, return estimates
                return time.Duration(float64(100*time.Millisecond) / math.Max(node.PerformanceScore, 0.1)), node.PerformanceScore * 10.0
        }</span>
        
        // Calculate weighted average based on recent samples
        <span class="cov0" title="0">totalLatency := time.Duration(0)
        totalThroughput := 0.0
        weightSum := 0.0
        
        for i, sample := range similarSamples </span><span class="cov0" title="0">{
                // Weight recent samples more heavily
                weight := float64(i+1) / float64(len(similarSamples))
                totalLatency += time.Duration(float64(sample.ActualLatency) * weight)
                totalThroughput += sample.ActualThroughput * weight
                weightSum += weight
        }</span>
        
        <span class="cov0" title="0">predictedLatency := time.Duration(float64(totalLatency) / weightSum)
        predictedThroughput := totalThroughput / weightSum
        
        return predictedLatency, predictedThroughput</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package orchestration

import (
        "fmt"
        "time"
)

// ConcatAggregationStrategy concatenates partial results
type ConcatAggregationStrategy struct {
        name string
}

func (cas *ConcatAggregationStrategy) GetName() string <span class="cov0" title="0">{
        return "concat"
}</span>

func (cas *ConcatAggregationStrategy) Aggregate(context *AggregationContext) (*AggregatedResponse, error) <span class="cov0" title="0">{
        start := time.Now()
        
        // Concatenate all partial results
        results := make([]interface{}, 0)
        for _, partial := range context.PartialResults </span><span class="cov0" title="0">{
                if partial.Error == "" </span><span class="cov0" title="0">{
                        results = append(results, partial.Data)
                }</span>
        }
        
        <span class="cov0" title="0">return &amp;AggregatedResponse{
                TaskID:    context.TaskID,
                Strategy:  cas.GetName(),
                Data:      results,
                Metadata: map[string]interface{}{
                        "concatenated_count": len(results),
                        "total_partitions":   len(context.PartialResults),
                },
                Latency:   time.Since(start),
                Timestamp: time.Now(),
        }, nil</span>
}

// AverageAggregationStrategy averages partial results
type AverageAggregationStrategy struct {
        name string
}

func (aas *AverageAggregationStrategy) GetName() string <span class="cov0" title="0">{
        return "average"
}</span>

func (aas *AverageAggregationStrategy) Aggregate(context *AggregationContext) (*AggregatedResponse, error) <span class="cov0" title="0">{
        start := time.Now()
        
        // Average numeric results
        var total float64
        var count int
        
        for _, partial := range context.PartialResults </span><span class="cov0" title="0">{
                if partial.Error == "" </span><span class="cov0" title="0">{
                        if value, ok := partial.Data.(float64); ok </span><span class="cov0" title="0">{
                                total += value
                                count++
                        }</span>
                }
        }
        
        <span class="cov0" title="0">if count == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no valid numeric results to average")
        }</span>
        
        <span class="cov0" title="0">average := total / float64(count)
        
        return &amp;AggregatedResponse{
                TaskID:    context.TaskID,
                Strategy:  aas.GetName(),
                Data:      average,
                Metadata: map[string]interface{}{
                        "total_sum":        total,
                        "count":            count,
                        "average":          average,
                        "total_partitions": len(context.PartialResults),
                },
                Latency:   time.Since(start),
                Timestamp: time.Now(),
        }, nil</span>
}

// WeightedAggregationStrategy performs weighted aggregation
type WeightedAggregationStrategy struct {
        name string
}

func (was *WeightedAggregationStrategy) GetName() string <span class="cov0" title="0">{
        return "weighted"
}</span>

func (was *WeightedAggregationStrategy) Aggregate(context *AggregationContext) (*AggregatedResponse, error) <span class="cov0" title="0">{
        start := time.Now()
        
        // Perform weighted aggregation
        var weightedSum float64
        var totalWeight float64
        
        for _, partial := range context.PartialResults </span><span class="cov0" title="0">{
                if partial.Error == "" </span><span class="cov0" title="0">{
                        if value, ok := partial.Data.(float64); ok </span><span class="cov0" title="0">{
                                // Get weight from metadata, default to 1.0
                                weight := 1.0
                                if w, exists := partial.Metadata["weight"]; exists </span><span class="cov0" title="0">{
                                        if weightVal, ok := w.(float64); ok </span><span class="cov0" title="0">{
                                                weight = weightVal
                                        }</span>
                                }
                                
                                <span class="cov0" title="0">weightedSum += value * weight
                                totalWeight += weight</span>
                        }
                }
        }
        
        <span class="cov0" title="0">if totalWeight == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no valid weighted results to aggregate")
        }</span>
        
        <span class="cov0" title="0">weightedAverage := weightedSum / totalWeight
        
        return &amp;AggregatedResponse{
                TaskID:    context.TaskID,
                Strategy:  was.GetName(),
                Data:      weightedAverage,
                Metadata: map[string]interface{}{
                        "weighted_sum":     weightedSum,
                        "total_weight":     totalWeight,
                        "weighted_average": weightedAverage,
                        "total_partitions": len(context.PartialResults),
                },
                Latency:   time.Since(start),
                Timestamp: time.Now(),
        }, nil</span>
}

// RoundRobinPartitioningStrategy implements round-robin partitioning
type RoundRobinPartitioningStrategy struct {
        name    string
        counter int
}

func (rrps *RoundRobinPartitioningStrategy) GetName() string <span class="cov0" title="0">{
        return "round_robin"
}</span>

func (rrps *RoundRobinPartitioningStrategy) Partition(request *OrchestrationRequest) (*PartitionPlan, error) <span class="cov0" title="0">{
        // Simple round-robin partitioning
        nodeCount := 3 // Mock node count
        partitions := make([]*TaskPartition, nodeCount)
        
        for i := 0; i &lt; nodeCount; i++ </span><span class="cov0" title="0">{
                partitions[i] = &amp;TaskPartition{
                        ID:           fmt.Sprintf("partition_%d", i),
                        NodeID:       fmt.Sprintf("node_%d", i),
                        Type:         "round_robin",
                        Data:         fmt.Sprintf("partition_data_%d", i),
                        Dependencies: []string{},
                        Metadata: map[string]interface{}{
                                "partition_index": i,
                                "total_partitions": nodeCount,
                        },
                }
        }</span>
        
        <span class="cov0" title="0">return &amp;PartitionPlan{
                ID:        fmt.Sprintf("plan_%d", time.Now().UnixNano()),
                Strategy:  rrps.GetName(),
                Partitions: partitions,
                Metadata: map[string]interface{}{
                        "strategy": "round_robin",
                        "node_count": nodeCount,
                },
                CreatedAt: time.Now(),
        }, nil</span>
}

// LoadBasedPartitioningStrategy implements load-based partitioning
type LoadBasedPartitioningStrategy struct {
        name string
}

func (lbps *LoadBasedPartitioningStrategy) GetName() string <span class="cov0" title="0">{
        return "load_based"
}</span>

func (lbps *LoadBasedPartitioningStrategy) Partition(request *OrchestrationRequest) (*PartitionPlan, error) <span class="cov0" title="0">{
        // Mock load-based partitioning
        nodeLoads := map[string]float64{
                "node_0": 0.3,
                "node_1": 0.7,
                "node_2": 0.5,
        }
        
        partitions := make([]*TaskPartition, 0)
        partitionIndex := 0
        
        for nodeID, load := range nodeLoads </span><span class="cov0" title="0">{
                // Assign more partitions to nodes with lower load
                partitionCount := int((1.0 - load) * 3) + 1
                
                for i := 0; i &lt; partitionCount; i++ </span><span class="cov0" title="0">{
                        partitions = append(partitions, &amp;TaskPartition{
                                ID:           fmt.Sprintf("partition_%d", partitionIndex),
                                NodeID:       nodeID,
                                Type:         "load_based",
                                Data:         fmt.Sprintf("partition_data_%d", partitionIndex),
                                Dependencies: []string{},
                                Metadata: map[string]interface{}{
                                        "node_load": load,
                                        "partition_weight": 1.0 - load,
                                },
                        })
                        partitionIndex++
                }</span>
        }
        
        <span class="cov0" title="0">return &amp;PartitionPlan{
                ID:        fmt.Sprintf("plan_%d", time.Now().UnixNano()),
                Strategy:  lbps.GetName(),
                Partitions: partitions,
                Metadata: map[string]interface{}{
                        "strategy": "load_based",
                        "node_loads": nodeLoads,
                        "total_partitions": len(partitions),
                },
                CreatedAt: time.Now(),
        }, nil</span>
}

// CapabilityBasedPartitioningStrategy implements capability-based partitioning
type CapabilityBasedPartitioningStrategy struct {
        name string
}

func (cbps *CapabilityBasedPartitioningStrategy) GetName() string <span class="cov0" title="0">{
        return "capability_based"
}</span>

func (cbps *CapabilityBasedPartitioningStrategy) Partition(request *OrchestrationRequest) (*PartitionPlan, error) <span class="cov0" title="0">{
        // Mock capability-based partitioning
        nodeCapabilities := map[string][]string{
                "node_0": {"cpu", "memory"},
                "node_1": {"gpu", "memory"},
                "node_2": {"cpu", "gpu", "memory"},
        }
        
        partitions := make([]*TaskPartition, 0)
        partitionIndex := 0
        
        for nodeID, capabilities := range nodeCapabilities </span><span class="cov0" title="0">{
                // Assign partitions based on capabilities
                for _, capability := range capabilities </span><span class="cov0" title="0">{
                        partitions = append(partitions, &amp;TaskPartition{
                                ID:           fmt.Sprintf("partition_%d", partitionIndex),
                                NodeID:       nodeID,
                                Type:         "capability_based",
                                Data:         fmt.Sprintf("partition_data_%s_%s", nodeID, capability),
                                Dependencies: []string{},
                                Metadata: map[string]interface{}{
                                        "required_capability": capability,
                                        "node_capabilities": capabilities,
                                },
                        })
                        partitionIndex++
                }</span>
        }
        
        <span class="cov0" title="0">return &amp;PartitionPlan{
                ID:        fmt.Sprintf("plan_%d", time.Now().UnixNano()),
                Strategy:  cbps.GetName(),
                Partitions: partitions,
                Metadata: map[string]interface{}{
                        "strategy": "capability_based",
                        "node_capabilities": nodeCapabilities,
                        "total_partitions": len(partitions),
                },
                CreatedAt: time.Now(),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package orchestration

import (
        "context"
        "fmt"
        "log/slog"
        "sync"
        "time"
)

// OrchestrationEngine manages distributed task orchestration
type OrchestrationEngine struct {
        config         *Config
        scheduler      *DistributedScheduler
        coordinator    *RequestCoordinator
        aggregator     *ResponseAggregator
        monitor        *OrchestrationMonitor
        activeTasks    map[string]*OrchestrationTask
        activeTasksMu  sync.RWMutex
        metrics        *OrchestrationMetrics
        mu             sync.RWMutex
        ctx            context.Context
        cancel         context.CancelFunc
        started        bool
}

// Config holds orchestration configuration
type Config struct {
        ClusterManager interface{} `json:"cluster_manager"`
        LoadBalancer   interface{} `json:"load_balancer"`
        FaultTolerance interface{} `json:"fault_tolerance"`
        MaxConcurrentTasks int     `json:"max_concurrent_tasks"`
        TaskTimeout        time.Duration `json:"task_timeout"`
        RetryPolicy        *RetryPolicy  `json:"retry_policy"`
        CoordinationMode   string        `json:"coordination_mode"`
}

// RetryPolicy defines retry behavior
type RetryPolicy struct {
        MaxRetries    int           `json:"max_retries"`
        InitialDelay  time.Duration `json:"initial_delay"`
        MaxDelay      time.Duration `json:"max_delay"`
        BackoffFactor float64       `json:"backoff_factor"`
}

// DistributedScheduler interface for scheduler operations
type DistributedScheduler interface {
        GetNodes() []interface{}
        GetMetrics() interface{}
}

// RequestCoordinator handles request coordination
type RequestCoordinator struct {
        engine      *OrchestrationEngine
        router      *RequestRouter
        partitioner *RequestPartitioner
        synchronizer *RequestSynchronizer
        stateManager *SessionStateManager
}

// RequestRouter handles request routing
type RequestRouter struct {
        coordinator *RequestCoordinator
        rules       []RoutingRule
        balancer    interface{}
        fallback    *FallbackStrategy
        metrics     *RoutingMetrics
}

// RoutingRule defines routing rules
type RoutingRule struct {
        ID        string                 `json:"id"`
        Condition string                 `json:"condition"`
        Action    string                 `json:"action"`
        Target    string                 `json:"target"`
        Priority  int                    `json:"priority"`
        Metadata  map[string]interface{} `json:"metadata"`
}

// FallbackStrategy defines fallback behavior
type FallbackStrategy struct {
        Type        string                 `json:"type"`
        Target      string                 `json:"target"`
        Timeout     time.Duration          `json:"timeout"`
        Metadata    map[string]interface{} `json:"metadata"`
}

// RoutingMetrics tracks routing performance
type RoutingMetrics struct {
        TotalRequests      int64         `json:"total_requests"`
        SuccessfulRoutes   int64         `json:"successful_routes"`
        FailedRoutes       int64         `json:"failed_routes"`
        AverageLatency     time.Duration `json:"average_latency"`
        RuleHitRate        float64       `json:"rule_hit_rate"`
        FallbackUsage      int64         `json:"fallback_usage"`
        LastUpdated        time.Time     `json:"last_updated"`
}

// RequestPartitioner handles request partitioning
type RequestPartitioner struct {
        coordinator *RequestCoordinator
        strategies  map[string]PartitioningStrategy
        optimizer   *PartitionOptimizer
}

// PartitioningStrategy interface for partitioning
type PartitioningStrategy interface {
        Partition(request *OrchestrationRequest) (*PartitionPlan, error)
        GetName() string
}

// PartitionOptimizer optimizes partitioning decisions
type PartitionOptimizer struct {
        partitioner *RequestPartitioner
        history     []*PartitionResult
        historyMu   sync.RWMutex
        optimizationWeights map[string]float64
}

// PartitionPlan represents a partitioning plan
type PartitionPlan struct {
        ID          string                 `json:"id"`
        Strategy    string                 `json:"strategy"`
        Partitions  []*TaskPartition       `json:"partitions"`
        Metadata    map[string]interface{} `json:"metadata"`
        CreatedAt   time.Time              `json:"created_at"`
}

// TaskPartition represents a task partition
type TaskPartition struct {
        ID           string                 `json:"id"`
        NodeID       string                 `json:"node_id"`
        Type         string                 `json:"type"`
        Data         interface{}            `json:"data"`
        Dependencies []string               `json:"dependencies"`
        Metadata     map[string]interface{} `json:"metadata"`
}

// PartitionResult represents partitioning results
type PartitionResult struct {
        Plan         *PartitionPlan `json:"plan"`
        Success      bool           `json:"success"`
        Latency      time.Duration  `json:"latency"`
        Throughput   float64        `json:"throughput"`
        Timestamp    time.Time      `json:"timestamp"`
}

// RequestSynchronizer handles request synchronization
type RequestSynchronizer struct {
        coordinator   *RequestCoordinator
        syncPoints    map[string]*SyncPoint
        syncPointsMu  sync.RWMutex
        barriers      map[string]*SyncBarrier
        barriersMu    sync.RWMutex
}

// SyncPoint represents a synchronization point
type SyncPoint struct {
        ID          string                 `json:"id"`
        Type        string                 `json:"type"`
        Condition   string                 `json:"condition"`
        WaitingTasks []string              `json:"waiting_tasks"`
        Completed   bool                   `json:"completed"`
        Metadata    map[string]interface{} `json:"metadata"`
        CreatedAt   time.Time              `json:"created_at"`
}

// SyncBarrier represents a synchronization barrier
type SyncBarrier struct {
        ID            string                 `json:"id"`
        RequiredTasks []string               `json:"required_tasks"`
        CompletedTasks []string              `json:"completed_tasks"`
        WaitingTasks  []string               `json:"waiting_tasks"`
        Released      bool                   `json:"released"`
        Metadata      map[string]interface{} `json:"metadata"`
        CreatedAt     time.Time              `json:"created_at"`
}

// SessionStateManager manages session state
type SessionStateManager struct {
        coordinator *RequestCoordinator
        sessions    map[string]*SessionState
        sessionsMu  sync.RWMutex
        persistence SessionPersistence
}

// SessionState represents session state
type SessionState struct {
        ID          string                 `json:"id"`
        Status      string                 `json:"status"`
        Requests    []string               `json:"requests"`
        Responses   []string               `json:"responses"`
        Metadata    map[string]interface{} `json:"metadata"`
        CreatedAt   time.Time              `json:"created_at"`
        UpdatedAt   time.Time              `json:"updated_at"`
}

// SessionPersistence interface for session persistence
type SessionPersistence interface {
        Save(session *SessionState) error
        Load(id string) (*SessionState, error)
        Delete(id string) error
        List() ([]*SessionState, error)
}

// ResponseAggregator handles response aggregation
type ResponseAggregator struct {
        engine      *OrchestrationEngine
        strategies  map[string]AggregationStrategy
        pendingResults map[string]*AggregationContext
        pendingMu   sync.RWMutex
}

// AggregationStrategy interface for aggregation
type AggregationStrategy interface {
        Aggregate(context *AggregationContext) (*AggregatedResponse, error)
        GetName() string
}

// AggregationContext holds aggregation context
type AggregationContext struct {
        TaskID      string                 `json:"task_id"`
        Strategy    string                 `json:"strategy"`
        PartialResults []PartialResult     `json:"partial_results"`
        Metadata    map[string]interface{} `json:"metadata"`
        CreatedAt   time.Time              `json:"created_at"`
}

// PartialResult represents a partial result
type PartialResult struct {
        PartitionID string                 `json:"partition_id"`
        NodeID      string                 `json:"node_id"`
        Data        interface{}            `json:"data"`
        Error       string                 `json:"error,omitempty"`
        Metadata    map[string]interface{} `json:"metadata"`
        Timestamp   time.Time              `json:"timestamp"`
}

// AggregatedResponse represents an aggregated response
type AggregatedResponse struct {
        TaskID      string                 `json:"task_id"`
        Strategy    string                 `json:"strategy"`
        Data        interface{}            `json:"data"`
        Metadata    map[string]interface{} `json:"metadata"`
        Latency     time.Duration          `json:"latency"`
        Timestamp   time.Time              `json:"timestamp"`
}

// OrchestrationMonitor monitors orchestration performance
type OrchestrationMonitor struct {
        engine    *OrchestrationEngine
        metrics   *OrchestrationMetrics
        monitors  []Monitor
        interval  time.Duration
        stopCh    chan struct{}
}

// Monitor interface for monitoring
type Monitor interface {
        Collect() (map[string]interface{}, error)
        GetName() string
}

// OrchestrationMetrics tracks orchestration metrics
type OrchestrationMetrics struct {
        TotalTasks         int64         `json:"total_tasks"`
        ActiveTasks        int64         `json:"active_tasks"`
        CompletedTasks     int64         `json:"completed_tasks"`
        FailedTasks        int64         `json:"failed_tasks"`
        AverageLatency     time.Duration `json:"average_latency"`
        Throughput         float64       `json:"throughput"`
        ResourceUtilization float64      `json:"resource_utilization"`
        ErrorRate          float64       `json:"error_rate"`
        LastUpdated        time.Time     `json:"last_updated"`
}

// OrchestrationTask represents a task being orchestrated
type OrchestrationTask struct {
        ID              string                 `json:"id"`
        Type            string                 `json:"type"`
        Request         *OrchestrationRequest  `json:"request"`
        PartitionPlan   *PartitionPlan         `json:"partition_plan"`
        PartialResults  []PartialResult        `json:"partial_results"`
        AggregatedResult *AggregatedResponse   `json:"aggregated_result"`
        Status          TaskStatus             `json:"status"`
        StartedAt       time.Time              `json:"started_at"`
        CompletedAt     *time.Time             `json:"completed_at"`
        Metadata        map[string]interface{} `json:"metadata"`
        RetryCount      int                    `json:"retry_count"`
        LastError       string                 `json:"last_error"`
}

// TaskStatus represents task status
type TaskStatus string

const (
        TaskStatusPending     TaskStatus = "pending"
        TaskStatusPartitioned TaskStatus = "partitioned"
        TaskStatusExecuting   TaskStatus = "executing"
        TaskStatusAggregating TaskStatus = "aggregating"
        TaskStatusCompleted   TaskStatus = "completed"
        TaskStatusFailed      TaskStatus = "failed"
        TaskStatusRetrying    TaskStatus = "retrying"
)

// OrchestrationRequest represents a request for orchestration
type OrchestrationRequest struct {
        ID          string                 `json:"id"`
        Type        string                 `json:"type"`
        Payload     interface{}            `json:"payload"`
        Options     map[string]interface{} `json:"options"`
        Priority    int                    `json:"priority"`
        Timeout     time.Duration          `json:"timeout"`
        Metadata    map[string]interface{} `json:"metadata"`
        CreatedAt   time.Time              `json:"created_at"`
}

// NewOrchestrationEngine creates a new orchestration engine
func NewOrchestrationEngine(config *Config) *OrchestrationEngine <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())
        
        oe := &amp;OrchestrationEngine{
                config:      config,
                activeTasks: make(map[string]*OrchestrationTask),
                metrics:     &amp;OrchestrationMetrics{LastUpdated: time.Now()},
                ctx:         ctx,
                cancel:      cancel,
        }
        
        // Initialize components
        oe.initializeComponents()
        
        return oe
}</span>

// initializeComponents initializes all orchestration components
func (oe *OrchestrationEngine) initializeComponents() <span class="cov0" title="0">{
        // Initialize request coordinator
        oe.coordinator = &amp;RequestCoordinator{
                engine: oe,
        }
        
        // Initialize request router
        oe.coordinator.router = &amp;RequestRouter{
                coordinator: oe.coordinator,
                rules:       make([]RoutingRule, 0),
                fallback: &amp;FallbackStrategy{
                        Type:    "local",
                        Timeout: 30 * time.Second,
                },
                metrics: &amp;RoutingMetrics{LastUpdated: time.Now()},
        }
        
        // Initialize request partitioner
        oe.coordinator.partitioner = &amp;RequestPartitioner{
                coordinator: oe.coordinator,
                strategies:  make(map[string]PartitioningStrategy),
                optimizer: &amp;PartitionOptimizer{
                        history: make([]*PartitionResult, 0),
                        optimizationWeights: map[string]float64{
                                "latency":    0.4,
                                "throughput": 0.3,
                                "resource":   0.2,
                                "reliability": 0.1,
                        },
                },
        }
        
        // Initialize request synchronizer
        oe.coordinator.synchronizer = &amp;RequestSynchronizer{
                coordinator: oe.coordinator,
                syncPoints:  make(map[string]*SyncPoint),
                barriers:    make(map[string]*SyncBarrier),
        }
        
        // Initialize session state manager
        oe.coordinator.stateManager = &amp;SessionStateManager{
                coordinator: oe.coordinator,
                sessions:    make(map[string]*SessionState),
        }
        
        // Initialize response aggregator
        oe.aggregator = &amp;ResponseAggregator{
                engine:         oe,
                strategies:     make(map[string]AggregationStrategy),
                pendingResults: make(map[string]*AggregationContext),
        }
        
        // Initialize orchestration monitor
        oe.monitor = &amp;OrchestrationMonitor{
                engine:   oe,
                metrics:  oe.metrics,
                monitors: make([]Monitor, 0),
                interval: 10 * time.Second,
                stopCh:   make(chan struct{}),
        }
        
        // Register default strategies
        oe.registerDefaultStrategies()
}</span>

// registerDefaultStrategies registers default strategies
func (oe *OrchestrationEngine) registerDefaultStrategies() <span class="cov0" title="0">{
        // Register aggregation strategies
        oe.aggregator.strategies["concat"] = &amp;ConcatAggregationStrategy{}
        oe.aggregator.strategies["average"] = &amp;AverageAggregationStrategy{}
        oe.aggregator.strategies["weighted"] = &amp;WeightedAggregationStrategy{}
        
        // Register partitioning strategies
        oe.coordinator.partitioner.strategies["round_robin"] = &amp;RoundRobinPartitioningStrategy{}
        oe.coordinator.partitioner.strategies["load_based"] = &amp;LoadBasedPartitioningStrategy{}
        oe.coordinator.partitioner.strategies["capability_based"] = &amp;CapabilityBasedPartitioningStrategy{}
}</span>

// Start starts the orchestration engine
func (oe *OrchestrationEngine) Start(ctx context.Context) error <span class="cov0" title="0">{
        oe.mu.Lock()
        defer oe.mu.Unlock()
        
        if oe.started </span><span class="cov0" title="0">{
                return fmt.Errorf("orchestration engine already started")
        }</span>
        
        // Start monitoring
        <span class="cov0" title="0">go oe.monitor.start(oe.ctx)
        
        // Start request processing
        go oe.processRequests(oe.ctx)
        
        // Start result aggregation
        go oe.processAggregation(oe.ctx)
        
        oe.started = true
        
        slog.Info("orchestration engine started",
                "max_concurrent_tasks", oe.config.MaxConcurrentTasks,
                "coordination_mode", oe.config.CoordinationMode)
        
        return nil</span>
}

// ExecuteTask executes a distributed task
func (oe *OrchestrationEngine) ExecuteTask(ctx context.Context, task interface{}) error <span class="cov0" title="0">{
        // Convert task to orchestration request
        request := oe.convertToOrchestrationRequest(task)
        
        // Create orchestration task
        orchTask := &amp;OrchestrationTask{
                ID:         request.ID,
                Type:       request.Type,
                Request:    request,
                Status:     TaskStatusPending,
                StartedAt:  time.Now(),
                Metadata:   make(map[string]interface{}),
                RetryCount: 0,
        }
        
        // Store active task
        oe.activeTasksMu.Lock()
        oe.activeTasks[orchTask.ID] = orchTask
        oe.activeTasksMu.Unlock()
        
        // Update metrics
        oe.metrics.TotalTasks++
        oe.metrics.ActiveTasks++
        
        // Execute task asynchronously
        go oe.executeTaskAsync(ctx, orchTask)
        
        return nil
}</span>

// convertToOrchestrationRequest converts a task to orchestration request
func (oe *OrchestrationEngine) convertToOrchestrationRequest(task interface{}) *OrchestrationRequest <span class="cov0" title="0">{
        return &amp;OrchestrationRequest{
                ID:        fmt.Sprintf("req_%d", time.Now().UnixNano()),
                Type:      "distributed_inference",
                Payload:   task,
                Options:   make(map[string]interface{}),
                Priority:  1,
                Timeout:   oe.config.TaskTimeout,
                Metadata:  make(map[string]interface{}),
                CreatedAt: time.Now(),
        }
}</span>

// executeTaskAsync executes a task asynchronously
func (oe *OrchestrationEngine) executeTaskAsync(ctx context.Context, task *OrchestrationTask) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                // Clean up task
                oe.activeTasksMu.Lock()
                delete(oe.activeTasks, task.ID)
                oe.activeTasksMu.Unlock()
                
                // Update metrics
                oe.metrics.ActiveTasks--
                if task.Status == TaskStatusCompleted </span><span class="cov0" title="0">{
                        oe.metrics.CompletedTasks++
                }</span> else<span class="cov0" title="0"> {
                        oe.metrics.FailedTasks++
                }</span>
        }()
        
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                switch task.Status </span>{
                case TaskStatusPending:<span class="cov0" title="0">
                        if err := oe.partitionTask(ctx, task); err != nil </span><span class="cov0" title="0">{
                                if oe.shouldRetry(task, err) </span><span class="cov0" title="0">{
                                        oe.retryTask(task, err)
                                        continue</span>
                                }
                                <span class="cov0" title="0">oe.failTask(task, err)
                                return</span>
                        }
                        <span class="cov0" title="0">task.Status = TaskStatusPartitioned</span>
                        
                case TaskStatusPartitioned:<span class="cov0" title="0">
                        if err := oe.executePartitions(ctx, task); err != nil </span><span class="cov0" title="0">{
                                if oe.shouldRetry(task, err) </span><span class="cov0" title="0">{
                                        oe.retryTask(task, err)
                                        continue</span>
                                }
                                <span class="cov0" title="0">oe.failTask(task, err)
                                return</span>
                        }
                        <span class="cov0" title="0">task.Status = TaskStatusExecuting</span>
                        
                case TaskStatusExecuting:<span class="cov0" title="0">
                        if oe.arePartitionsComplete(task) </span><span class="cov0" title="0">{
                                task.Status = TaskStatusAggregating
                        }</span> else<span class="cov0" title="0"> {
                                // Wait for partitions to complete
                                time.Sleep(100 * time.Millisecond)
                        }</span>
                        
                case TaskStatusAggregating:<span class="cov0" title="0">
                        if err := oe.aggregateResults(ctx, task); err != nil </span><span class="cov0" title="0">{
                                if oe.shouldRetry(task, err) </span><span class="cov0" title="0">{
                                        oe.retryTask(task, err)
                                        continue</span>
                                }
                                <span class="cov0" title="0">oe.failTask(task, err)
                                return</span>
                        }
                        <span class="cov0" title="0">task.Status = TaskStatusCompleted
                        completedAt := time.Now()
                        task.CompletedAt = &amp;completedAt</span>
                        
                case TaskStatusCompleted:<span class="cov0" title="0">
                        slog.Info("task completed", "task_id", task.ID, "duration", time.Since(task.StartedAt))
                        return</span>
                        
                case TaskStatusFailed:<span class="cov0" title="0">
                        slog.Error("task failed", "task_id", task.ID, "error", task.LastError)
                        return</span>
                        
                case TaskStatusRetrying:<span class="cov0" title="0">
                        // Wait before retrying
                        delay := oe.calculateRetryDelay(task.RetryCount)
                        time.Sleep(delay)
                        task.Status = TaskStatusPending</span>
                        
                default:<span class="cov0" title="0">
                        slog.Error("unknown task status", "task_id", task.ID, "status", task.Status)
                        return</span>
                }
        }
}

// partitionTask partitions a task for distributed execution
func (oe *OrchestrationEngine) partitionTask(ctx context.Context, task *OrchestrationTask) error <span class="cov0" title="0">{
        // Select partitioning strategy
        strategy, err := oe.selectPartitioningStrategy(task)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to select partitioning strategy: %v", err)
        }</span>
        
        // Partition the task
        <span class="cov0" title="0">plan, err := strategy.Partition(task.Request)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to partition task: %v", err)
        }</span>
        
        <span class="cov0" title="0">task.PartitionPlan = plan
        return nil</span>
}

// selectPartitioningStrategy selects the best partitioning strategy
func (oe *OrchestrationEngine) selectPartitioningStrategy(task *OrchestrationTask) (PartitioningStrategy, error) <span class="cov0" title="0">{
        // Simple strategy selection based on task type
        switch task.Type </span>{
        case "distributed_inference":<span class="cov0" title="0">
                return oe.coordinator.partitioner.strategies["load_based"], nil</span>
        case "batch_processing":<span class="cov0" title="0">
                return oe.coordinator.partitioner.strategies["round_robin"], nil</span>
        default:<span class="cov0" title="0">
                return oe.coordinator.partitioner.strategies["capability_based"], nil</span>
        }
}

// executePartitions executes task partitions
func (oe *OrchestrationEngine) executePartitions(ctx context.Context, task *OrchestrationTask) error <span class="cov0" title="0">{
        // Execute partitions in parallel
        for _, partition := range task.PartitionPlan.Partitions </span><span class="cov0" title="0">{
                go oe.executePartition(ctx, task, partition)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// executePartition executes a single partition
func (oe *OrchestrationEngine) executePartition(ctx context.Context, task *OrchestrationTask, partition *TaskPartition) <span class="cov0" title="0">{
        start := time.Now()
        
        // Simulate partition execution
        time.Sleep(100 * time.Millisecond)
        
        // Create partial result
        result := PartialResult{
                PartitionID: partition.ID,
                NodeID:      partition.NodeID,
                Data:        "mock_result",
                Metadata:    make(map[string]interface{}),
                Timestamp:   time.Now(),
        }
        
        // Store partial result
        task.PartialResults = append(task.PartialResults, result)
        
        slog.Debug("partition executed", "task_id", task.ID, "partition_id", partition.ID, "duration", time.Since(start))
}</span>

// arePartitionsComplete checks if all partitions are complete
func (oe *OrchestrationEngine) arePartitionsComplete(task *OrchestrationTask) bool <span class="cov0" title="0">{
        return len(task.PartialResults) &gt;= len(task.PartitionPlan.Partitions)
}</span>

// aggregateResults aggregates partial results
func (oe *OrchestrationEngine) aggregateResults(ctx context.Context, task *OrchestrationTask) error <span class="cov0" title="0">{
        // Create aggregation context
        aggCtx := &amp;AggregationContext{
                TaskID:         task.ID,
                Strategy:       "concat", // Default strategy
                PartialResults: task.PartialResults,
                Metadata:       make(map[string]interface{}),
                CreatedAt:      time.Now(),
        }
        
        // Select aggregation strategy
        strategy := oe.aggregator.strategies[aggCtx.Strategy]
        if strategy == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("aggregation strategy not found: %s", aggCtx.Strategy)
        }</span>
        
        // Aggregate results
        <span class="cov0" title="0">aggregated, err := strategy.Aggregate(aggCtx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to aggregate results: %v", err)
        }</span>
        
        <span class="cov0" title="0">task.AggregatedResult = aggregated
        return nil</span>
}

// shouldRetry determines if a task should be retried
func (oe *OrchestrationEngine) shouldRetry(task *OrchestrationTask, err error) bool <span class="cov0" title="0">{
        if oe.config.RetryPolicy == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">return task.RetryCount &lt; oe.config.RetryPolicy.MaxRetries</span>
}

// retryTask prepares a task for retry
func (oe *OrchestrationEngine) retryTask(task *OrchestrationTask, err error) <span class="cov0" title="0">{
        task.RetryCount++
        task.LastError = err.Error()
        task.Status = TaskStatusRetrying
        
        slog.Warn("retrying task", "task_id", task.ID, "retry_count", task.RetryCount, "error", err)
}</span>

// failTask marks a task as failed
func (oe *OrchestrationEngine) failTask(task *OrchestrationTask, err error) <span class="cov0" title="0">{
        task.Status = TaskStatusFailed
        task.LastError = err.Error()
        completedAt := time.Now()
        task.CompletedAt = &amp;completedAt
        
        slog.Error("task failed", "task_id", task.ID, "error", err)
}</span>

// calculateRetryDelay calculates retry delay with exponential backoff
func (oe *OrchestrationEngine) calculateRetryDelay(retryCount int) time.Duration <span class="cov0" title="0">{
        if oe.config.RetryPolicy == nil </span><span class="cov0" title="0">{
                return time.Second
        }</span>
        
        <span class="cov0" title="0">delay := oe.config.RetryPolicy.InitialDelay
        for i := 0; i &lt; retryCount; i++ </span><span class="cov0" title="0">{
                delay = time.Duration(float64(delay) * oe.config.RetryPolicy.BackoffFactor)
                if delay &gt; oe.config.RetryPolicy.MaxDelay </span><span class="cov0" title="0">{
                        delay = oe.config.RetryPolicy.MaxDelay
                        break</span>
                }
        }
        
        <span class="cov0" title="0">return delay</span>
}

// processRequests processes incoming requests
func (oe *OrchestrationEngine) processRequests(ctx context.Context) <span class="cov0" title="0">{
        slog.Info("request processor started")
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        slog.Info("request processor shutting down")
                        return</span>
                default:<span class="cov0" title="0">
                        // Process any pending requests
                        time.Sleep(100 * time.Millisecond)</span>
                }
        }
}

// processAggregation processes result aggregation
func (oe *OrchestrationEngine) processAggregation(ctx context.Context) <span class="cov0" title="0">{
        slog.Info("aggregation processor started")
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        slog.Info("aggregation processor shutting down")
                        return</span>
                default:<span class="cov0" title="0">
                        // Process any pending aggregations
                        time.Sleep(100 * time.Millisecond)</span>
                }
        }
}

// GetMetrics returns orchestration metrics
func (oe *OrchestrationEngine) GetMetrics() *OrchestrationMetrics <span class="cov0" title="0">{
        oe.mu.RLock()
        defer oe.mu.RUnlock()
        
        // Update metrics
        if oe.metrics.TotalTasks &gt; 0 </span><span class="cov0" title="0">{
                oe.metrics.ErrorRate = float64(oe.metrics.FailedTasks) / float64(oe.metrics.TotalTasks)
                oe.metrics.Throughput = float64(oe.metrics.CompletedTasks) / time.Since(oe.metrics.LastUpdated).Seconds()
        }</span>
        
        <span class="cov0" title="0">return oe.metrics</span>
}

// GetActiveTasks returns active tasks
func (oe *OrchestrationEngine) GetActiveTasks() []*OrchestrationTask <span class="cov0" title="0">{
        oe.activeTasksMu.RLock()
        defer oe.activeTasksMu.RUnlock()
        
        tasks := make([]*OrchestrationTask, 0, len(oe.activeTasks))
        for _, task := range oe.activeTasks </span><span class="cov0" title="0">{
                tasks = append(tasks, task)
        }</span>
        
        <span class="cov0" title="0">return tasks</span>
}

// Shutdown gracefully shuts down the orchestration engine
func (oe *OrchestrationEngine) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        oe.mu.Lock()
        defer oe.mu.Unlock()
        
        if !oe.started </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">slog.Info("shutting down orchestration engine")
        
        // Stop monitoring
        close(oe.monitor.stopCh)
        
        // Cancel context
        oe.cancel()
        
        // Wait for active tasks to complete
        shutdownCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
        defer cancel()
        
        for </span><span class="cov0" title="0">{
                oe.activeTasksMu.RLock()
                activeCount := len(oe.activeTasks)
                oe.activeTasksMu.RUnlock()
                
                if activeCount == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
                
                <span class="cov0" title="0">select </span>{
                case &lt;-shutdownCtx.Done():<span class="cov0" title="0">
                        slog.Warn("shutdown timeout, forcing shutdown with active tasks", "active_tasks", activeCount)
                        return nil</span>
                default:<span class="cov0" title="0">
                        time.Sleep(100 * time.Millisecond)</span>
                }
        }
        
        <span class="cov0" title="0">oe.started = false
        
        return nil</span>
}

// Monitor methods

// start starts the orchestration monitor
func (om *OrchestrationMonitor) start(ctx context.Context) <span class="cov0" title="0">{
        ticker := time.NewTicker(om.interval)
        defer ticker.Stop()
        
        slog.Info("orchestration monitor started")
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        slog.Info("orchestration monitor shutting down")
                        return</span>
                case &lt;-om.stopCh:<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        om.collectMetrics()</span>
                }
        }
}

// collectMetrics collects metrics from all monitors
func (om *OrchestrationMonitor) collectMetrics() <span class="cov0" title="0">{
        for _, monitor := range om.monitors </span><span class="cov0" title="0">{
                metrics, err := monitor.Collect()
                if err != nil </span><span class="cov0" title="0">{
                        slog.Warn("failed to collect metrics", "monitor", monitor.GetName(), "error", err)
                        continue</span>
                }
                
                // Process metrics
                <span class="cov0" title="0">om.processMetrics(monitor.GetName(), metrics)</span>
        }
        
        // Update last updated time
        <span class="cov0" title="0">om.metrics.LastUpdated = time.Now()</span>
}

// processMetrics processes collected metrics
func (om *OrchestrationMonitor) processMetrics(monitorName string, metrics map[string]interface{}) <span class="cov0" title="0">{
        // Process metrics based on monitor type
        switch monitorName </span>{
        case "resource_monitor":<span class="cov0" title="0">
                if util, ok := metrics["resource_utilization"].(float64); ok </span><span class="cov0" title="0">{
                        om.metrics.ResourceUtilization = util
                }</span>
        case "performance_monitor":<span class="cov0" title="0">
                if latency, ok := metrics["average_latency"].(time.Duration); ok </span><span class="cov0" title="0">{
                        om.metrics.AverageLatency = latency
                }</span>
        case "throughput_monitor":<span class="cov0" title="0">
                if throughput, ok := metrics["throughput"].(float64); ok </span><span class="cov0" title="0">{
                        om.metrics.Throughput = throughput
                }</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
