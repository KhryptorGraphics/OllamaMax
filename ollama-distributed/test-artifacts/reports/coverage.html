
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>auth: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/ollama/ollama-distributed/internal/auth/auth.go (70.5%)</option>
				
				<option value="file1">github.com/ollama/ollama-distributed/internal/auth/integration.go (0.0%)</option>
				
				<option value="file2">github.com/ollama/ollama-distributed/internal/auth/jwt.go (36.7%)</option>
				
				<option value="file3">github.com/ollama/ollama-distributed/internal/auth/middleware.go (0.0%)</option>
				
				<option value="file4">github.com/ollama/ollama-distributed/internal/auth/routes.go (0.0%)</option>
				
				<option value="file5">github.com/ollama/ollama-distributed/internal/auth/server_example.go (0.0%)</option>
				
				<option value="file6">github.com/ollama/ollama-distributed/internal/auth/types.go (0.0%)</option>
				
				<option value="file7">github.com/ollama/ollama-distributed/internal/config/config.go (0.0%)</option>
				
				<option value="file8">github.com/ollama/ollama-distributed/internal/storage/distributed.go (0.0%)</option>
				
				<option value="file9">github.com/ollama/ollama-distributed/internal/storage/interface.go (0.0%)</option>
				
				<option value="file10">github.com/ollama/ollama-distributed/internal/storage/local.go (65.5%)</option>
				
				<option value="file11">github.com/ollama/ollama-distributed/internal/storage/metadata.go (67.3%)</option>
				
				<option value="file12">github.com/ollama/ollama-distributed/internal/storage/replication.go (49.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package auth

import (
        "crypto/rand"
        "crypto/sha256"
        "crypto/subtle"
        "encoding/hex"
        "fmt"
        "sync"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "github.com/ollama/ollama-distributed/internal/config"
        "golang.org/x/crypto/bcrypt"
)

// Manager handles all authentication operations
type Manager struct {
        config *config.AuthConfig
        
        // JWT signing key
        signingKey []byte
        
        // In-memory stores (in production, these would be backed by persistent storage)
        users          map[string]*User
        apiKeys        map[string]*APIKey
        sessions       map[string]*Session
        blacklistCache map[string]time.Time
        
        // Password hasher
        bcryptCost int
        
        // Mutex for thread safety
        mu sync.RWMutex
        
        // Background cleanup
        stopCleanup chan struct{}
}

// NewManager creates a new authentication manager
func NewManager(cfg *config.AuthConfig) (*Manager, error) <span class="cov10" title="3">{
        if cfg == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("auth config is required")
        }</span>
        
        // Generate or use provided signing key
        <span class="cov10" title="3">signingKey := []byte(cfg.SecretKey)
        if len(signingKey) == 0 </span><span class="cov0" title="0">{
                // Generate a random signing key
                signingKey = make([]byte, 32)
                if _, err := rand.Read(signingKey); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to generate signing key: %w", err)
                }</span>
        }
        
        <span class="cov10" title="3">manager := &amp;Manager{
                config:         cfg,
                signingKey:     signingKey,
                users:          make(map[string]*User),
                apiKeys:        make(map[string]*APIKey),
                sessions:       make(map[string]*Session),
                blacklistCache: make(map[string]time.Time),
                bcryptCost:     bcrypt.DefaultCost,
                stopCleanup:    make(chan struct{}),
        }
        
        // Create default admin user if none exists
        if err := manager.createDefaultAdmin(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create default admin: %w", err)
        }</span>
        
        // Start background cleanup routines
        <span class="cov10" title="3">go manager.cleanupExpiredSessions()
        go manager.cleanupBlacklist()
        
        return manager, nil</span>
}

// Close gracefully shuts down the auth manager
func (m *Manager) Close() <span class="cov10" title="3">{
        close(m.stopCleanup)
}</span>

// createDefaultAdmin creates a default admin user if no users exist
func (m *Manager) createDefaultAdmin() error <span class="cov10" title="3">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        // Check if any users exist
        if len(m.users) &gt; 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        // Create default admin user
        <span class="cov10" title="3">hashedPassword, err := bcrypt.GenerateFromPassword([]byte("admin123"), m.bcryptCost)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to hash default password: %w", err)
        }</span>
        
        <span class="cov10" title="3">adminUser := &amp;User{
                ID:          generateID(),
                Username:    "admin",
                Email:       "admin@localhost",
                Role:        RoleAdmin,
                Permissions: DefaultRolePermissions[RoleAdmin],
                Metadata: map[string]string{
                        "password_hash": string(hashedPassword),
                        "created_by":    "system",
                },
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
                Active:    true,
        }
        
        m.users[adminUser.ID] = adminUser
        
        fmt.Printf("Created default admin user (username: admin, password: admin123)\n")
        fmt.Printf("WARNING: Please change the default password immediately!\n")
        
        return nil</span>
}

// Authenticate validates credentials and returns an auth context
func (m *Manager) Authenticate(username, password string, metadata map[string]string) (*AuthContext, error) <span class="cov10" title="3">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        
        // Find user by username
        var user *User
        for _, u := range m.users </span><span class="cov10" title="3">{
                if u.Username == username &amp;&amp; u.Active </span><span class="cov10" title="3">{
                        user = u
                        break</span>
                }
        }
        
        <span class="cov10" title="3">if user == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidCredentials
        }</span>
        
        // Verify password
        <span class="cov10" title="3">passwordHash := user.Metadata["password_hash"]
        if err := bcrypt.CompareHashAndPassword([]byte(passwordHash), []byte(password)); err != nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidCredentials
        }</span>
        
        // Update last login
        <span class="cov10" title="3">now := time.Now()
        user.LastLoginAt = &amp;now
        user.UpdatedAt = now
        
        // Create session
        session := &amp;Session{
                ID:        generateID(),
                UserID:    user.ID,
                IPAddress: metadata["ip_address"],
                UserAgent: metadata["user_agent"],
                Metadata:  metadata,
                CreatedAt: now,
                ExpiresAt: now.Add(m.config.TokenExpiry),
                Active:    true,
        }
        
        m.sessions[session.ID] = session
        
        // Generate JWT token
        claims := &amp;Claims{
                UserID:      user.ID,
                Username:    user.Username,
                Email:       user.Email,
                Role:        user.Role,
                Permissions: user.Permissions,
                SessionID:   session.ID,
                Metadata:    user.Metadata,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(session.ExpiresAt),
                        IssuedAt:  jwt.NewNumericDate(now),
                        NotBefore: jwt.NewNumericDate(now),
                        Issuer:    m.config.Issuer,
                        Subject:   user.ID,
                        ID:        generateID(),
                        Audience:  []string{m.config.Audience},
                },
        }
        
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        tokenString, err := token.SignedString(m.signingKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to sign token: %w", err)
        }</span>
        
        <span class="cov10" title="3">session.TokenID = claims.ID
        
        return &amp;AuthContext{
                User:        user,
                Session:     session,
                Claims:      claims,
                TokenString: tokenString,
                Method:      AuthMethodJWT,
        }, nil</span>
}

// ValidateToken validates a JWT token and returns the auth context
func (m *Manager) ValidateToken(tokenString string) (*AuthContext, error) <span class="cov10" title="3">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov10" title="3">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov10" title="3">return m.signingKey, nil</span>
        })
        
        <span class="cov10" title="3">if err != nil </span><span class="cov0" title="0">{
                return nil, ErrTokenInvalid
        }</span>
        
        <span class="cov10" title="3">claims, ok := token.Claims.(*Claims)
        if !ok || !token.Valid </span><span class="cov0" title="0">{
                return nil, ErrTokenInvalid
        }</span>
        
        // Check if token is blacklisted
        <span class="cov10" title="3">if m.isTokenBlacklisted(claims.ID) </span><span class="cov10" title="3">{
                return nil, ErrTokenBlacklisted
        }</span>
        
        <span class="cov10" title="3">m.mu.RLock()
        defer m.mu.RUnlock()
        
        // Get user
        user, exists := m.users[claims.UserID]
        if !exists || !user.Active </span><span class="cov0" title="0">{
                return nil, ErrUserNotFound
        }</span>
        
        // Get session if available
        <span class="cov10" title="3">var session *Session
        if claims.SessionID != "" </span><span class="cov10" title="3">{
                if s, exists := m.sessions[claims.SessionID]; exists &amp;&amp; s.Active </span><span class="cov10" title="3">{
                        if time.Now().After(s.ExpiresAt) </span><span class="cov0" title="0">{
                                return nil, ErrSessionExpired
                        }</span>
                        <span class="cov10" title="3">session = s</span>
                }
        }
        
        <span class="cov10" title="3">return &amp;AuthContext{
                User:        user,
                Session:     session,
                Claims:      claims,
                TokenString: tokenString,
                Method:      AuthMethodJWT,
        }, nil</span>
}

// ValidateAPIKey validates an API key and returns the auth context
func (m *Manager) ValidateAPIKey(key string) (*AuthContext, error) <span class="cov10" title="3">{
        keyHash := hashAPIKey(key)
        
        m.mu.RLock()
        defer m.mu.RUnlock()
        
        // Find API key
        var apiKey *APIKey
        for _, ak := range m.apiKeys </span><span class="cov10" title="3">{
                if subtle.ConstantTimeCompare([]byte(ak.Key), []byte(keyHash)) == 1 &amp;&amp; ak.Active </span><span class="cov10" title="3">{
                        apiKey = ak
                        break</span>
                }
        }
        
        <span class="cov10" title="3">if apiKey == nil </span><span class="cov0" title="0">{
                return nil, ErrAPIKeyNotFound
        }</span>
        
        // Check expiration
        <span class="cov10" title="3">if apiKey.ExpiresAt != nil &amp;&amp; time.Now().After(*apiKey.ExpiresAt) </span><span class="cov0" title="0">{
                return nil, ErrAPIKeyExpired
        }</span>
        
        // Get user
        <span class="cov10" title="3">user, exists := m.users[apiKey.UserID]
        if !exists || !user.Active </span><span class="cov0" title="0">{
                return nil, ErrUserNotFound
        }</span>
        
        // Update last used
        <span class="cov10" title="3">now := time.Now()
        apiKey.LastUsedAt = &amp;now
        
        return &amp;AuthContext{
                User:   user,
                APIKey: apiKey,
                Method: AuthMethodAPIKey,
        }, nil</span>
}

// CreateUser creates a new user
func (m *Manager) CreateUser(req *CreateUserRequest) (*User, error) <span class="cov10" title="3">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        // Check if username already exists
        for _, u := range m.users </span><span class="cov10" title="3">{
                if u.Username == req.Username </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("username already exists")
                }</span>
        }
        
        // Hash password
        <span class="cov10" title="3">hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), m.bcryptCost)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to hash password: %w", err)
        }</span>
        
        // Set permissions based on role if not provided
        <span class="cov10" title="3">permissions := req.Permissions
        if len(permissions) == 0 </span><span class="cov10" title="3">{
                if rolePerms, exists := DefaultRolePermissions[req.Role]; exists </span><span class="cov10" title="3">{
                        permissions = rolePerms
                }</span>
        }
        
        // Create user
        <span class="cov10" title="3">user := &amp;User{
                ID:          generateID(),
                Username:    req.Username,
                Email:       req.Email,
                Role:        req.Role,
                Permissions: permissions,
                Metadata: map[string]string{
                        "password_hash": string(hashedPassword),
                },
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
                Active:    true,
        }
        
        // Add custom metadata
        for k, v := range req.Metadata </span><span class="cov0" title="0">{
                user.Metadata[k] = v
        }</span>
        
        <span class="cov10" title="3">m.users[user.ID] = user
        
        return user, nil</span>
}

// CreateAPIKey creates a new API key for a user
func (m *Manager) CreateAPIKey(userID string, req *CreateAPIKeyRequest) (*APIKey, string, error) <span class="cov10" title="3">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        // Check if user exists
        user, exists := m.users[userID]
        if !exists || !user.Active </span><span class="cov0" title="0">{
                return nil, "", ErrUserNotFound
        }</span>
        
        // Generate API key
        <span class="cov10" title="3">rawKey := generateAPIKey()
        keyHash := hashAPIKey(rawKey)
        
        // Set permissions
        permissions := req.Permissions
        if len(permissions) == 0 </span><span class="cov0" title="0">{
                permissions = user.Permissions
        }</span>
        
        <span class="cov10" title="3">apiKey := &amp;APIKey{
                ID:          generateID(),
                Name:        req.Name,
                Key:         keyHash,
                UserID:      userID,
                Permissions: permissions,
                Metadata:    req.Metadata,
                ExpiresAt:   req.ExpiresAt,
                CreatedAt:   time.Now(),
                Active:      true,
        }
        
        if apiKey.Metadata == nil </span><span class="cov10" title="3">{
                apiKey.Metadata = make(map[string]string)
        }</span>
        
        <span class="cov10" title="3">m.apiKeys[apiKey.ID] = apiKey
        
        return apiKey, rawKey, nil</span>
}

// RevokeToken adds a token to the blacklist
func (m *Manager) RevokeToken(tokenID string, expiry time.Time) <span class="cov10" title="3">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        m.blacklistCache[tokenID] = expiry
}</span>

// RevokeSession revokes a session
func (m *Manager) RevokeSession(sessionID string) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        session, exists := m.sessions[sessionID]
        if !exists </span><span class="cov0" title="0">{
                return ErrSessionNotFound
        }</span>
        
        <span class="cov0" title="0">session.Active = false
        
        // Also blacklist the associated token
        if session.TokenID != "" </span><span class="cov0" title="0">{
                m.blacklistCache[session.TokenID] = session.ExpiresAt
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// RevokeAPIKey revokes an API key
func (m *Manager) RevokeAPIKey(keyID string) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        
        apiKey, exists := m.apiKeys[keyID]
        if !exists </span><span class="cov0" title="0">{
                return ErrAPIKeyNotFound
        }</span>
        
        <span class="cov0" title="0">apiKey.Active = false
        
        return nil</span>
}

// HasPermission checks if the auth context has a specific permission
func (m *Manager) HasPermission(ctx *AuthContext, permission string) bool <span class="cov10" title="3">{
        if ctx == nil || ctx.User == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // Admin role has all permissions
        <span class="cov10" title="3">if ctx.User.Role == RoleAdmin </span><span class="cov10" title="3">{
                return true
        }</span>
        
        // Check user permissions
        <span class="cov10" title="3">for _, perm := range ctx.User.Permissions </span><span class="cov10" title="3">{
                if perm == permission || perm == PermissionSystemAdmin </span><span class="cov10" title="3">{
                        return true
                }</span>
        }
        
        // Check API key permissions if using API key auth
        <span class="cov10" title="3">if ctx.Method == AuthMethodAPIKey &amp;&amp; ctx.APIKey != nil </span><span class="cov0" title="0">{
                for _, perm := range ctx.APIKey.Permissions </span><span class="cov0" title="0">{
                        if perm == permission || perm == PermissionSystemAdmin </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        
        <span class="cov10" title="3">return false</span>
}

// isTokenBlacklisted checks if a token is blacklisted
func (m *Manager) isTokenBlacklisted(tokenID string) bool <span class="cov10" title="3">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        
        expiry, exists := m.blacklistCache[tokenID]
        if !exists </span><span class="cov10" title="3">{
                return false
        }</span>
        
        // Check if blacklist entry has expired
        <span class="cov10" title="3">if time.Now().After(expiry) </span><span class="cov0" title="0">{
                delete(m.blacklistCache, tokenID)
                return false
        }</span>
        
        <span class="cov10" title="3">return true</span>
}

// Background cleanup routines
func (m *Manager) cleanupExpiredSessions() <span class="cov10" title="3">{
        ticker := time.NewTicker(30 * time.Minute)
        defer ticker.Stop()
        
        for </span><span class="cov10" title="3">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        m.mu.Lock()
                        now := time.Now()
                        for id, session := range m.sessions </span><span class="cov0" title="0">{
                                if now.After(session.ExpiresAt) </span><span class="cov0" title="0">{
                                        delete(m.sessions, id)
                                }</span>
                        }
                        <span class="cov0" title="0">m.mu.Unlock()</span>
                case &lt;-m.stopCleanup:<span class="cov10" title="3">
                        return</span>
                }
        }
}

func (m *Manager) cleanupBlacklist() <span class="cov10" title="3">{
        ticker := time.NewTicker(time.Hour)
        defer ticker.Stop()
        
        for </span><span class="cov10" title="3">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        m.mu.Lock()
                        now := time.Now()
                        for tokenID, expiry := range m.blacklistCache </span><span class="cov0" title="0">{
                                if now.After(expiry) </span><span class="cov0" title="0">{
                                        delete(m.blacklistCache, tokenID)
                                }</span>
                        }
                        <span class="cov0" title="0">m.mu.Unlock()</span>
                case &lt;-m.stopCleanup:<span class="cov10" title="3">
                        return</span>
                }
        }
}

// Utility functions
func generateID() string <span class="cov10" title="3">{
        bytes := make([]byte, 16)
        rand.Read(bytes)
        return hex.EncodeToString(bytes)
}</span>

func generateAPIKey() string <span class="cov10" title="3">{
        bytes := make([]byte, 32)
        rand.Read(bytes)
        return "ok_" + hex.EncodeToString(bytes)
}</span>

func hashAPIKey(key string) string <span class="cov10" title="3">{
        hash := sha256.Sum256([]byte(key))
        return hex.EncodeToString(hash[:])
}</pre>
		
		<pre class="file" id="file1" style="display: none">package auth

import (
        "fmt"
        "log"

        "github.com/gin-gonic/gin"
        "github.com/ollama/ollama-distributed/internal/config"
)

// Integration provides easy integration with the existing API server
type Integration struct {
        AuthManager       *Manager
        JWTManager        *JWTManager
        MiddlewareManager *MiddlewareManager
        Routes            *Routes
}

// NewIntegration creates a complete authentication integration
func NewIntegration(cfg *config.AuthConfig) (*Integration, error) <span class="cov0" title="0">{
        // Create auth manager
        authManager, err := NewManager(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create auth manager: %w", err)
        }</span>
        
        // Create JWT manager
        <span class="cov0" title="0">jwtManager, err := NewJWTManager(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create JWT manager: %w", err)
        }</span>
        
        // Create middleware manager
        <span class="cov0" title="0">middlewareManager := NewMiddlewareManager(authManager, jwtManager, cfg)
        
        // Create routes
        routes := NewRoutes(authManager, jwtManager, middlewareManager)
        
        return &amp;Integration{
                AuthManager:       authManager,
                JWTManager:        jwtManager,
                MiddlewareManager: middlewareManager,
                Routes:            routes,
        }, nil</span>
}

// SetupRouter configures a Gin router with authentication
func (i *Integration) SetupRouter() *gin.Engine <span class="cov0" title="0">{
        router := gin.New()
        
        // Register authentication routes
        i.Routes.RegisterRoutes(router)
        
        return router
}</span>

// ProtectAPIRoutes adds authentication to existing API routes
func (i *Integration) ProtectAPIRoutes(router *gin.Engine) <span class="cov0" title="0">{
        // Apply authentication middleware to protected API routes
        api := router.Group("/api/v1")
        api.Use(i.MiddlewareManager.AuthRequired())
        
        // Node management - requires node permissions
        nodeRoutes := api.Group("/nodes")
        nodeRoutes.Use(i.MiddlewareManager.RequireAnyPermission(
                PermissionNodeRead,
                PermissionNodeWrite,
                PermissionNodeAdmin,
        ))
        
        // Model management - requires model permissions
        modelRoutes := api.Group("/models")
        modelRoutes.Use(i.MiddlewareManager.RequireAnyPermission(
                PermissionModelRead,
                PermissionModelWrite,
                PermissionModelAdmin,
        ))
        
        // Cluster management - requires cluster permissions
        clusterRoutes := api.Group("/cluster")
        clusterRoutes.Use(i.MiddlewareManager.RequireAnyPermission(
                PermissionClusterRead,
                PermissionClusterWrite,
                PermissionClusterAdmin,
        ))
        
        // Inference - requires inference permissions
        inferenceRoutes := api.Group("/")
        inferenceRoutes.Use(i.MiddlewareManager.RequireAnyPermission(
                PermissionInferenceRead,
                PermissionInferenceWrite,
        ))
        
        // Metrics - requires metrics permissions
        metricsRoutes := api.Group("/metrics")
        metricsRoutes.Use(i.MiddlewareManager.RequirePermission(PermissionMetricsRead))
}</span>

// CreateServiceToken creates a service token for internal communication
func (i *Integration) CreateServiceToken(serviceID, serviceName string) (string, error) <span class="cov0" title="0">{
        permissions := []string{
                PermissionNodeRead,
                PermissionModelRead,
                PermissionInferenceWrite,
                PermissionClusterRead,
        }
        
        return i.JWTManager.GenerateServiceToken(serviceID, serviceName, permissions)
}</span>

// CreateAdminToken creates an admin token for administrative tasks
func (i *Integration) CreateAdminToken(adminID, adminName string) (string, error) <span class="cov0" title="0">{
        permissions := DefaultRolePermissions[RoleAdmin]
        return i.JWTManager.GenerateServiceToken(adminID, adminName, permissions)
}</span>

// Close gracefully shuts down the authentication system
func (i *Integration) Close() <span class="cov0" title="0">{
        i.AuthManager.Close()
}</span>

// Example integration with existing server
func ExampleIntegration() <span class="cov0" title="0">{
        // Load configuration
        cfg := &amp;config.AuthConfig{
                Enabled:     true,
                Method:      "jwt",
                TokenExpiry: 24 * 3600, // 24 hours in seconds
                SecretKey:   "your-secret-key",
                Issuer:      "ollama-distributed",
                Audience:    "ollama-api",
        }
        
        // Create authentication integration
        authIntegration, err := NewIntegration(cfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create auth integration: %v", err)
        }</span>
        <span class="cov0" title="0">defer authIntegration.Close()
        
        // Setup router with authentication
        router := gin.New()
        
        // Register authentication routes
        authIntegration.Routes.RegisterRoutes(router)
        
        // Protect existing API routes
        authIntegration.ProtectAPIRoutes(router)
        
        // Example: Add a protected endpoint
        protected := router.Group("/api/v1/protected")
        protected.Use(authIntegration.MiddlewareManager.AuthRequired())
        protected.Use(authIntegration.MiddlewareManager.RequirePermission(PermissionSystemAdmin))
        </span><span class="cov0" title="0">{
                protected.GET("/admin-only", func(c *gin.Context) </span><span class="cov0" title="0">{
                        user := GetCurrentUser(c)
                        c.JSON(200, gin.H{
                                "message": "This is an admin-only endpoint",
                                "user":    user.Username,
                                "role":    user.Role,
                        })
                }</span>)
        }
        
        // Example: Create a service token
        <span class="cov0" title="0">serviceToken, err := authIntegration.CreateServiceToken("node-1", "Ollama Node 1")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to create service token: %v", err)
        }</span> else<span class="cov0" title="0"> {
                log.Printf("Service token created: %s", serviceToken)
        }</span>
        
        // Start server
        <span class="cov0" title="0">log.Println("Starting server with authentication on :8080")
        router.Run(":8080")</span>
}

// MiddlewareHelpers provides helper functions for common middleware patterns
type MiddlewareHelpers struct {
        integration *Integration
}

// NewMiddlewareHelpers creates middleware helpers
func NewMiddlewareHelpers(integration *Integration) *MiddlewareHelpers <span class="cov0" title="0">{
        return &amp;MiddlewareHelpers{integration: integration}
}</span>

// RequireNodePermission creates middleware for node operations
func (mh *MiddlewareHelpers) RequireNodePermission(operation string) gin.HandlerFunc <span class="cov0" title="0">{
        switch operation </span>{
        case "read":<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionNodeRead)</span>
        case "write":<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionNodeWrite)</span>
        case "admin":<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionNodeAdmin)</span>
        default:<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionNodeRead)</span>
        }
}

// RequireModelPermission creates middleware for model operations
func (mh *MiddlewareHelpers) RequireModelPermission(operation string) gin.HandlerFunc <span class="cov0" title="0">{
        switch operation </span>{
        case "read":<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionModelRead)</span>
        case "write":<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionModelWrite)</span>
        case "admin":<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionModelAdmin)</span>
        default:<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionModelRead)</span>
        }
}

// RequireClusterPermission creates middleware for cluster operations
func (mh *MiddlewareHelpers) RequireClusterPermission(operation string) gin.HandlerFunc <span class="cov0" title="0">{
        switch operation </span>{
        case "read":<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionClusterRead)</span>
        case "write":<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionClusterWrite)</span>
        case "admin":<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionClusterAdmin)</span>
        default:<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionClusterRead)</span>
        }
}

// RequireInferencePermission creates middleware for inference operations
func (mh *MiddlewareHelpers) RequireInferencePermission(operation string) gin.HandlerFunc <span class="cov0" title="0">{
        switch operation </span>{
        case "read":<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionInferenceRead)</span>
        case "write":<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionInferenceWrite)</span>
        default:<span class="cov0" title="0">
                return mh.integration.MiddlewareManager.RequirePermission(PermissionInferenceRead)</span>
        }
}

// Example usage in existing API handlers
func ExampleAPIIntegration(authIntegration *Integration) <span class="cov0" title="0">{
        router := gin.New()
        helpers := NewMiddlewareHelpers(authIntegration)
        
        // Register auth routes
        authIntegration.Routes.RegisterRoutes(router)
        
        // Protected API routes
        api := router.Group("/api/v1")
        api.Use(authIntegration.MiddlewareManager.AuthRequired())
        
        // Node management with granular permissions
        nodes := api.Group("/nodes")
        </span><span class="cov0" title="0">{
                nodes.GET("", helpers.RequireNodePermission("read"), func(c *gin.Context) </span><span class="cov0" title="0">{
                        // Get nodes logic
                        c.JSON(200, gin.H{"nodes": []string{}})
                }</span>)
                
                <span class="cov0" title="0">nodes.POST("", helpers.RequireNodePermission("write"), func(c *gin.Context) </span><span class="cov0" title="0">{
                        // Create node logic
                        c.JSON(201, gin.H{"message": "Node created"})
                }</span>)
                
                <span class="cov0" title="0">nodes.DELETE("/:id", helpers.RequireNodePermission("admin"), func(c *gin.Context) </span><span class="cov0" title="0">{
                        // Delete node logic
                        c.JSON(200, gin.H{"message": "Node deleted"})
                }</span>)
        }
        
        // Model management with granular permissions
        <span class="cov0" title="0">models := api.Group("/models")
        </span><span class="cov0" title="0">{
                models.GET("", helpers.RequireModelPermission("read"), func(c *gin.Context) </span><span class="cov0" title="0">{
                        // Get models logic
                        c.JSON(200, gin.H{"models": []string{}})
                }</span>)
                
                <span class="cov0" title="0">models.POST("/:name/download", helpers.RequireModelPermission("write"), func(c *gin.Context) </span><span class="cov0" title="0">{
                        // Download model logic
                        c.JSON(200, gin.H{"message": "Download started"})
                }</span>)
                
                <span class="cov0" title="0">models.DELETE("/:name", helpers.RequireModelPermission("admin"), func(c *gin.Context) </span><span class="cov0" title="0">{
                        // Delete model logic
                        c.JSON(200, gin.H{"message": "Model deleted"})
                }</span>)
        }
        
        // Inference endpoints
        <span class="cov0" title="0">inference := api.Group("/")
        </span><span class="cov0" title="0">{
                inference.POST("/generate", helpers.RequireInferencePermission("write"), func(c *gin.Context) </span><span class="cov0" title="0">{
                        // Generate logic
                        user := GetCurrentUser(c)
                        c.JSON(200, gin.H{
                                "response": "Generated text",
                                "user":     user.Username,
                        })
                }</span>)
                
                <span class="cov0" title="0">inference.POST("/chat", helpers.RequireInferencePermission("write"), func(c *gin.Context) </span><span class="cov0" title="0">{
                        // Chat logic
                        c.JSON(200, gin.H{"response": "Chat response"})
                }</span>)
        }
        
        // Metrics (read-only)
        <span class="cov0" title="0">api.GET("/metrics", helpers.RequireInferencePermission("read"), func(c *gin.Context) </span><span class="cov0" title="0">{
                // Metrics logic
                c.JSON(200, gin.H{"metrics": map[string]interface{}{}})
        }</span>)
}</pre>
		
		<pre class="file" id="file2" style="display: none">package auth

import (
        "crypto/rand"
        "crypto/rsa"
        "fmt"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "github.com/ollama/ollama-distributed/internal/config"
)

// JWTManager handles JWT token operations with advanced features
type JWTManager struct {
        config     *config.AuthConfig
        privateKey *rsa.PrivateKey
        publicKey  *rsa.PublicKey
        
        // Token blacklist and refresh tokens
        blacklist    map[string]time.Time
        refreshTokens map[string]*RefreshToken
}

// RefreshToken represents a refresh token
type RefreshToken struct {
        ID        string    `json:"id"`
        UserID    string    `json:"user_id"`
        TokenHash string    `json:"token_hash"`
        ExpiresAt time.Time `json:"expires_at"`
        CreatedAt time.Time `json:"created_at"`
        Used      bool      `json:"used"`
}

// TokenPair represents an access token and refresh token pair
type TokenPair struct {
        AccessToken  string    `json:"access_token"`
        RefreshToken string    `json:"refresh_token"`
        ExpiresAt    time.Time `json:"expires_at"`
        TokenType    string    `json:"token_type"`
}

// NewJWTManager creates a new JWT manager
func NewJWTManager(cfg *config.AuthConfig) (*JWTManager, error) <span class="cov10" title="3">{
        // Generate RSA key pair for signing
        privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate RSA key: %w", err)
        }</span>
        
        <span class="cov10" title="3">return &amp;JWTManager{
                config:        cfg,
                privateKey:    privateKey,
                publicKey:     &amp;privateKey.PublicKey,
                blacklist:     make(map[string]time.Time),
                refreshTokens: make(map[string]*RefreshToken),
        }, nil</span>
}

// GenerateTokenPair generates an access token and refresh token pair
func (jm *JWTManager) GenerateTokenPair(user *User, sessionID string, metadata map[string]string) (*TokenPair, error) <span class="cov10" title="3">{
        now := time.Now()
        accessTokenExpiry := now.Add(jm.config.TokenExpiry)
        refreshTokenExpiry := now.Add(7 * 24 * time.Hour) // 7 days for refresh token
        
        // Create access token claims
        accessClaims := &amp;Claims{
                UserID:      user.ID,
                Username:    user.Username,
                Email:       user.Email,
                Role:        user.Role,
                Permissions: user.Permissions,
                SessionID:   sessionID,
                Metadata:    metadata,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(accessTokenExpiry),
                        IssuedAt:  jwt.NewNumericDate(now),
                        NotBefore: jwt.NewNumericDate(now),
                        Issuer:    jm.config.Issuer,
                        Subject:   user.ID,
                        ID:        generateID(),
                        Audience:  []string{jm.config.Audience},
                },
        }
        
        // Sign access token
        accessToken := jwt.NewWithClaims(jwt.SigningMethodRS256, accessClaims)
        accessTokenString, err := accessToken.SignedString(jm.privateKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to sign access token: %w", err)
        }</span>
        
        // Create refresh token
        <span class="cov10" title="3">refreshTokenID := generateID()
        refreshTokenString := generateAPIKey() // Reuse the secure random generation
        refreshTokenHash := hashAPIKey(refreshTokenString)
        
        refreshToken := &amp;RefreshToken{
                ID:        refreshTokenID,
                UserID:    user.ID,
                TokenHash: refreshTokenHash,
                ExpiresAt: refreshTokenExpiry,
                CreatedAt: now,
                Used:      false,
        }
        
        jm.refreshTokens[refreshTokenID] = refreshToken
        
        return &amp;TokenPair{
                AccessToken:  accessTokenString,
                RefreshToken: refreshTokenString,
                ExpiresAt:    accessTokenExpiry,
                TokenType:    "Bearer",
        }, nil</span>
}

// RefreshAccessToken generates a new access token using a refresh token
func (jm *JWTManager) RefreshAccessToken(refreshTokenString string, user *User) (*TokenPair, error) <span class="cov0" title="0">{
        refreshTokenHash := hashAPIKey(refreshTokenString)
        
        // Find the refresh token
        var refreshToken *RefreshToken
        for _, rt := range jm.refreshTokens </span><span class="cov0" title="0">{
                if rt.TokenHash == refreshTokenHash &amp;&amp; rt.UserID == user.ID &amp;&amp; !rt.Used </span><span class="cov0" title="0">{
                        if time.Now().Before(rt.ExpiresAt) </span><span class="cov0" title="0">{
                                refreshToken = rt
                                break</span>
                        }
                }
        }
        
        <span class="cov0" title="0">if refreshToken == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid or expired refresh token")
        }</span>
        
        // Mark the old refresh token as used
        <span class="cov0" title="0">refreshToken.Used = true
        
        // Generate new token pair
        return jm.GenerateTokenPair(user, "", nil)</span>
}

// ValidateToken validates a JWT access token
func (jm *JWTManager) ValidateToken(tokenString string) (*Claims, error) <span class="cov10" title="3">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov10" title="3">{
                if _, ok := token.Method.(*jwt.SigningMethodRSA); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov10" title="3">return jm.publicKey, nil</span>
        })
        
        <span class="cov10" title="3">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse token: %w", err)
        }</span>
        
        <span class="cov10" title="3">claims, ok := token.Claims.(*Claims)
        if !ok || !token.Valid </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid token claims")
        }</span>
        
        // Check if token is blacklisted
        <span class="cov10" title="3">if jm.isBlacklisted(claims.ID) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("token is blacklisted")
        }</span>
        
        <span class="cov10" title="3">return claims, nil</span>
}

// BlacklistToken adds a token to the blacklist
func (jm *JWTManager) BlacklistToken(tokenID string, expiry time.Time) <span class="cov0" title="0">{
        jm.blacklist[tokenID] = expiry
}</span>

// RevokeRefreshToken revokes a refresh token
func (jm *JWTManager) RevokeRefreshToken(refreshTokenString, userID string) error <span class="cov0" title="0">{
        refreshTokenHash := hashAPIKey(refreshTokenString)
        
        for _, rt := range jm.refreshTokens </span><span class="cov0" title="0">{
                if rt.TokenHash == refreshTokenHash &amp;&amp; rt.UserID == userID </span><span class="cov0" title="0">{
                        rt.Used = true
                        return nil
                }</span>
        }
        
        <span class="cov0" title="0">return fmt.Errorf("refresh token not found")</span>
}

// RevokeAllUserTokens revokes all tokens for a user
func (jm *JWTManager) RevokeAllUserTokens(userID string) <span class="cov0" title="0">{
        // Mark all refresh tokens as used
        for _, rt := range jm.refreshTokens </span><span class="cov0" title="0">{
                if rt.UserID == userID </span><span class="cov0" title="0">{
                        rt.Used = true
                }</span>
        }
}

// CleanupExpiredTokens removes expired tokens from memory
func (jm *JWTManager) CleanupExpiredTokens() <span class="cov0" title="0">{
        now := time.Now()
        
        // Clean up blacklist
        for tokenID, expiry := range jm.blacklist </span><span class="cov0" title="0">{
                if now.After(expiry) </span><span class="cov0" title="0">{
                        delete(jm.blacklist, tokenID)
                }</span>
        }
        
        // Clean up refresh tokens
        <span class="cov0" title="0">for id, rt := range jm.refreshTokens </span><span class="cov0" title="0">{
                if now.After(rt.ExpiresAt) || rt.Used </span><span class="cov0" title="0">{
                        delete(jm.refreshTokens, id)
                }</span>
        }
}

// GetTokenClaims extracts claims from a token without validating it (useful for expired tokens)
func (jm *JWTManager) GetTokenClaims(tokenString string) (*Claims, error) <span class="cov0" title="0">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                return jm.publicKey, nil
        }</span>, jwt.WithoutClaimsValidation())
        
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse token: %w", err)
        }</span>
        
        <span class="cov0" title="0">claims, ok := token.Claims.(*Claims)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid token claims")
        }</span>
        
        <span class="cov0" title="0">return claims, nil</span>
}

// GenerateServiceToken generates a long-lived token for service-to-service communication
func (jm *JWTManager) GenerateServiceToken(serviceID, serviceName string, permissions []string) (string, error) <span class="cov10" title="3">{
        now := time.Now()
        expiry := now.Add(365 * 24 * time.Hour) // 1 year
        
        claims := &amp;Claims{
                UserID:      serviceID,
                Username:    serviceName,
                Role:        RoleService,
                Permissions: permissions,
                Metadata: map[string]string{
                        "token_type": "service",
                },
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(expiry),
                        IssuedAt:  jwt.NewNumericDate(now),
                        NotBefore: jwt.NewNumericDate(now),
                        Issuer:    jm.config.Issuer,
                        Subject:   serviceID,
                        ID:        generateID(),
                        Audience:  []string{jm.config.Audience},
                },
        }
        
        token := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
        return token.SignedString(jm.privateKey)
}</span>

// ValidateServiceToken validates a service token
func (jm *JWTManager) ValidateServiceToken(tokenString string) (*Claims, error) <span class="cov10" title="3">{
        claims, err := jm.ValidateToken(tokenString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // Verify this is a service token
        <span class="cov10" title="3">if claims.Metadata["token_type"] != "service" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not a service token")
        }</span>
        
        <span class="cov10" title="3">return claims, nil</span>
}

// CreateShortLivedToken creates a token with custom expiry (for specific operations)
func (jm *JWTManager) CreateShortLivedToken(user *User, duration time.Duration, purpose string) (string, error) <span class="cov0" title="0">{
        now := time.Now()
        expiry := now.Add(duration)
        
        claims := &amp;Claims{
                UserID:      user.ID,
                Username:    user.Username,
                Email:       user.Email,
                Role:        user.Role,
                Permissions: user.Permissions,
                Metadata: map[string]string{
                        "token_type": "short_lived",
                        "purpose":    purpose,
                },
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(expiry),
                        IssuedAt:  jwt.NewNumericDate(now),
                        NotBefore: jwt.NewNumericDate(now),
                        Issuer:    jm.config.Issuer,
                        Subject:   user.ID,
                        ID:        generateID(),
                        Audience:  []string{jm.config.Audience},
                },
        }
        
        token := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
        return token.SignedString(jm.privateKey)
}</span>

// GetPublicKey returns the public key for token verification by other services
func (jm *JWTManager) GetPublicKey() *rsa.PublicKey <span class="cov0" title="0">{
        return jm.publicKey
}</span>

// GetTokenStats returns statistics about tokens
func (jm *JWTManager) GetTokenStats() map[string]interface{} <span class="cov0" title="0">{
        activeRefreshTokens := 0
        expiredRefreshTokens := 0
        now := time.Now()
        
        for _, rt := range jm.refreshTokens </span><span class="cov0" title="0">{
                if rt.Used || now.After(rt.ExpiresAt) </span><span class="cov0" title="0">{
                        expiredRefreshTokens++
                }</span> else<span class="cov0" title="0"> {
                        activeRefreshTokens++
                }</span>
        }
        
        <span class="cov0" title="0">return map[string]interface{}{
                "active_refresh_tokens":  activeRefreshTokens,
                "expired_refresh_tokens": expiredRefreshTokens,
                "blacklisted_tokens":     len(jm.blacklist),
                "total_refresh_tokens":   len(jm.refreshTokens),
        }</span>
}

// isBlacklisted checks if a token ID is blacklisted
func (jm *JWTManager) isBlacklisted(tokenID string) bool <span class="cov10" title="3">{
        expiry, exists := jm.blacklist[tokenID]
        if !exists </span><span class="cov10" title="3">{
                return false
        }</span>
        
        <span class="cov0" title="0">if time.Now().After(expiry) </span><span class="cov0" title="0">{
                delete(jm.blacklist, tokenID)
                return false
        }</span>
        
        <span class="cov0" title="0">return true</span>
}</pre>
		
		<pre class="file" id="file3" style="display: none">package auth

import (
        "net/http"
        "strings"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/ollama/ollama-distributed/internal/config"
)

// MiddlewareManager handles HTTP middleware for authentication and authorization
type MiddlewareManager struct {
        authManager *Manager
        jwtManager  *JWTManager
        config      *config.AuthConfig
}

// NewMiddlewareManager creates a new middleware manager
func NewMiddlewareManager(authManager *Manager, jwtManager *JWTManager, config *config.AuthConfig) *MiddlewareManager <span class="cov0" title="0">{
        return &amp;MiddlewareManager{
                authManager: authManager,
                jwtManager:  jwtManager,
                config:      config,
        }
}</span>

// AuthRequired middleware that requires authentication
func (mm *MiddlewareManager) AuthRequired() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Skip auth if disabled
                if !mm.config.Enabled </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>
                
                // Skip auth for certain paths
                <span class="cov0" title="0">if mm.shouldSkipAuth(c.Request.URL.Path, c.Request.Method) </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>
                
                // Try to authenticate
                <span class="cov0" title="0">authCtx, err := mm.authenticate(c)
                if err != nil </span><span class="cov0" title="0">{
                        mm.handleAuthError(c, err)
                        return
                }</span>
                
                // Store auth context
                <span class="cov0" title="0">mm.setAuthContext(c, authCtx)
                c.Next()</span>
        }
}

// RequirePermission middleware that requires specific permissions
func (mm *MiddlewareManager) RequirePermission(permission string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                authCtx := mm.getAuthContext(c)
                if authCtx == nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
                        c.Abort()
                        return
                }</span>
                
                <span class="cov0" title="0">if !mm.authManager.HasPermission(authCtx, permission) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, gin.H{
                                "error": "Insufficient permissions",
                                "required_permission": permission,
                        })
                        c.Abort()
                        return
                }</span>
                
                <span class="cov0" title="0">c.Next()</span>
        }
}

// RequireRole middleware that requires a specific role
func (mm *MiddlewareManager) RequireRole(role string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                authCtx := mm.getAuthContext(c)
                if authCtx == nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
                        c.Abort()
                        return
                }</span>
                
                <span class="cov0" title="0">if authCtx.User.Role != role &amp;&amp; authCtx.User.Role != RoleAdmin </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, gin.H{
                                "error": "Insufficient role",
                                "required_role": role,
                                "user_role": authCtx.User.Role,
                        })
                        c.Abort()
                        return
                }</span>
                
                <span class="cov0" title="0">c.Next()</span>
        }
}

// RequireAnyRole middleware that requires any of the specified roles
func (mm *MiddlewareManager) RequireAnyRole(roles ...string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                authCtx := mm.getAuthContext(c)
                if authCtx == nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
                        c.Abort()
                        return
                }</span>
                
                // Admin always has access
                <span class="cov0" title="0">if authCtx.User.Role == RoleAdmin </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>
                
                // Check if user has any of the required roles
                <span class="cov0" title="0">hasRole := false
                for _, role := range roles </span><span class="cov0" title="0">{
                        if authCtx.User.Role == role </span><span class="cov0" title="0">{
                                hasRole = true
                                break</span>
                        }
                }
                
                <span class="cov0" title="0">if !hasRole </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, gin.H{
                                "error": "Insufficient role",
                                "required_roles": roles,
                                "user_role": authCtx.User.Role,
                        })
                        c.Abort()
                        return
                }</span>
                
                <span class="cov0" title="0">c.Next()</span>
        }
}

// RequireAnyPermission middleware that requires any of the specified permissions
func (mm *MiddlewareManager) RequireAnyPermission(permissions ...string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                authCtx := mm.getAuthContext(c)
                if authCtx == nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
                        c.Abort()
                        return
                }</span>
                
                // Check if user has any of the required permissions
                <span class="cov0" title="0">hasPermission := false
                for _, permission := range permissions </span><span class="cov0" title="0">{
                        if mm.authManager.HasPermission(authCtx, permission) </span><span class="cov0" title="0">{
                                hasPermission = true
                                break</span>
                        }
                }
                
                <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, gin.H{
                                "error": "Insufficient permissions",
                                "required_permissions": permissions,
                        })
                        c.Abort()
                        return
                }</span>
                
                <span class="cov0" title="0">c.Next()</span>
        }
}

// Optional middleware that attempts authentication but doesn't require it
func (mm *MiddlewareManager) Optional() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                if !mm.config.Enabled </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>
                
                // Try to authenticate but don't fail if unsuccessful
                <span class="cov0" title="0">authCtx, _ := mm.authenticate(c)
                if authCtx != nil </span><span class="cov0" title="0">{
                        mm.setAuthContext(c, authCtx)
                }</span>
                
                <span class="cov0" title="0">c.Next()</span>
        }
}

// RateLimit middleware for API rate limiting
func (mm *MiddlewareManager) RateLimit() gin.HandlerFunc <span class="cov0" title="0">{
        // This is a simplified rate limiter
        // In production, use a proper rate limiting library like tollbooth or redis-based limiter
        requestCounts := make(map[string]map[int64]int)
        
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Get client identifier (IP or user ID if authenticated)
                clientID := c.ClientIP()
                if authCtx := mm.getAuthContext(c); authCtx != nil </span><span class="cov0" title="0">{
                        clientID = authCtx.User.ID
                }</span>
                
                // Current minute window
                <span class="cov0" title="0">currentMinute := time.Now().Unix() / 60
                
                if requestCounts[clientID] == nil </span><span class="cov0" title="0">{
                        requestCounts[clientID] = make(map[int64]int)
                }</span>
                
                // Clean old entries
                <span class="cov0" title="0">for minute := range requestCounts[clientID] </span><span class="cov0" title="0">{
                        if currentMinute-minute &gt; 5 </span><span class="cov0" title="0">{ // Keep last 5 minutes
                                delete(requestCounts[clientID], minute)
                        }</span>
                }
                
                // Count requests in current minute
                <span class="cov0" title="0">requestCounts[clientID][currentMinute]++
                
                // Check limit (100 requests per minute)
                if requestCounts[clientID][currentMinute] &gt; 100 </span><span class="cov0" title="0">{
                        c.JSON(http.StatusTooManyRequests, gin.H{
                                "error": "Rate limit exceeded",
                                "retry_after": 60,
                        })
                        c.Abort()
                        return
                }</span>
                
                <span class="cov0" title="0">c.Header("X-RateLimit-Limit", "100")
                c.Header("X-RateLimit-Remaining", string(rune(100-requestCounts[clientID][currentMinute])))
                c.Header("X-RateLimit-Reset", string(rune((currentMinute+1)*60)))
                
                c.Next()</span>
        }
}

// CORS middleware with authentication-aware settings
func (mm *MiddlewareManager) CORS() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                origin := c.Request.Header.Get("Origin")
                
                // Default allowed origins
                allowedOrigins := []string{"http://localhost:8080", "https://localhost:8080"}
                
                // Check if origin is allowed
                allowed := false
                for _, allowedOrigin := range allowedOrigins </span><span class="cov0" title="0">{
                        if origin == allowedOrigin </span><span class="cov0" title="0">{
                                allowed = true
                                break</span>
                        }
                }
                
                <span class="cov0" title="0">if allowed </span><span class="cov0" title="0">{
                        c.Header("Access-Control-Allow-Origin", origin)
                }</span>
                
                <span class="cov0" title="0">c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                c.Header("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Requested-With")
                c.Header("Access-Control-Allow-Credentials", "true")
                c.Header("Access-Control-Max-Age", "3600")
                
                if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(http.StatusNoContent)
                        return
                }</span>
                
                <span class="cov0" title="0">c.Next()</span>
        }
}

// SecurityHeaders middleware that adds security headers
func (mm *MiddlewareManager) SecurityHeaders() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Header("X-Content-Type-Options", "nosniff")
                c.Header("X-Frame-Options", "DENY")
                c.Header("X-XSS-Protection", "1; mode=block")
                c.Header("Referrer-Policy", "strict-origin-when-cross-origin")
                c.Header("Content-Security-Policy", "default-src 'self'")
                c.Header("Strict-Transport-Security", "max-age=31536000; includeSubDomains")
                
                c.Next()
        }</span>
}

// AuditLog middleware that logs authentication events
func (mm *MiddlewareManager) AuditLog() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()
                
                // Process request
                c.Next()
                
                // Log after request completion
                duration := time.Since(start)
                authCtx := mm.getAuthContext(c)
                
                logData := map[string]interface{}{
                        "timestamp":    start.Unix(),
                        "method":       c.Request.Method,
                        "path":         c.Request.URL.Path,
                        "status":       c.Writer.Status(),
                        "duration_ms":  duration.Milliseconds(),
                        "ip":           c.ClientIP(),
                        "user_agent":   c.Request.Header.Get("User-Agent"),
                }
                
                if authCtx != nil </span><span class="cov0" title="0">{
                        logData["user_id"] = authCtx.User.ID
                        logData["username"] = authCtx.User.Username
                        logData["auth_method"] = string(authCtx.Method)
                        if authCtx.Session != nil </span><span class="cov0" title="0">{
                                logData["session_id"] = authCtx.Session.ID
                        }</span>
                        <span class="cov0" title="0">if authCtx.APIKey != nil </span><span class="cov0" title="0">{
                                logData["api_key_id"] = authCtx.APIKey.ID
                        }</span>
                }
                
                // In production, send this to a proper logging system
                // fmt.Printf("AUDIT: %+v\n", logData)
        }
}

// Helper methods

func (mm *MiddlewareManager) authenticate(c *gin.Context) (*AuthContext, error) <span class="cov0" title="0">{
        // Try API key authentication first
        if apiKey := mm.extractAPIKey(c); apiKey != "" </span><span class="cov0" title="0">{
                return mm.authManager.ValidateAPIKey(apiKey)
        }</span>
        
        // Try JWT token authentication
        <span class="cov0" title="0">if token := mm.extractBearerToken(c); token != "" </span><span class="cov0" title="0">{
                return mm.authManager.ValidateToken(token)
        }</span>
        
        <span class="cov0" title="0">return nil, ErrInvalidCredentials</span>
}

func (mm *MiddlewareManager) extractBearerToken(c *gin.Context) string <span class="cov0" title="0">{
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        
        <span class="cov0" title="0">parts := strings.SplitN(authHeader, " ", 2)
        if len(parts) != 2 || strings.ToLower(parts[0]) != "bearer" </span><span class="cov0" title="0">{
                return ""
        }</span>
        
        <span class="cov0" title="0">return parts[1]</span>
}

func (mm *MiddlewareManager) extractAPIKey(c *gin.Context) string <span class="cov0" title="0">{
        // Check Authorization header with API key
        authHeader := c.GetHeader("Authorization")
        if strings.HasPrefix(strings.ToLower(authHeader), "apikey ") </span><span class="cov0" title="0">{
                return strings.TrimPrefix(authHeader, "ApiKey ")
        }</span>
        
        // Check X-API-Key header
        <span class="cov0" title="0">if apiKey := c.GetHeader("X-API-Key"); apiKey != "" </span><span class="cov0" title="0">{
                return apiKey
        }</span>
        
        // Check query parameter
        <span class="cov0" title="0">if apiKey := c.Query("api_key"); apiKey != "" </span><span class="cov0" title="0">{
                return apiKey
        }</span>
        
        <span class="cov0" title="0">return ""</span>
}

func (mm *MiddlewareManager) shouldSkipAuth(path, method string) bool <span class="cov0" title="0">{
        // Public endpoints that don't require authentication
        publicPaths := []string{
                "/api/v1/health",
                "/api/v1/login",
                "/api/v1/register",
                "/metrics",
                "/favicon.ico",
        }
        
        for _, publicPath := range publicPaths </span><span class="cov0" title="0">{
                if path == publicPath </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">if strings.HasPrefix(path, "/static/") </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        
        // Always allow OPTIONS requests for CORS
        <span class="cov0" title="0">if method == "OPTIONS" </span><span class="cov0" title="0">{
                return true
        }</span>
        
        <span class="cov0" title="0">return false</span>
}

func (mm *MiddlewareManager) handleAuthError(c *gin.Context, err error) <span class="cov0" title="0">{
        var status int
        var response gin.H
        
        switch err.(type) </span>{
        case AuthError:<span class="cov0" title="0">
                authErr := err.(AuthError)
                switch authErr.Code </span>{
                case "TOKEN_EXPIRED":<span class="cov0" title="0">
                        status = http.StatusUnauthorized</span>
                case "TOKEN_INVALID":<span class="cov0" title="0">
                        status = http.StatusUnauthorized</span>
                case "TOKEN_BLACKLISTED":<span class="cov0" title="0">
                        status = http.StatusUnauthorized</span>
                case "INSUFFICIENT_PERMISSIONS":<span class="cov0" title="0">
                        status = http.StatusForbidden</span>
                case "USER_NOT_FOUND":<span class="cov0" title="0">
                        status = http.StatusUnauthorized</span>
                case "USER_INACTIVE":<span class="cov0" title="0">
                        status = http.StatusUnauthorized</span>
                default:<span class="cov0" title="0">
                        status = http.StatusUnauthorized</span>
                }
                <span class="cov0" title="0">response = gin.H{
                        "error": authErr.Message,
                        "code":  authErr.Code,
                }</span>
        default:<span class="cov0" title="0">
                status = http.StatusUnauthorized
                response = gin.H{
                        "error": "Authentication required",
                }</span>
        }
        
        <span class="cov0" title="0">c.JSON(status, response)
        c.Abort()</span>
}

func (mm *MiddlewareManager) setAuthContext(c *gin.Context, authCtx *AuthContext) <span class="cov0" title="0">{
        c.Set("auth_context", authCtx)
        c.Set("user", authCtx.User)
        c.Set("user_id", authCtx.User.ID)
        c.Set("username", authCtx.User.Username)
        c.Set("role", authCtx.User.Role)
        c.Set("permissions", authCtx.User.Permissions)
        if authCtx.Session != nil </span><span class="cov0" title="0">{
                c.Set("session", authCtx.Session)
                c.Set("session_id", authCtx.Session.ID)
        }</span>
        <span class="cov0" title="0">if authCtx.APIKey != nil </span><span class="cov0" title="0">{
                c.Set("api_key", authCtx.APIKey)
                c.Set("api_key_id", authCtx.APIKey.ID)
        }</span>
}

func (mm *MiddlewareManager) getAuthContext(c *gin.Context) *AuthContext <span class="cov0" title="0">{
        if authCtx, exists := c.Get("auth_context"); exists </span><span class="cov0" title="0">{
                if ctx, ok := authCtx.(*AuthContext); ok </span><span class="cov0" title="0">{
                        return ctx
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// GetCurrentUser helper function to get current user from context
func GetCurrentUser(c *gin.Context) *User <span class="cov0" title="0">{
        if user, exists := c.Get("user"); exists </span><span class="cov0" title="0">{
                if u, ok := user.(*User); ok </span><span class="cov0" title="0">{
                        return u
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// GetCurrentUserID helper function to get current user ID from context
func GetCurrentUserID(c *gin.Context) string <span class="cov0" title="0">{
        if userID, exists := c.Get("user_id"); exists </span><span class="cov0" title="0">{
                if id, ok := userID.(string); ok </span><span class="cov0" title="0">{
                        return id
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// HasPermission helper function to check permissions in handlers
func HasPermission(c *gin.Context, permission string) bool <span class="cov0" title="0">{
        if permissions, exists := c.Get("permissions"); exists </span><span class="cov0" title="0">{
                if perms, ok := permissions.([]string); ok </span><span class="cov0" title="0">{
                        for _, perm := range perms </span><span class="cov0" title="0">{
                                if perm == permission || perm == PermissionSystemAdmin </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return false</span>
}</pre>
		
		<pre class="file" id="file4" style="display: none">package auth

import (
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
)

// Routes handles authentication-related HTTP routes
type Routes struct {
        authManager       *Manager
        jwtManager        *JWTManager
        middlewareManager *MiddlewareManager
}

// NewRoutes creates a new routes handler
func NewRoutes(authManager *Manager, jwtManager *JWTManager, middlewareManager *MiddlewareManager) *Routes <span class="cov0" title="0">{
        return &amp;Routes{
                authManager:       authManager,
                jwtManager:        jwtManager,
                middlewareManager: middlewareManager,
        }
}</span>

// RegisterRoutes registers authentication routes with the Gin router
func (r *Routes) RegisterRoutes(router *gin.Engine) <span class="cov0" title="0">{
        // Apply global middleware
        router.Use(r.middlewareManager.CORS())
        router.Use(r.middlewareManager.SecurityHeaders())
        router.Use(r.middlewareManager.RateLimit())
        router.Use(r.middlewareManager.AuditLog())
        
        // Public routes (no authentication required)
        public := router.Group("/api/v1")
        </span><span class="cov0" title="0">{
                public.POST("/login", r.login)
                public.POST("/register", r.register)
                public.POST("/refresh", r.refreshToken)
                public.GET("/health", r.health)
        }</span>
        
        // Protected routes (authentication required)
        <span class="cov0" title="0">protected := router.Group("/api/v1")
        protected.Use(r.middlewareManager.AuthRequired())
        </span><span class="cov0" title="0">{
                // User management
                user := protected.Group("/user")
                </span><span class="cov0" title="0">{
                        user.GET("/profile", r.getProfile)
                        user.PUT("/profile", r.updateProfile)
                        user.POST("/change-password", r.changePassword)
                        user.POST("/logout", r.logout)
                        user.GET("/sessions", r.getSessions)
                        user.DELETE("/sessions/:session_id", r.revokeSession)
                }</span>
                
                // API key management
                <span class="cov0" title="0">apiKeys := protected.Group("/api-keys")
                </span><span class="cov0" title="0">{
                        apiKeys.GET("", r.listAPIKeys)
                        apiKeys.POST("", r.createAPIKey)
                        apiKeys.DELETE("/:key_id", r.revokeAPIKey)
                }</span>
                
                // Admin routes
                <span class="cov0" title="0">admin := protected.Group("/admin")
                admin.Use(r.middlewareManager.RequireRole(RoleAdmin))
                </span><span class="cov0" title="0">{
                        admin.GET("/users", r.listUsers)
                        admin.POST("/users", r.createUser)
                        admin.GET("/users/:user_id", r.getUser)
                        admin.PUT("/users/:user_id", r.updateUser)
                        admin.DELETE("/users/:user_id", r.deleteUser)
                        admin.POST("/users/:user_id/reset-password", r.resetUserPassword)
                        admin.GET("/stats", r.getAuthStats)
                }</span>
        }
}

// Authentication handlers

func (r *Routes) login(c *gin.Context) <span class="cov0" title="0">{
        var req LoginRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>
        
        // Get client metadata
        <span class="cov0" title="0">metadata := map[string]string{
                "ip_address": c.ClientIP(),
                "user_agent": c.Request.Header.Get("User-Agent"),
        }
        for k, v := range req.Metadata </span><span class="cov0" title="0">{
                metadata[k] = v
        }</span>
        
        // Authenticate user
        <span class="cov0" title="0">authCtx, err := r.authManager.Authenticate(req.Username, req.Password, metadata)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
                return
        }</span>
        
        <span class="cov0" title="0">response := LoginResponse{
                Token:     authCtx.TokenString,
                ExpiresAt: authCtx.Session.ExpiresAt,
                User:      authCtx.User,
                SessionID: authCtx.Session.ID,
        }
        
        c.JSON(http.StatusOK, response)</span>
}

func (r *Routes) register(c *gin.Context) <span class="cov0" title="0">{
        var req CreateUserRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>
        
        // Default role for registration
        <span class="cov0" title="0">if req.Role == "" </span><span class="cov0" title="0">{
                req.Role = RoleUser
        }</span>
        
        // Only allow certain roles for self-registration
        <span class="cov0" title="0">allowedRoles := []string{RoleUser, RoleReadOnly}
        roleAllowed := false
        for _, role := range allowedRoles </span><span class="cov0" title="0">{
                if req.Role == role </span><span class="cov0" title="0">{
                        roleAllowed = true
                        break</span>
                }
        }
        
        <span class="cov0" title="0">if !roleAllowed </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid role for registration"})
                return
        }</span>
        
        <span class="cov0" title="0">user, err := r.authManager.CreateUser(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        
        // Remove sensitive data from response
        <span class="cov0" title="0">user.Metadata = map[string]string{}
        
        c.JSON(http.StatusCreated, gin.H{"user": user})</span>
}

func (r *Routes) refreshToken(c *gin.Context) <span class="cov0" title="0">{
        var req RefreshRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>
        
        // Get user from token (even if expired)
        <span class="cov0" title="0">_, err := r.jwtManager.GetTokenClaims(req.Token)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token"})
                return
        }</span>
        
        // This is a simplified implementation
        // In a real system, you'd use a separate refresh token
        <span class="cov0" title="0">c.JSON(http.StatusNotImplemented, gin.H{"error": "Refresh token functionality not implemented"})</span>
}

func (r *Routes) health(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "status":    "healthy",
                "service":   "auth",
                "timestamp": time.Now().Unix(),
        })
}</span>

// User management handlers

func (r *Routes) getProfile(c *gin.Context) <span class="cov0" title="0">{
        user := GetCurrentUser(c)
        if user == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "User not found"})
                return
        }</span>
        
        // Remove sensitive data
        <span class="cov0" title="0">user.Metadata = map[string]string{}
        
        c.JSON(http.StatusOK, gin.H{"user": user})</span>
}

func (r *Routes) updateProfile(c *gin.Context) <span class="cov0" title="0">{
        user := GetCurrentUser(c)
        if user == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "User not found"})
                return
        }</span>
        
        <span class="cov0" title="0">var req UpdateUserRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>
        
        // Update allowed fields
        <span class="cov0" title="0">if req.Email != nil </span><span class="cov0" title="0">{
                user.Email = *req.Email
        }</span>
        <span class="cov0" title="0">if req.Metadata != nil </span><span class="cov0" title="0">{
                for k, v := range req.Metadata </span><span class="cov0" title="0">{
                        if k != "password_hash" </span><span class="cov0" title="0">{ // Prevent password hash modification
                                user.Metadata[k] = v
                        }</span>
                }
        }
        
        <span class="cov0" title="0">user.UpdatedAt = time.Now()
        
        // Remove sensitive data from response
        user.Metadata = map[string]string{}
        
        c.JSON(http.StatusOK, gin.H{"user": user})</span>
}

func (r *Routes) changePassword(c *gin.Context) <span class="cov0" title="0">{
        user := GetCurrentUser(c)
        if user == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "User not found"})
                return
        }</span>
        
        <span class="cov0" title="0">var req ChangePasswordRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>
        
        // This would need to be implemented in the auth manager
        <span class="cov0" title="0">c.JSON(http.StatusNotImplemented, gin.H{"error": "Password change not implemented"})</span>
}

func (r *Routes) logout(c *gin.Context) <span class="cov0" title="0">{
        authCtx := r.middlewareManager.getAuthContext(c)
        if authCtx == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "No active session"})
                return
        }</span>
        
        // Revoke session if it exists
        <span class="cov0" title="0">if authCtx.Session != nil </span><span class="cov0" title="0">{
                r.authManager.RevokeSession(authCtx.Session.ID)
        }</span>
        
        // Blacklist the token
        <span class="cov0" title="0">if authCtx.Claims != nil </span><span class="cov0" title="0">{
                r.authManager.RevokeToken(authCtx.Claims.ID, authCtx.Claims.ExpiresAt.Time)
        }</span>
        
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Logged out successfully"})</span>
}

func (r *Routes) getSessions(c *gin.Context) <span class="cov0" title="0">{
        // This would need to be implemented to return user sessions
        c.JSON(http.StatusNotImplemented, gin.H{"error": "Session listing not implemented"})
}</span>

func (r *Routes) revokeSession(c *gin.Context) <span class="cov0" title="0">{
        sessionID := c.Param("session_id")
        
        err := r.authManager.RevokeSession(sessionID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>
        
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Session revoked successfully"})</span>
}

// API key management handlers

func (r *Routes) listAPIKeys(c *gin.Context) <span class="cov0" title="0">{
        user := GetCurrentUser(c)
        if user == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "User not found"})
                return
        }</span>
        
        // Filter API keys to only show current user's keys
        <span class="cov0" title="0">var userAPIKeys []APIKey
        for _, apiKey := range user.APIKeys </span><span class="cov0" title="0">{
                // Remove the actual key value for security
                apiKey.Key = ""
                userAPIKeys = append(userAPIKeys, apiKey)
        }</span>
        
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"api_keys": userAPIKeys})</span>
}

func (r *Routes) createAPIKey(c *gin.Context) <span class="cov0" title="0">{
        user := GetCurrentUser(c)
        if user == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "User not found"})
                return
        }</span>
        
        <span class="cov0" title="0">var req CreateAPIKeyRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>
        
        <span class="cov0" title="0">apiKey, rawKey, err := r.authManager.CreateAPIKey(user.ID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        
        <span class="cov0" title="0">response := CreateAPIKeyResponse{
                APIKey: apiKey,
                Key:    rawKey,
        }
        
        // Remove the hashed key from the response
        response.APIKey.Key = ""
        
        c.JSON(http.StatusCreated, response)</span>
}

func (r *Routes) revokeAPIKey(c *gin.Context) <span class="cov0" title="0">{
        keyID := c.Param("key_id")
        
        err := r.authManager.RevokeAPIKey(keyID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>
        
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "API key revoked successfully"})</span>
}

// Admin handlers

func (r *Routes) listUsers(c *gin.Context) <span class="cov0" title="0">{
        // This would need to be implemented in the auth manager
        c.JSON(http.StatusNotImplemented, gin.H{"error": "User listing not implemented"})
}</span>

func (r *Routes) createUser(c *gin.Context) <span class="cov0" title="0">{
        var req CreateUserRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>
        
        <span class="cov0" title="0">user, err := r.authManager.CreateUser(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        
        // Remove sensitive data
        <span class="cov0" title="0">user.Metadata = map[string]string{}
        
        c.JSON(http.StatusCreated, gin.H{"user": user})</span>
}

func (r *Routes) getUser(c *gin.Context) <span class="cov0" title="0">{
        userID := c.Param("user_id")
        
        // This would need to be implemented in the auth manager
        c.JSON(http.StatusNotImplemented, gin.H{"error": "User retrieval not implemented", "user_id": userID})
}</span>

func (r *Routes) updateUser(c *gin.Context) <span class="cov0" title="0">{
        userID := c.Param("user_id")
        
        var req UpdateUserRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request format"})
                return
        }</span>
        
        // This would need to be implemented in the auth manager
        <span class="cov0" title="0">c.JSON(http.StatusNotImplemented, gin.H{"error": "User update not implemented", "user_id": userID})</span>
}

func (r *Routes) deleteUser(c *gin.Context) <span class="cov0" title="0">{
        userID := c.Param("user_id")
        
        // This would need to be implemented in the auth manager
        c.JSON(http.StatusNotImplemented, gin.H{"error": "User deletion not implemented", "user_id": userID})
}</span>

func (r *Routes) resetUserPassword(c *gin.Context) <span class="cov0" title="0">{
        userID := c.Param("user_id")
        
        // This would need to be implemented in the auth manager
        c.JSON(http.StatusNotImplemented, gin.H{"error": "Password reset not implemented", "user_id": userID})
}</span>

func (r *Routes) getAuthStats(c *gin.Context) <span class="cov0" title="0">{
        stats := r.jwtManager.GetTokenStats()
        
        // Add more stats from auth manager
        stats["timestamp"] = time.Now().Unix()
        
        c.JSON(http.StatusOK, gin.H{"stats": stats})
}</pre>
		
		<pre class="file" id="file5" style="display: none">package auth

import (
        "log"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/ollama/ollama-distributed/internal/config"
)

// ExampleServerWithAuth demonstrates how to integrate the authentication system
// with the existing Ollama distributed server
func ExampleServerWithAuth() <span class="cov0" title="0">{
        // Load main configuration
        cfg, err := config.Load("")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load config: %v", err)
        }</span>
        
        // Ensure auth is enabled
        <span class="cov0" title="0">if !cfg.Security.Auth.Enabled </span><span class="cov0" title="0">{
                log.Println("WARNING: Authentication is disabled. Enable it for production!")
                cfg.Security.Auth.Enabled = true
                cfg.Security.Auth.Method = "jwt"
                cfg.Security.Auth.TokenExpiry = 24 * time.Hour
                cfg.Security.Auth.SecretKey = "demo-secret-key-change-in-production"
                cfg.Security.Auth.Issuer = "ollama-distributed"
                cfg.Security.Auth.Audience = "ollama-api"
        }</span>
        
        // Create authentication integration
        <span class="cov0" title="0">authIntegration, err := NewIntegration(&amp;cfg.Security.Auth)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create auth integration: %v", err)
        }</span>
        <span class="cov0" title="0">defer authIntegration.Close()
        
        // Create Gin router
        router := gin.New()
        
        // Apply global middleware
        router.Use(gin.Logger())
        router.Use(gin.Recovery())
        router.Use(authIntegration.MiddlewareManager.SecurityHeaders())
        router.Use(authIntegration.MiddlewareManager.CORS())
        router.Use(authIntegration.MiddlewareManager.RateLimit())
        router.Use(authIntegration.MiddlewareManager.AuditLog())
        
        // Register authentication routes
        authIntegration.Routes.RegisterRoutes(router)
        
        // Setup protected API routes
        setupProtectedAPIRoutes(router, authIntegration)
        
        // Setup public routes
        setupPublicRoutes(router)
        
        // Start server
        log.Printf("Starting Ollama Distributed Server with Authentication on %s", cfg.API.Listen)
        if err := router.Run(cfg.API.Listen); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to start server: %v", err)
        }</span>
}

// setupProtectedAPIRoutes configures the protected API endpoints
func setupProtectedAPIRoutes(router *gin.Engine, authIntegration *Integration) <span class="cov0" title="0">{
        // Protected API routes
        api := router.Group("/api/v1")
        api.Use(authIntegration.MiddlewareManager.AuthRequired())
        
        // Create middleware helpers
        helpers := NewMiddlewareHelpers(authIntegration)
        
        // Node management endpoints
        setupNodeRoutes(api, helpers)
        
        // Model management endpoints
        setupModelRoutes(api, helpers)
        
        // Cluster management endpoints
        setupClusterRoutes(api, helpers)
        
        // Inference endpoints
        setupInferenceRoutes(api, helpers)
        
        // Monitoring endpoints
        setupMonitoringRoutes(api, helpers)
        
        // Distribution management endpoints
        setupDistributionRoutes(api, helpers)
}</span>

// setupNodeRoutes configures node management routes
func setupNodeRoutes(api *gin.RouterGroup, helpers *MiddlewareHelpers) <span class="cov0" title="0">{
        nodes := api.Group("/nodes")
        
        // List nodes - requires read permission
        nodes.GET("", helpers.RequireNodePermission("read"), func(c *gin.Context) </span><span class="cov0" title="0">{
                user := GetCurrentUser(c)
                log.Printf("User %s requested node list", user.Username)
                
                // Mock response - in real implementation, this would call the scheduler
                c.JSON(200, gin.H{
                        "nodes": []map[string]interface{}{
                                {
                                        "id":     "node-1",
                                        "status": "online",
                                        "cpu":    "50%",
                                        "memory": "60%",
                                },
                                {
                                        "id":     "node-2",
                                        "status": "online",
                                        "cpu":    "30%",
                                        "memory": "40%",
                                },
                        },
                        "total": 2,
                })
        }</span>)
        
        // Get specific node - requires read permission
        <span class="cov0" title="0">nodes.GET("/:id", helpers.RequireNodePermission("read"), func(c *gin.Context) </span><span class="cov0" title="0">{
                nodeID := c.Param("id")
                user := GetCurrentUser(c)
                log.Printf("User %s requested details for node %s", user.Username, nodeID)
                
                c.JSON(200, gin.H{
                        "node": map[string]interface{}{
                                "id":       nodeID,
                                "status":   "online",
                                "cpu":      "50%",
                                "memory":   "60%",
                                "models":   []string{"llama2", "codellama"},
                                "requests": 150,
                        },
                })
        }</span>)
        
        // Drain node - requires write permission
        <span class="cov0" title="0">nodes.POST("/:id/drain", helpers.RequireNodePermission("write"), func(c *gin.Context) </span><span class="cov0" title="0">{
                nodeID := c.Param("id")
                user := GetCurrentUser(c)
                log.Printf("User %s initiated drain for node %s", user.Username, nodeID)
                
                c.JSON(200, gin.H{
                        "message": "Node drain initiated",
                        "node_id": nodeID,
                        "status":  "draining",
                })
        }</span>)
        
        // Delete node - requires admin permission
        <span class="cov0" title="0">nodes.DELETE("/:id", helpers.RequireNodePermission("admin"), func(c *gin.Context) </span><span class="cov0" title="0">{
                nodeID := c.Param("id")
                user := GetCurrentUser(c)
                log.Printf("User %s deleted node %s", user.Username, nodeID)
                
                c.JSON(200, gin.H{
                        "message": "Node deleted successfully",
                        "node_id": nodeID,
                })
        }</span>)
}

// setupModelRoutes configures model management routes
func setupModelRoutes(api *gin.RouterGroup, helpers *MiddlewareHelpers) <span class="cov0" title="0">{
        models := api.Group("/models")
        
        // List models - requires read permission
        models.GET("", helpers.RequireModelPermission("read"), func(c *gin.Context) </span><span class="cov0" title="0">{
                user := GetCurrentUser(c)
                log.Printf("User %s requested model list", user.Username)
                
                c.JSON(200, gin.H{
                        "models": []map[string]interface{}{
                                {
                                        "name":      "llama2",
                                        "size":      "7B",
                                        "locations": []string{"node-1", "node-2"},
                                        "status":    "ready",
                                },
                                {
                                        "name":      "codellama",
                                        "size":      "13B",
                                        "locations": []string{"node-1"},
                                        "status":    "ready",
                                },
                        },
                })
        }</span>)
        
        // Download model - requires write permission
        <span class="cov0" title="0">models.POST("/:name/download", helpers.RequireModelPermission("write"), func(c *gin.Context) </span><span class="cov0" title="0">{
                modelName := c.Param("name")
                user := GetCurrentUser(c)
                log.Printf("User %s initiated download for model %s", user.Username, modelName)
                
                c.JSON(200, gin.H{
                        "message":    "Model download initiated",
                        "model_name": modelName,
                        "status":     "downloading",
                        "progress":   0,
                })
        }</span>)
        
        // Delete model - requires admin permission
        <span class="cov0" title="0">models.DELETE("/:name", helpers.RequireModelPermission("admin"), func(c *gin.Context) </span><span class="cov0" title="0">{
                modelName := c.Param("name")
                user := GetCurrentUser(c)
                log.Printf("User %s deleted model %s", user.Username, modelName)
                
                c.JSON(200, gin.H{
                        "message":    "Model deleted successfully",
                        "model_name": modelName,
                })
        }</span>)
}

// setupClusterRoutes configures cluster management routes
func setupClusterRoutes(api *gin.RouterGroup, helpers *MiddlewareHelpers) <span class="cov0" title="0">{
        cluster := api.Group("/cluster")
        
        // Get cluster status - requires read permission
        cluster.GET("/status", helpers.RequireClusterPermission("read"), func(c *gin.Context) </span><span class="cov0" title="0">{
                user := GetCurrentUser(c)
                log.Printf("User %s requested cluster status", user.Username)
                
                c.JSON(200, gin.H{
                        "status": "healthy",
                        "nodes":  2,
                        "leader": "node-1",
                        "peers":  1,
                })
        }</span>)
        
        // Join cluster - requires write permission
        <span class="cov0" title="0">cluster.POST("/join", helpers.RequireClusterPermission("write"), func(c *gin.Context) </span><span class="cov0" title="0">{
                var req map[string]interface{}
                c.ShouldBindJSON(&amp;req)
                
                user := GetCurrentUser(c)
                log.Printf("User %s initiated cluster join", user.Username)
                
                c.JSON(200, gin.H{
                        "message": "Node join initiated",
                })
        }</span>)
        
        // Leave cluster - requires admin permission
        <span class="cov0" title="0">cluster.POST("/leave", helpers.RequireClusterPermission("admin"), func(c *gin.Context) </span><span class="cov0" title="0">{
                user := GetCurrentUser(c)
                log.Printf("User %s initiated cluster leave", user.Username)
                
                c.JSON(200, gin.H{
                        "message": "Node leave initiated",
                })
        }</span>)
}

// setupInferenceRoutes configures inference routes
func setupInferenceRoutes(api *gin.RouterGroup, helpers *MiddlewareHelpers) <span class="cov0" title="0">{
        // Generate endpoint - requires write permission
        api.POST("/generate", helpers.RequireInferencePermission("write"), func(c *gin.Context) </span><span class="cov0" title="0">{
                var req map[string]interface{}
                c.ShouldBindJSON(&amp;req)
                
                user := GetCurrentUser(c)
                modelName := req["model"]
                log.Printf("User %s requested generation with model %v", user.Username, modelName)
                
                c.JSON(200, gin.H{
                        "response": "This is a generated response from the distributed Ollama system",
                        "model":    modelName,
                        "node_id":  "node-1",
                        "user":     user.Username,
                })
        }</span>)
        
        // Chat endpoint - requires write permission
        <span class="cov0" title="0">api.POST("/chat", helpers.RequireInferencePermission("write"), func(c *gin.Context) </span><span class="cov0" title="0">{
                var req map[string]interface{}
                c.ShouldBindJSON(&amp;req)
                
                user := GetCurrentUser(c)
                log.Printf("User %s initiated chat session", user.Username)
                
                c.JSON(200, gin.H{
                        "message": map[string]interface{}{
                                "role":    "assistant",
                                "content": "Hello! I'm your AI assistant powered by the distributed Ollama system.",
                        },
                        "user": user.Username,
                })
        }</span>)
        
        // Embeddings endpoint - requires write permission
        <span class="cov0" title="0">api.POST("/embeddings", helpers.RequireInferencePermission("write"), func(c *gin.Context) </span><span class="cov0" title="0">{
                var req map[string]interface{}
                c.ShouldBindJSON(&amp;req)
                
                user := GetCurrentUser(c)
                log.Printf("User %s requested embeddings", user.Username)
                
                c.JSON(200, gin.H{
                        "embeddings": []float64{0.1, 0.2, 0.3, 0.4, 0.5},
                        "model":      req["model"],
                        "user":       user.Username,
                })
        }</span>)
}

// setupMonitoringRoutes configures monitoring routes
func setupMonitoringRoutes(api *gin.RouterGroup, helpers *MiddlewareHelpers) <span class="cov0" title="0">{
        // Metrics endpoint - requires read permission
        api.GET("/metrics", helpers.RequireInferencePermission("read"), func(c *gin.Context) </span><span class="cov0" title="0">{
                user := GetCurrentUser(c)
                log.Printf("User %s requested metrics", user.Username)
                
                c.JSON(200, gin.H{
                        "metrics": map[string]interface{}{
                                "nodes_online":       2,
                                "models_loaded":      5,
                                "requests_processed": 1500,
                                "cpu_usage":          45.2,
                                "memory_usage":       62.8,
                                "network_usage":      23.1,
                        },
                        "timestamp": time.Now().Unix(),
                })
        }</span>)
        
        // Health check - no authentication required for monitoring
        <span class="cov0" title="0">api.GET("/health", func(c *gin.Context) </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{
                        "status":    "healthy",
                        "timestamp": time.Now().Unix(),
                        "version":   "1.0.0",
                })
        }</span>)
        
        // Transfers endpoint
        <span class="cov0" title="0">api.GET("/transfers", helpers.RequireInferencePermission("read"), func(c *gin.Context) </span><span class="cov0" title="0">{
                user := GetCurrentUser(c)
                log.Printf("User %s requested transfer status", user.Username)
                
                c.JSON(200, gin.H{
                        "transfers": []map[string]interface{}{
                                {
                                        "id":       "transfer-1",
                                        "model":    "llama2",
                                        "status":   "completed",
                                        "progress": 100,
                                },
                        },
                })
        }</span>)
}

// setupDistributionRoutes configures distribution management routes
func setupDistributionRoutes(api *gin.RouterGroup, helpers *MiddlewareHelpers) <span class="cov0" title="0">{
        distribution := api.Group("/distribution")
        
        // Auto-configure distribution - requires admin permission
        distribution.POST("/auto-configure", helpers.RequireClusterPermission("admin"), func(c *gin.Context) </span><span class="cov0" title="0">{
                var req map[string]interface{}
                c.ShouldBindJSON(&amp;req)
                
                user := GetCurrentUser(c)
                log.Printf("User %s configured auto-distribution", user.Username)
                
                c.JSON(200, gin.H{
                        "message": "Auto-distribution configured",
                        "enabled": req["enabled"],
                })
        }</span>)
}

// setupPublicRoutes configures public routes that don't require authentication
func setupPublicRoutes(router *gin.Engine) <span class="cov0" title="0">{
        // Serve static files for web UI
        router.Static("/static", "./web/static")
        router.StaticFile("/", "./web/index.html")
        router.StaticFile("/favicon.ico", "./web/favicon.ico")
        
        // Catch-all for SPA routing
        router.NoRoute(func(c *gin.Context) </span><span class="cov0" title="0">{
                c.File("./web/index.html")
        }</span>)
}

// DemoUsage shows how to use the authentication system programmatically
func DemoUsage() <span class="cov0" title="0">{
        // Create auth config
        cfg := &amp;config.AuthConfig{
                Enabled:     true,
                Method:      "jwt",
                TokenExpiry: 24 * time.Hour,
                SecretKey:   "demo-secret-key",
                Issuer:      "ollama-distributed",
                Audience:    "ollama-api",
        }
        
        // Create auth manager
        authManager, err := NewManager(cfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create auth manager: %v", err)
        }</span>
        <span class="cov0" title="0">defer authManager.Close()
        
        // Create a new user
        userReq := &amp;CreateUserRequest{
                Username: "demo-user",
                Email:    "demo@example.com",
                Password: "secure-password",
                Role:     RoleUser,
        }
        
        user, err := authManager.CreateUser(userReq)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create user: %v", err)
        }</span>
        
        <span class="cov0" title="0">log.Printf("Created user: %s (ID: %s)", user.Username, user.ID)
        
        // Authenticate user
        authCtx, err := authManager.Authenticate("demo-user", "secure-password", map[string]string{
                "ip_address": "127.0.0.1",
                "user_agent": "demo-client",
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to authenticate: %v", err)
        }</span>
        
        <span class="cov0" title="0">log.Printf("Authentication successful! Token: %s", authCtx.TokenString[:50]+"...")
        
        // Create API key
        apiKeyReq := &amp;CreateAPIKeyRequest{
                Name:        "Demo API Key",
                Permissions: []string{PermissionModelRead, PermissionInferenceWrite},
        }
        
        apiKey, rawKey, err := authManager.CreateAPIKey(user.ID, apiKeyReq)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create API key: %v", err)
        }</span>
        
        <span class="cov0" title="0">log.Printf("Created API key: %s (Key: %s)", apiKey.Name, rawKey[:20]+"...")
        
        // Validate API key
        apiAuthCtx, err := authManager.ValidateAPIKey(rawKey)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to validate API key: %v", err)
        }</span>
        
        <span class="cov0" title="0">log.Printf("API key validation successful for user: %s", apiAuthCtx.User.Username)
        
        // Check permissions
        hasModelRead := authManager.HasPermission(apiAuthCtx, PermissionModelRead)
        hasSystemAdmin := authManager.HasPermission(apiAuthCtx, PermissionSystemAdmin)
        
        log.Printf("User has model read permission: %v", hasModelRead)
        log.Printf("User has system admin permission: %v", hasSystemAdmin)</span>
}</pre>
		
		<pre class="file" id="file6" style="display: none">package auth

import (
        "time"

        "github.com/golang-jwt/jwt/v5"
)

// User represents a system user
type User struct {
        ID          string            `json:"id"`
        Username    string            `json:"username"`
        Email       string            `json:"email,omitempty"`
        Role        string            `json:"role"`
        Permissions []string          `json:"permissions"`
        APIKeys     []APIKey          `json:"api_keys,omitempty"`
        Metadata    map[string]string `json:"metadata,omitempty"`
        CreatedAt   time.Time         `json:"created_at"`
        UpdatedAt   time.Time         `json:"updated_at"`
        LastLoginAt *time.Time        `json:"last_login_at,omitempty"`
        Active      bool              `json:"active"`
}

// APIKey represents an API key for authentication
type APIKey struct {
        ID          string            `json:"id"`
        Name        string            `json:"name"`
        Key         string            `json:"key"`
        UserID      string            `json:"user_id"`
        Permissions []string          `json:"permissions"`
        Metadata    map[string]string `json:"metadata,omitempty"`
        ExpiresAt   *time.Time        `json:"expires_at,omitempty"`
        CreatedAt   time.Time         `json:"created_at"`
        LastUsedAt  *time.Time        `json:"last_used_at,omitempty"`
        Active      bool              `json:"active"`
}

// Session represents an authentication session
type Session struct {
        ID        string            `json:"id"`
        UserID    string            `json:"user_id"`
        TokenID   string            `json:"token_id"`
        IPAddress string            `json:"ip_address"`
        UserAgent string            `json:"user_agent"`
        Metadata  map[string]string `json:"metadata,omitempty"`
        CreatedAt time.Time         `json:"created_at"`
        ExpiresAt time.Time         `json:"expires_at"`
        Active    bool              `json:"active"`
}

// Claims represents JWT claims for the system
type Claims struct {
        UserID      string            `json:"user_id"`
        Username    string            `json:"username"`
        Email       string            `json:"email,omitempty"`
        Role        string            `json:"role"`
        Permissions []string          `json:"permissions"`
        SessionID   string            `json:"session_id,omitempty"`
        APIKeyID    string            `json:"api_key_id,omitempty"`
        Metadata    map[string]string `json:"metadata,omitempty"`
        jwt.RegisteredClaims
}

// AuthContext contains authentication information for a request
type AuthContext struct {
        User        *User     `json:"user"`
        Session     *Session  `json:"session,omitempty"`
        APIKey      *APIKey   `json:"api_key,omitempty"`
        Claims      *Claims   `json:"claims"`
        TokenString string    `json:"-"`
        Method      AuthMethod `json:"method"`
}

// AuthMethod represents the authentication method used
type AuthMethod string

const (
        AuthMethodJWT    AuthMethod = "jwt"
        AuthMethodAPIKey AuthMethod = "api_key"
        AuthMethodX509   AuthMethod = "x509"
        AuthMethodNone   AuthMethod = "none"
)

// Permission constants
const (
        PermissionNodeRead       = "node:read"
        PermissionNodeWrite      = "node:write"
        PermissionNodeAdmin      = "node:admin"
        PermissionModelRead      = "model:read"
        PermissionModelWrite     = "model:write"
        PermissionModelAdmin     = "model:admin"
        PermissionClusterRead    = "cluster:read"
        PermissionClusterWrite   = "cluster:write"
        PermissionClusterAdmin   = "cluster:admin"
        PermissionInferenceRead  = "inference:read"
        PermissionInferenceWrite = "inference:write"
        PermissionMetricsRead    = "metrics:read"
        PermissionSystemAdmin    = "system:admin"
        PermissionUserAdmin      = "user:admin"
)

// Role constants
const (
        RoleAdmin     = "admin"
        RoleOperator  = "operator"
        RoleUser      = "user"
        RoleReadOnly  = "readonly"
        RoleService   = "service"
)

// Default role permissions
var DefaultRolePermissions = map[string][]string{
        RoleAdmin: {
                PermissionSystemAdmin,
                PermissionUserAdmin,
                PermissionNodeAdmin,
                PermissionModelAdmin,
                PermissionClusterAdmin,
                PermissionInferenceWrite,
                PermissionMetricsRead,
        },
        RoleOperator: {
                PermissionNodeWrite,
                PermissionModelWrite,
                PermissionClusterWrite,
                PermissionInferenceWrite,
                PermissionMetricsRead,
        },
        RoleUser: {
                PermissionNodeRead,
                PermissionModelRead,
                PermissionClusterRead,
                PermissionInferenceWrite,
                PermissionMetricsRead,
        },
        RoleReadOnly: {
                PermissionNodeRead,
                PermissionModelRead,
                PermissionClusterRead,
                PermissionInferenceRead,
                PermissionMetricsRead,
        },
        RoleService: {
                PermissionNodeRead,
                PermissionModelRead,
                PermissionInferenceWrite,
        },
}

// AuthError represents authentication errors
type AuthError struct {
        Code    string `json:"code"`
        Message string `json:"message"`
        Details string `json:"details,omitempty"`
}

func (e AuthError) Error() string <span class="cov0" title="0">{
        if e.Details != "" </span><span class="cov0" title="0">{
                return e.Message + ": " + e.Details
        }</span>
        <span class="cov0" title="0">return e.Message</span>
}

// Common authentication errors
var (
        ErrInvalidCredentials = AuthError{
                Code:    "INVALID_CREDENTIALS",
                Message: "Invalid credentials provided",
        }
        ErrTokenExpired = AuthError{
                Code:    "TOKEN_EXPIRED",
                Message: "Authentication token has expired",
        }
        ErrTokenInvalid = AuthError{
                Code:    "TOKEN_INVALID",
                Message: "Authentication token is invalid",
        }
        ErrTokenBlacklisted = AuthError{
                Code:    "TOKEN_BLACKLISTED",
                Message: "Authentication token has been revoked",
        }
        ErrInsufficientPermissions = AuthError{
                Code:    "INSUFFICIENT_PERMISSIONS",
                Message: "Insufficient permissions for this operation",
        }
        ErrUserNotFound = AuthError{
                Code:    "USER_NOT_FOUND",
                Message: "User not found",
        }
        ErrUserInactive = AuthError{
                Code:    "USER_INACTIVE",
                Message: "User account is inactive",
        }
        ErrAPIKeyNotFound = AuthError{
                Code:    "API_KEY_NOT_FOUND",
                Message: "API key not found",
        }
        ErrAPIKeyInactive = AuthError{
                Code:    "API_KEY_INACTIVE",
                Message: "API key is inactive",
        }
        ErrAPIKeyExpired = AuthError{
                Code:    "API_KEY_EXPIRED",
                Message: "API key has expired",
        }
        ErrSessionNotFound = AuthError{
                Code:    "SESSION_NOT_FOUND",
                Message: "Session not found",
        }
        ErrSessionExpired = AuthError{
                Code:    "SESSION_EXPIRED",
                Message: "Session has expired",
        }
)

// LoginRequest represents a login request
type LoginRequest struct {
        Username string `json:"username" binding:"required"`
        Password string `json:"password" binding:"required"`
        Metadata map[string]string `json:"metadata,omitempty"`
}

// LoginResponse represents a login response
type LoginResponse struct {
        Token     string    `json:"token"`
        ExpiresAt time.Time `json:"expires_at"`
        User      *User     `json:"user"`
        SessionID string    `json:"session_id"`
}

// RefreshRequest represents a token refresh request
type RefreshRequest struct {
        Token string `json:"token" binding:"required"`
}

// CreateAPIKeyRequest represents an API key creation request
type CreateAPIKeyRequest struct {
        Name        string            `json:"name" binding:"required"`
        Permissions []string          `json:"permissions,omitempty"`
        ExpiresAt   *time.Time        `json:"expires_at,omitempty"`
        Metadata    map[string]string `json:"metadata,omitempty"`
}

// CreateAPIKeyResponse represents an API key creation response
type CreateAPIKeyResponse struct {
        APIKey *APIKey `json:"api_key"`
        Key    string  `json:"key"` // Only returned once during creation
}

// CreateUserRequest represents a user creation request
type CreateUserRequest struct {
        Username    string            `json:"username" binding:"required"`
        Email       string            `json:"email,omitempty"`
        Password    string            `json:"password" binding:"required"`
        Role        string            `json:"role" binding:"required"`
        Permissions []string          `json:"permissions,omitempty"`
        Metadata    map[string]string `json:"metadata,omitempty"`
}

// UpdateUserRequest represents a user update request
type UpdateUserRequest struct {
        Email       *string           `json:"email,omitempty"`
        Role        *string           `json:"role,omitempty"`
        Permissions []string          `json:"permissions,omitempty"`
        Metadata    map[string]string `json:"metadata,omitempty"`
        Active      *bool             `json:"active,omitempty"`
}

// ChangePasswordRequest represents a password change request
type ChangePasswordRequest struct {
        CurrentPassword string `json:"current_password" binding:"required"`
        NewPassword     string `json:"new_password" binding:"required"`
}</pre>
		
		<pre class="file" id="file7" style="display: none">package config

import (
        "fmt"
        "os"
        "path/filepath"
        "time"

        "github.com/spf13/viper"
)

// Config represents the complete configuration for a distributed Ollama node
type Config struct {
        // Node configuration
        Node        NodeConfig        `yaml:"node"`
        API         APIConfig         `yaml:"api"`
        P2P         P2PConfig         `yaml:"p2p"`
        Consensus   ConsensusConfig   `yaml:"consensus"`
        Scheduler   SchedulerConfig   `yaml:"scheduler"`
        Storage     StorageConfig     `yaml:"storage"`
        Security    SecurityConfig    `yaml:"security"`
        Web         WebConfig         `yaml:"web"`
        Metrics     MetricsConfig     `yaml:"metrics"`
        Logging     LoggingConfig     `yaml:"logging"`
        Sync        SyncConfig        `yaml:"sync"`
        Replication ReplicationConfig `yaml:"replication"`
        Distributed DistributedConfig `yaml:"distributed"`
}

// NodeConfig holds node-specific configuration
type NodeConfig struct {
        ID          string            `yaml:"id"`
        Name        string            `yaml:"name"`
        Region      string            `yaml:"region"`
        Zone        string            `yaml:"zone"`
        Environment string            `yaml:"environment"`
        Tags        map[string]string `yaml:"tags"`
}

// APIConfig holds API server configuration
type APIConfig struct {
        Listen      string        `yaml:"listen"`
        TLS         TLSConfig     `yaml:"tls"`
        Cors        CorsConfig    `yaml:"cors"`
        RateLimit   RateLimitConfig `yaml:"rate_limit"`
        Timeout     time.Duration `yaml:"timeout"`
        MaxBodySize int64         `yaml:"max_body_size"`
}

// P2PConfig holds P2P networking configuration
type P2PConfig struct {
        Listen        string   `yaml:"listen"`
        Bootstrap     []string `yaml:"bootstrap"`
        PrivateKey    string   `yaml:"private_key"`
        EnableDHT     bool     `yaml:"enable_dht"`
        EnablePubSub  bool     `yaml:"enable_pubsub"`
        ConnMgrLow    int      `yaml:"conn_mgr_low"`
        ConnMgrHigh   int      `yaml:"conn_mgr_high"`
        ConnMgrGrace  string   `yaml:"conn_mgr_grace"`
        DialTimeout   time.Duration `yaml:"dial_timeout"`
        MaxStreams    int      `yaml:"max_streams"`
}

// ConsensusConfig holds consensus engine configuration
type ConsensusConfig struct {
        DataDir          string        `yaml:"data_dir"`
        BindAddr         string        `yaml:"bind_addr"`
        AdvertiseAddr    string        `yaml:"advertise_addr"`
        Bootstrap        bool          `yaml:"bootstrap"`
        LogLevel         string        `yaml:"log_level"`
        HeartbeatTimeout time.Duration `yaml:"heartbeat_timeout"`
        ElectionTimeout  time.Duration `yaml:"election_timeout"`
        CommitTimeout    time.Duration `yaml:"commit_timeout"`
        MaxAppendEntries int           `yaml:"max_append_entries"`
        SnapshotInterval time.Duration `yaml:"snapshot_interval"`
        SnapshotThreshold uint64       `yaml:"snapshot_threshold"`
}

// SchedulerConfig holds scheduler configuration
type SchedulerConfig struct {
        Algorithm        string        `yaml:"algorithm"`
        LoadBalancing    string        `yaml:"load_balancing"`
        HealthCheckInterval time.Duration `yaml:"health_check_interval"`
        MaxRetries       int           `yaml:"max_retries"`
        RetryDelay       time.Duration `yaml:"retry_delay"`
        QueueSize        int           `yaml:"queue_size"`
        WorkerCount      int           `yaml:"worker_count"`
}

// StorageConfig holds storage configuration
type StorageConfig struct {
        DataDir     string `yaml:"data_dir"`
        ModelDir    string `yaml:"model_dir"`
        CacheDir    string `yaml:"cache_dir"`
        MaxDiskSize int64  `yaml:"max_disk_size"`
        CleanupAge  time.Duration `yaml:"cleanup_age"`
}

// SecurityConfig holds security configuration
type SecurityConfig struct {
        TLS         TLSConfig         `yaml:"tls"`
        Auth        AuthConfig        `yaml:"auth"`
        Encryption  EncryptionConfig  `yaml:"encryption"`
        Firewall    FirewallConfig    `yaml:"firewall"`
        Audit       AuditConfig       `yaml:"audit"`
}

// TLSConfig holds TLS configuration
type TLSConfig struct {
        Enabled    bool   `yaml:"enabled"`
        CertFile   string `yaml:"cert_file"`
        KeyFile    string `yaml:"key_file"`
        CAFile     string `yaml:"ca_file"`
        MinVersion string `yaml:"min_version"`
        CipherSuites []string `yaml:"cipher_suites"`
}

// AuthConfig holds authentication configuration
type AuthConfig struct {
        Enabled     bool          `yaml:"enabled"`
        Method      string        `yaml:"method"` // jwt, oauth, x509
        TokenExpiry time.Duration `yaml:"token_expiry"`
        SecretKey   string        `yaml:"secret_key"`
        Issuer      string        `yaml:"issuer"`
        Audience    string        `yaml:"audience"`
}

// EncryptionConfig holds encryption configuration
type EncryptionConfig struct {
        Algorithm string `yaml:"algorithm"`
        KeySize   int    `yaml:"key_size"`
        KeyFile   string `yaml:"key_file"`
}

// FirewallConfig holds firewall configuration
type FirewallConfig struct {
        Enabled    bool     `yaml:"enabled"`
        AllowedIPs []string `yaml:"allowed_ips"`
        BlockedIPs []string `yaml:"blocked_ips"`
        Rules      []FirewallRule `yaml:"rules"`
}

// FirewallRule represents a firewall rule
type FirewallRule struct {
        Protocol string `yaml:"protocol"`
        Port     int    `yaml:"port"`
        Action   string `yaml:"action"`
        Source   string `yaml:"source"`
}

// AuditConfig holds audit configuration
type AuditConfig struct {
        Enabled bool   `yaml:"enabled"`
        LogFile string `yaml:"log_file"`
        Format  string `yaml:"format"`
}

// CorsConfig holds CORS configuration
type CorsConfig struct {
        Enabled          bool     `yaml:"enabled"`
        AllowedOrigins   []string `yaml:"allowed_origins"`
        AllowedMethods   []string `yaml:"allowed_methods"`
        AllowedHeaders   []string `yaml:"allowed_headers"`
        ExposedHeaders   []string `yaml:"exposed_headers"`
        AllowCredentials bool     `yaml:"allow_credentials"`
        MaxAge           int      `yaml:"max_age"`
}

// RateLimitConfig holds rate limiting configuration
type RateLimitConfig struct {
        Enabled bool  `yaml:"enabled"`
        RPS     int   `yaml:"rps"`
        Burst   int   `yaml:"burst"`
        Window  time.Duration `yaml:"window"`
}

// WebConfig holds web interface configuration
type WebConfig struct {
        Enabled    bool   `yaml:"enabled"`
        Listen     string `yaml:"listen"`
        StaticDir  string `yaml:"static_dir"`
        TemplateDir string `yaml:"template_dir"`
        TLS        TLSConfig `yaml:"tls"`
}

// MetricsConfig holds metrics configuration
type MetricsConfig struct {
        Enabled    bool   `yaml:"enabled"`
        Listen     string `yaml:"listen"`
        Path       string `yaml:"path"`
        Namespace  string `yaml:"namespace"`
        Subsystem  string `yaml:"subsystem"`
}

// LoggingConfig holds logging configuration
type LoggingConfig struct {
        Level      string `yaml:"level"`
        Format     string `yaml:"format"`
        Output     string `yaml:"output"`
        File       string `yaml:"file"`
        MaxSize    int    `yaml:"max_size"`
        MaxAge     int    `yaml:"max_age"`
        MaxBackups int    `yaml:"max_backups"`
        Compress   bool   `yaml:"compress"`
}

// SyncConfig holds model synchronization configuration
type SyncConfig struct {
        DeltaDir       string        `yaml:"delta_dir"`
        CASDir         string        `yaml:"cas_dir"`
        WorkerCount    int           `yaml:"worker_count"`
        SyncInterval   time.Duration `yaml:"sync_interval"`
        ChunkSize      int64         `yaml:"chunk_size"`
        MaxRetries     int           `yaml:"max_retries"`
        RetryDelay     time.Duration `yaml:"retry_delay"`
}

// ReplicationConfig holds model replication configuration
type ReplicationConfig struct {
        WorkerCount                int           `yaml:"worker_count"`
        DefaultMinReplicas         int           `yaml:"default_min_replicas"`
        DefaultMaxReplicas         int           `yaml:"default_max_replicas"`
        DefaultReplicationFactor   int           `yaml:"default_replication_factor"`
        DefaultSyncInterval        time.Duration `yaml:"default_sync_interval"`
        PolicyEnforcementInterval  time.Duration `yaml:"policy_enforcement_interval"`
        HealthCheckInterval        time.Duration `yaml:"health_check_interval"`
        HealthCheckTimeout         time.Duration `yaml:"health_check_timeout"`
}

// DistributedConfig holds distributed model management configuration
type DistributedConfig struct {
        Storage     *StorageConfig     `yaml:"storage"`
        Sync        *SyncConfig        `yaml:"sync"`
        Replication *ReplicationConfig `yaml:"replication"`
        CASDir      string             `yaml:"cas_dir"`
        DeltaDir    string             `yaml:"delta_dir"`
}

// DefaultConfig returns a default configuration
func DefaultConfig() *Config <span class="cov0" title="0">{
        // Create storage config first
        storageConfig := StorageConfig{
                DataDir:     "./data",
                ModelDir:    "./models",
                CacheDir:    "./cache",
                MaxDiskSize: 100 * 1024 * 1024 * 1024, // 100GB
                CleanupAge:  7 * 24 * time.Hour,       // 7 days
        }
        
        // Create sync config
        syncConfig := SyncConfig{
                DeltaDir:     "./data/deltas",
                CASDir:       "./data/cas",
                WorkerCount:  3,
                SyncInterval: 5 * time.Minute,
                ChunkSize:    1024 * 1024, // 1MB
                MaxRetries:   3,
                RetryDelay:   time.Second,
        }
        
        // Create replication config
        replicationConfig := ReplicationConfig{
                WorkerCount:                3,
                DefaultMinReplicas:         1,
                DefaultMaxReplicas:         3,
                DefaultReplicationFactor:   2,
                DefaultSyncInterval:        10 * time.Minute,
                PolicyEnforcementInterval:  30 * time.Second,
                HealthCheckInterval:        30 * time.Second,
                HealthCheckTimeout:         10 * time.Second,
        }
        
        return &amp;Config{
                Node: NodeConfig{
                        ID:          "",
                        Name:        "ollama-node",
                        Region:      "us-west-2",
                        Zone:        "us-west-2a",
                        Environment: "production",
                        Tags:        make(map[string]string),
                },
                API: APIConfig{
                        Listen:      "0.0.0.0:11434",
                        Timeout:     30 * time.Second,
                        MaxBodySize: 32 * 1024 * 1024, // 32MB
                        TLS: TLSConfig{
                                Enabled:    false,
                                MinVersion: "1.2",
                        },
                        Cors: CorsConfig{
                                Enabled:          true,
                                AllowedOrigins:   []string{"http://localhost:8080", "https://localhost:8080"},
                                AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
                                AllowedHeaders:   []string{"Content-Type", "Authorization", "X-Requested-With"},
                                AllowCredentials: true,
                                MaxAge:           3600,
                        },
                        RateLimit: RateLimitConfig{
                                Enabled: true,
                                RPS:     1000,
                                Burst:   2000,
                                Window:  time.Minute,
                        },
                },
                P2P: P2PConfig{
                        Listen:        "/ip4/0.0.0.0/tcp/4001",
                        Bootstrap:     []string{},
                        EnableDHT:     true,
                        EnablePubSub:  true,
                        ConnMgrLow:    50,
                        ConnMgrHigh:   200,
                        ConnMgrGrace:  "30s",
                        DialTimeout:   30 * time.Second,
                        MaxStreams:    1000,
                },
                Consensus: ConsensusConfig{
                        DataDir:           "./data/consensus",
                        BindAddr:          "0.0.0.0:7000",
                        AdvertiseAddr:     "",
                        Bootstrap:         false,
                        LogLevel:          "INFO",
                        HeartbeatTimeout:  1 * time.Second,
                        ElectionTimeout:   1 * time.Second,
                        CommitTimeout:     50 * time.Millisecond,
                        MaxAppendEntries:  64,
                        SnapshotInterval:  120 * time.Second,
                        SnapshotThreshold: 8192,
                },
                Scheduler: SchedulerConfig{
                        Algorithm:           "round_robin",
                        LoadBalancing:       "least_connections",
                        HealthCheckInterval: 30 * time.Second,
                        MaxRetries:          3,
                        RetryDelay:          1 * time.Second,
                        QueueSize:           10000,
                        WorkerCount:         10,
                },
                Storage: storageConfig,
                Security: SecurityConfig{
                        TLS: TLSConfig{
                                Enabled:    true,
                                MinVersion: "1.3",
                        },
                        Auth: AuthConfig{
                                Enabled:     true,
                                Method:      "jwt",
                                TokenExpiry: 24 * time.Hour,
                        },
                        Encryption: EncryptionConfig{
                                Algorithm: "AES-256-GCM",
                                KeySize:   256,
                        },
                        Firewall: FirewallConfig{
                                Enabled: true,
                                Rules:   []FirewallRule{},
                        },
                        Audit: AuditConfig{
                                Enabled: true,
                                LogFile: "./logs/audit.log",
                                Format:  "json",
                        },
                },
                Web: WebConfig{
                        Enabled:   true,
                        Listen:    "0.0.0.0:8080",
                        StaticDir: "./web/static",
                        TLS: TLSConfig{
                                Enabled: false,
                        },
                },
                Metrics: MetricsConfig{
                        Enabled:   true,
                        Listen:    "0.0.0.0:9090",
                        Path:      "/metrics",
                        Namespace: "ollama",
                        Subsystem: "distributed",
                },
                Logging: LoggingConfig{
                        Level:      "info",
                        Format:     "json",
                        Output:     "stdout",
                        MaxSize:    100,
                        MaxAge:     30,
                        MaxBackups: 10,
                        Compress:   true,
                },
                Sync:        syncConfig,
                Replication: replicationConfig,
                Distributed: DistributedConfig{
                        Storage:     &amp;storageConfig,
                        Sync:        &amp;syncConfig,
                        Replication: &amp;replicationConfig,
                        CASDir:      "./data/cas",
                        DeltaDir:    "./data/deltas",
                },
        }
}</span>

// Load loads configuration from file
func Load(configFile string) (*Config, error) <span class="cov0" title="0">{
        config := DefaultConfig()
        
        if configFile != "" </span><span class="cov0" title="0">{
                viper.SetConfigFile(configFile)
        }</span> else<span class="cov0" title="0"> {
                // Look for config in standard locations
                viper.SetConfigName("config")
                viper.SetConfigType("yaml")
                viper.AddConfigPath(".")
                viper.AddConfigPath("./config")
                viper.AddConfigPath("$HOME/.ollama-distributed")
                viper.AddConfigPath("/etc/ollama-distributed")
        }</span>
        
        // Environment variables
        <span class="cov0" title="0">viper.SetEnvPrefix("OLLAMA")
        viper.AutomaticEnv()
        
        // Read configuration
        if err := viper.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                if _, ok := err.(viper.ConfigFileNotFoundError); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to read config file: %w", err)
                }</span>
        }
        
        // Unmarshal into config struct
        <span class="cov0" title="0">if err := viper.Unmarshal(config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal config: %w", err)
        }</span>
        
        // Validate and set defaults
        <span class="cov0" title="0">if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid configuration: %w", err)
        }</span>
        
        <span class="cov0" title="0">return config, nil</span>
}

// Validate validates the configuration
func (c *Config) Validate() error <span class="cov0" title="0">{
        // Validate directories exist or can be created
        dirs := []string{
                c.Storage.DataDir,
                c.Storage.ModelDir,
                c.Storage.CacheDir,
                c.Consensus.DataDir,
                c.Sync.DeltaDir,
                c.Sync.CASDir,
                c.Distributed.CASDir,
                c.Distributed.DeltaDir,
        }
        
        for _, dir := range dirs </span><span class="cov0" title="0">{
                if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create directory %s: %w", dir, err)
                }</span>
        }
        
        // Validate log directory
        <span class="cov0" title="0">if c.Logging.Output == "file" &amp;&amp; c.Logging.File != "" </span><span class="cov0" title="0">{
                logDir := filepath.Dir(c.Logging.File)
                if err := os.MkdirAll(logDir, 0755); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create log directory %s: %w", logDir, err)
                }</span>
        }
        
        // Validate TLS certificates if enabled
        <span class="cov0" title="0">if c.Security.TLS.Enabled </span><span class="cov0" title="0">{
                if c.Security.TLS.CertFile == "" || c.Security.TLS.KeyFile == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("TLS enabled but cert_file or key_file not specified")
                }</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// Save saves the configuration to a file
func (c *Config) Save(filename string) error <span class="cov0" title="0">{
        viper.Set("config", c)
        return viper.WriteConfigAs(filename)
}</pre>
		
		<pre class="file" id="file8" style="display: none">package storage

import (
        "context"
        "fmt"
        "io"
        "log/slog"
        "sort"
        "sync"
        "time"
)

// DistributedStorageImpl implements DistributedStorage interface
type DistributedStorageImpl struct {
        localStorage Storage
        logger       *slog.Logger
        
        // Distributed coordination
        nodeID       string
        
        // Node management
        nodes       map[string]*NodeInfo
        nodesMutex  sync.RWMutex
        
        // Replication management
        replicationMgr *ReplicationManager
        
        // Consensus and coordination
        consensusState *ConsensusState
        consensusMutex sync.RWMutex
        
        // Distributed locks
        locks       map[string]*DistributedLock
        locksMutex  sync.RWMutex
        
        // Configuration
        config *DistributedStorageConfig
        
        // Metrics and monitoring
        metrics     *DistributedMetrics
        metricsMutex sync.RWMutex
        
        // Background tasks
        ctx     context.Context
        cancel  context.CancelFunc
        started bool
        mu      sync.RWMutex
}

// DistributedStorageConfig contains configuration for distributed storage
type DistributedStorageConfig struct {
        NodeID               string        `json:"node_id"`
        ReplicationFactor    int           `json:"replication_factor"`
        ConsistencyLevel     string        `json:"consistency_level"`
        HeartbeatInterval    time.Duration `json:"heartbeat_interval"`
        ElectionTimeout      time.Duration `json:"election_timeout"`
        ReplicationTimeout   time.Duration `json:"replication_timeout"`
        MaxConcurrentRepl    int           `json:"max_concurrent_replication"`
        GossipInterval       time.Duration `json:"gossip_interval"`
        FailureDetectorTimeout time.Duration `json:"failure_detector_timeout"`
}

// ReplicationManager handles distributed replication
type ReplicationManager struct {
        storage    *DistributedStorageImpl
        logger     *slog.Logger
        
        // Replication state
        replicas      map[string]*ReplicationStatus
        replicasMutex sync.RWMutex
        
        // Worker pools
        workers     []*ReplicationWorker
        workQueue   chan *ReplicationTask
        
        // Policies
        policies      map[string]*ReplicationPolicy
        policiesMutex sync.RWMutex
        
        ctx    context.Context
        cancel context.CancelFunc
}

// ReplicationWorker handles replication tasks
type ReplicationWorker struct {
        id      int
        manager *ReplicationManager
        logger  *slog.Logger
}

// ReplicationTask represents a replication task
type ReplicationTask struct {
        Type        string    `json:"type"`
        Key         string    `json:"key"`
        SourceNode  string    `json:"source_node"`
        TargetNodes []string  `json:"target_nodes"`
        Priority    int       `json:"priority"`
        Timeout     time.Duration `json:"timeout"`
        CreatedAt   time.Time `json:"created_at"`
        Retries     int       `json:"retries"`
        MaxRetries  int       `json:"max_retries"`
}

// DistributedLock implements the Lock interface
type DistributedLock struct {
        lockID     string
        owner      string
        expiration time.Time
        storage    *DistributedStorageImpl
        released   bool
        mutex      sync.Mutex
}

// NewDistributedStorage creates a new distributed storage instance
func NewDistributedStorage(
        localStorage Storage,
        config *DistributedStorageConfig,
        logger *slog.Logger,
) (*DistributedStorageImpl, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())
        
        ds := &amp;DistributedStorageImpl{
                localStorage: localStorage,
                logger:       logger,
                nodeID:       config.NodeID,
                nodes:        make(map[string]*NodeInfo),
                locks:        make(map[string]*DistributedLock),
                config:       config,
                consensusState: &amp;ConsensusState{
                        Nodes:      make(map[string]string),
                        QuorumSize: (config.ReplicationFactor / 2) + 1,
                        IsHealthy:  true,
                },
                metrics: &amp;DistributedMetrics{
                        DataDistribution: make(map[string]int64),
                        NetworkMetrics:   &amp;NetworkMetrics{ConnectionCounts: make(map[string]int64)},
                        ConsensusMetrics: &amp;ConsensusMetrics{},
                },
                ctx:    ctx,
                cancel: cancel,
        }
        
        // Initialize replication manager
        ds.replicationMgr = &amp;ReplicationManager{
                storage:   ds,
                logger:    logger,
                replicas:  make(map[string]*ReplicationStatus),
                policies:  make(map[string]*ReplicationPolicy),
                workQueue: make(chan *ReplicationTask, 1000),
                ctx:       ctx,
                cancel:    cancel,
        }
        
        // Create replication workers
        workerCount := config.MaxConcurrentRepl
        if workerCount &lt;= 0 </span><span class="cov0" title="0">{
                workerCount = 10
        }</span>
        
        <span class="cov0" title="0">ds.replicationMgr.workers = make([]*ReplicationWorker, workerCount)
        for i := 0; i &lt; workerCount; i++ </span><span class="cov0" title="0">{
                ds.replicationMgr.workers[i] = &amp;ReplicationWorker{
                        id:      i,
                        manager: ds.replicationMgr,
                        logger:  logger,
                }
        }</span>
        
        <span class="cov0" title="0">return ds, nil</span>
}

// Start starts the distributed storage
func (ds *DistributedStorageImpl) Start(ctx context.Context) error <span class="cov0" title="0">{
        ds.mu.Lock()
        defer ds.mu.Unlock()
        
        if ds.started </span><span class="cov0" title="0">{
                return &amp;StorageError{
                        Code:    ErrCodeInternal,
                        Message: "distributed storage already started",
                }
        }</span>
        
        // Start local storage
        <span class="cov0" title="0">if err := ds.localStorage.Start(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start local storage: %w", err)
        }</span>
        
        // Start replication workers
        <span class="cov0" title="0">for _, worker := range ds.replicationMgr.workers </span><span class="cov0" title="0">{
                go worker.start()
        }</span>
        
        // Start background routines
        <span class="cov0" title="0">go ds.heartbeatRoutine()
        go ds.consensusMonitorRoutine()
        go ds.metricsCollectionRoutine()
        go ds.failureDetectorRoutine()
        
        ds.started = true
        ds.logger.Info("distributed storage started", "node_id", ds.nodeID)
        
        return nil</span>
}

// Stop stops the distributed storage
func (ds *DistributedStorageImpl) Stop(ctx context.Context) error <span class="cov0" title="0">{
        ds.mu.Lock()
        defer ds.mu.Unlock()
        
        if !ds.started </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">ds.cancel()
        
        // Stop local storage
        if err := ds.localStorage.Stop(ctx); err != nil </span><span class="cov0" title="0">{
                ds.logger.Error("failed to stop local storage", "error", err)
        }</span>
        
        <span class="cov0" title="0">ds.started = false
        ds.logger.Info("distributed storage stopped")
        
        return nil</span>
}

// Close closes the distributed storage
func (ds *DistributedStorageImpl) Close() error <span class="cov0" title="0">{
        return ds.Stop(context.Background())
}</span>

// Core storage operations (delegate to local storage with replication)

// Store stores an object with distributed replication
func (ds *DistributedStorageImpl) Store(ctx context.Context, key string, data io.Reader, metadata *ObjectMetadata) error <span class="cov0" title="0">{
        // First store locally
        if err := ds.localStorage.Store(ctx, key, data, metadata); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // Get or create replication policy
        <span class="cov0" title="0">policy := ds.getReplicationPolicy(key)
        if policy == nil </span><span class="cov0" title="0">{
                policy = ds.createDefaultReplicationPolicy(key)
        }</span>
        
        // Initiate replication based on policy
        <span class="cov0" title="0">if err := ds.initiateReplication(ctx, key, policy); err != nil </span><span class="cov0" title="0">{
                ds.logger.Error("replication failed", "key", key, "error", err)
                // Don't fail the store operation if replication fails
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// Retrieve retrieves an object, potentially from replicas
func (ds *DistributedStorageImpl) Retrieve(ctx context.Context, key string) (io.ReadCloser, *ObjectMetadata, error) <span class="cov0" title="0">{
        // Try local storage first
        reader, metadata, err := ds.localStorage.Retrieve(ctx, key)
        if err == nil </span><span class="cov0" title="0">{
                return reader, metadata, nil
        }</span>
        
        // If not found locally, try replicas
        <span class="cov0" title="0">if isNotFoundError(err) </span><span class="cov0" title="0">{
                return ds.retrieveFromReplicas(ctx, key)
        }</span>
        
        <span class="cov0" title="0">return nil, nil, err</span>
}

// Delete deletes an object from all replicas
func (ds *DistributedStorageImpl) Delete(ctx context.Context, key string) error <span class="cov0" title="0">{
        // Delete locally first
        if err := ds.localStorage.Delete(ctx, key); err != nil &amp;&amp; !isNotFoundError(err) </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // Delete from replicas
        <span class="cov0" title="0">if err := ds.deleteFromReplicas(ctx, key); err != nil </span><span class="cov0" title="0">{
                ds.logger.Error("failed to delete from replicas", "key", key, "error", err)
        }</span>
        
        // Remove replication status
        <span class="cov0" title="0">ds.replicationMgr.removeReplicationStatus(key)
        
        return nil</span>
}

// Exists checks if an object exists locally or on replicas
func (ds *DistributedStorageImpl) Exists(ctx context.Context, key string) (bool, error) <span class="cov0" title="0">{
        // Check locally first
        exists, err := ds.localStorage.Exists(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return true, nil
        }</span>
        
        // Check replicas
        <span class="cov0" title="0">return ds.existsOnReplicas(ctx, key)</span>
}

// Delegate metadata operations to local storage
func (ds *DistributedStorageImpl) GetMetadata(ctx context.Context, key string) (*ObjectMetadata, error) <span class="cov0" title="0">{
        return ds.localStorage.GetMetadata(ctx, key)
}</span>

func (ds *DistributedStorageImpl) SetMetadata(ctx context.Context, key string, metadata *ObjectMetadata) error <span class="cov0" title="0">{
        return ds.localStorage.SetMetadata(ctx, key, metadata)
}</span>

func (ds *DistributedStorageImpl) UpdateMetadata(ctx context.Context, key string, updates map[string]interface{}) error <span class="cov0" title="0">{
        return ds.localStorage.UpdateMetadata(ctx, key, updates)
}</span>

// Delegate batch operations
func (ds *DistributedStorageImpl) BatchStore(ctx context.Context, operations []BatchStoreOperation) error <span class="cov0" title="0">{
        return ds.localStorage.BatchStore(ctx, operations)
}</span>

func (ds *DistributedStorageImpl) BatchDelete(ctx context.Context, keys []string) error <span class="cov0" title="0">{
        return ds.localStorage.BatchDelete(ctx, keys)
}</span>

// Delegate listing operations
func (ds *DistributedStorageImpl) List(ctx context.Context, prefix string, options *ListOptions) (*ListResult, error) <span class="cov0" title="0">{
        return ds.localStorage.List(ctx, prefix, options)
}</span>

func (ds *DistributedStorageImpl) ListKeys(ctx context.Context, prefix string) ([]string, error) <span class="cov0" title="0">{
        return ds.localStorage.ListKeys(ctx, prefix)
}</span>

// Distributed-specific operations

// Replicate replicates an object to target nodes
func (ds *DistributedStorageImpl) Replicate(ctx context.Context, key string, targetNodes []string) error <span class="cov0" title="0">{
        task := &amp;ReplicationTask{
                Type:        "replicate",
                Key:         key,
                SourceNode:  ds.nodeID,
                TargetNodes: targetNodes,
                Priority:    1,
                Timeout:     ds.config.ReplicationTimeout,
                CreatedAt:   time.Now(),
                MaxRetries:  3,
        }
        
        select </span>{
        case ds.replicationMgr.workQueue &lt;- task:<span class="cov0" title="0">
                return nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        case &lt;-time.After(5 * time.Second):<span class="cov0" title="0">
                return &amp;StorageError{
                        Code:    ErrCodeTimeout,
                        Message: "replication queue full",
                }</span>
        }
}

// GetReplicationStatus gets the replication status for a key
func (ds *DistributedStorageImpl) GetReplicationStatus(ctx context.Context, key string) (*ReplicationStatus, error) <span class="cov0" title="0">{
        ds.replicationMgr.replicasMutex.RLock()
        defer ds.replicationMgr.replicasMutex.RUnlock()
        
        status, exists := ds.replicationMgr.replicas[key]
        if !exists </span><span class="cov0" title="0">{
                return nil, &amp;StorageError{
                        Code:    ErrCodeNotFound,
                        Message: "replication status not found",
                }
        }</span>
        
        // Create a copy
        <span class="cov0" title="0">result := *status
        return &amp;result, nil</span>
}

// SetReplicationPolicy sets a replication policy for a key
func (ds *DistributedStorageImpl) SetReplicationPolicy(ctx context.Context, key string, policy *ReplicationPolicy) error <span class="cov0" title="0">{
        ds.replicationMgr.policiesMutex.Lock()
        defer ds.replicationMgr.policiesMutex.Unlock()
        
        ds.replicationMgr.policies[key] = policy
        
        // Trigger replication if necessary
        go ds.enforceReplicationPolicy(ctx, key, policy)
        
        return nil
}</span>

// Consensus and coordination operations

// ProposeWrite proposes a write operation through consensus
func (ds *DistributedStorageImpl) ProposeWrite(ctx context.Context, key string, data io.Reader, metadata *ObjectMetadata) error <span class="cov0" title="0">{
        // For now, fall back to direct store since we don't have Raft integration
        return ds.Store(ctx, key, data, metadata)
}</span>

// ProposeDelete proposes a delete operation through consensus
func (ds *DistributedStorageImpl) ProposeDelete(ctx context.Context, key string) error <span class="cov0" title="0">{
        // For now, fall back to direct delete since we don't have Raft integration
        return ds.Delete(ctx, key)
}</span>

// GetConsensusState returns the current consensus state
func (ds *DistributedStorageImpl) GetConsensusState(ctx context.Context) (*ConsensusState, error) <span class="cov0" title="0">{
        ds.consensusMutex.RLock()
        defer ds.consensusMutex.RUnlock()
        
        // Create a copy
        state := *ds.consensusState
        state.Nodes = make(map[string]string)
        for k, v := range ds.consensusState.Nodes </span><span class="cov0" title="0">{
                state.Nodes[k] = v
        }</span>
        
        <span class="cov0" title="0">return &amp;state, nil</span>
}

// Node management operations

// AddNode adds a new node to the cluster
func (ds *DistributedStorageImpl) AddNode(ctx context.Context, nodeID string, nodeInfo *NodeInfo) error <span class="cov0" title="0">{
        ds.nodesMutex.Lock()
        defer ds.nodesMutex.Unlock()
        
        nodeInfo.NodeID = nodeID
        nodeInfo.JoinedAt = time.Now()
        nodeInfo.LastSeen = time.Now()
        
        ds.nodes[nodeID] = nodeInfo
        
        // Update consensus state
        ds.consensusMutex.Lock()
        ds.consensusState.Nodes[nodeID] = "active"
        ds.consensusMutex.Unlock()
        
        ds.logger.Info("node added", "node_id", nodeID, "address", nodeInfo.Address)
        
        return nil
}</span>

// RemoveNode removes a node from the cluster
func (ds *DistributedStorageImpl) RemoveNode(ctx context.Context, nodeID string) error <span class="cov0" title="0">{
        ds.nodesMutex.Lock()
        defer ds.nodesMutex.Unlock()
        
        delete(ds.nodes, nodeID)
        
        // Update consensus state
        ds.consensusMutex.Lock()
        delete(ds.consensusState.Nodes, nodeID)
        ds.consensusMutex.Unlock()
        
        ds.logger.Info("node removed", "node_id", nodeID)
        
        return nil
}</span>

// GetNodes returns all nodes in the cluster
func (ds *DistributedStorageImpl) GetNodes(ctx context.Context) ([]*NodeInfo, error) <span class="cov0" title="0">{
        ds.nodesMutex.RLock()
        defer ds.nodesMutex.RUnlock()
        
        nodes := make([]*NodeInfo, 0, len(ds.nodes))
        for _, node := range ds.nodes </span><span class="cov0" title="0">{
                // Create a copy
                nodeCopy := *node
                nodes = append(nodes, &amp;nodeCopy)
        }</span>
        
        <span class="cov0" title="0">return nodes, nil</span>
}

// Distributed coordination

// AcquireLock acquires a distributed lock
func (ds *DistributedStorageImpl) AcquireLock(ctx context.Context, lockID string, timeout time.Duration) (Lock, error) <span class="cov0" title="0">{
        ds.locksMutex.Lock()
        defer ds.locksMutex.Unlock()
        
        // Check if lock already exists
        if lock, exists := ds.locks[lockID]; exists </span><span class="cov0" title="0">{
                if lock.IsHeld() </span><span class="cov0" title="0">{
                        return nil, &amp;StorageError{
                                Code:    ErrCodeAlreadyExists,
                                Message: "lock already held",
                        }
                }</span>
        }
        
        // Create new lock
        <span class="cov0" title="0">lock := &amp;DistributedLock{
                lockID:     lockID,
                owner:      ds.nodeID,
                expiration: time.Now().Add(timeout),
                storage:    ds,
                released:   false,
        }
        
        ds.locks[lockID] = lock
        
        return lock, nil</span>
}

// GetDistributedMetrics returns distributed metrics
func (ds *DistributedStorageImpl) GetDistributedMetrics(ctx context.Context) (*DistributedMetrics, error) <span class="cov0" title="0">{
        ds.metricsMutex.RLock()
        defer ds.metricsMutex.RUnlock()
        
        // Create a copy
        metrics := *ds.metrics
        
        // Copy maps
        metrics.DataDistribution = make(map[string]int64)
        for k, v := range ds.metrics.DataDistribution </span><span class="cov0" title="0">{
                metrics.DataDistribution[k] = v
        }</span>
        
        <span class="cov0" title="0">if ds.metrics.NetworkMetrics != nil </span><span class="cov0" title="0">{
                netMetrics := *ds.metrics.NetworkMetrics
                netMetrics.ConnectionCounts = make(map[string]int64)
                for k, v := range ds.metrics.NetworkMetrics.ConnectionCounts </span><span class="cov0" title="0">{
                        netMetrics.ConnectionCounts[k] = v
                }</span>
                <span class="cov0" title="0">metrics.NetworkMetrics = &amp;netMetrics</span>
        }
        
        <span class="cov0" title="0">if ds.metrics.ConsensusMetrics != nil </span><span class="cov0" title="0">{
                consMetrics := *ds.metrics.ConsensusMetrics
                metrics.ConsensusMetrics = &amp;consMetrics
        }</span>
        
        <span class="cov0" title="0">return &amp;metrics, nil</span>
}

// Health check for distributed storage
func (ds *DistributedStorageImpl) HealthCheck(ctx context.Context) (*HealthStatus, error) <span class="cov0" title="0">{
        // Get local health first
        localHealth, err := ds.localStorage.HealthCheck(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // Add distributed-specific checks
        <span class="cov0" title="0">checks := localHealth.Checks
        if checks == nil </span><span class="cov0" title="0">{
                checks = make(map[string]CheckResult)
        }</span>
        
        // Check consensus health
        <span class="cov0" title="0">consensusCheck := ds.checkConsensusHealth()
        checks["consensus"] = consensusCheck
        
        // Check node connectivity
        connectivityCheck := ds.checkNodeConnectivity()
        checks["connectivity"] = connectivityCheck
        
        // Check replication health
        replicationCheck := ds.checkReplicationHealth()
        checks["replication"] = replicationCheck
        
        // Overall health
        healthy := localHealth.Healthy &amp;&amp; 
                consensusCheck.Status == "ok" &amp;&amp; 
                connectivityCheck.Status == "ok" &amp;&amp; 
                replicationCheck.Status == "ok"
        
        status := "healthy"
        if !healthy </span><span class="cov0" title="0">{
                status = "unhealthy"
        }</span>
        
        <span class="cov0" title="0">return &amp;HealthStatus{
                Status:    status,
                Healthy:   healthy,
                LastCheck: time.Now(),
                Checks:    checks,
        }, nil</span>
}

// GetStats returns distributed storage statistics
func (ds *DistributedStorageImpl) GetStats(ctx context.Context) (*StorageStats, error) <span class="cov0" title="0">{
        localStats, err := ds.localStorage.GetStats(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // Add replication statistics
        <span class="cov0" title="0">localStats.Replication = ds.getReplicationStats()
        
        return localStats, nil</span>
}

// Helper methods

func (ds *DistributedStorageImpl) getReplicationPolicy(key string) *ReplicationPolicy <span class="cov0" title="0">{
        ds.replicationMgr.policiesMutex.RLock()
        defer ds.replicationMgr.policiesMutex.RUnlock()
        
        return ds.replicationMgr.policies[key]
}</span>

func (ds *DistributedStorageImpl) createDefaultReplicationPolicy(key string) *ReplicationPolicy <span class="cov0" title="0">{
        policy := &amp;ReplicationPolicy{
                MinReplicas:      ds.config.ReplicationFactor,
                MaxReplicas:      ds.config.ReplicationFactor * 2,
                ConsistencyLevel: ds.config.ConsistencyLevel,
                Strategy:         "eager",
                Constraints:      make(map[string]interface{}),
        }
        
        ds.replicationMgr.policiesMutex.Lock()
        ds.replicationMgr.policies[key] = policy
        ds.replicationMgr.policiesMutex.Unlock()
        
        return policy
}</span>

func (ds *DistributedStorageImpl) initiateReplication(ctx context.Context, key string, policy *ReplicationPolicy) error <span class="cov0" title="0">{
        // Select target nodes
        targetNodes := ds.selectReplicationTargets(policy)
        if len(targetNodes) == 0 </span><span class="cov0" title="0">{
                return &amp;StorageError{
                        Code:    ErrCodeUnavailable,
                        Message: "no suitable replication targets available",
                }
        }</span>
        
        // Create replication status
        <span class="cov0" title="0">status := &amp;ReplicationStatus{
                Key:             key,
                Policy:          policy,
                CurrentReplicas: 1, // Local copy
                HealthyReplicas: 1,
                ReplicaNodes:    append([]string{ds.nodeID}, targetNodes...),
                SyncStatus:      make(map[string]string),
                LastSync:        time.Now(),
        }
        
        ds.replicationMgr.replicasMutex.Lock()
        ds.replicationMgr.replicas[key] = status
        ds.replicationMgr.replicasMutex.Unlock()
        
        // Submit replication task
        return ds.Replicate(ctx, key, targetNodes)</span>
}

func (ds *DistributedStorageImpl) selectReplicationTargets(policy *ReplicationPolicy) []string <span class="cov0" title="0">{
        ds.nodesMutex.RLock()
        defer ds.nodesMutex.RUnlock()
        
        var candidates []*NodeInfo
        
        // Filter by preferred nodes first
        if len(policy.PreferredNodes) &gt; 0 </span><span class="cov0" title="0">{
                for _, nodeID := range policy.PreferredNodes </span><span class="cov0" title="0">{
                        if node, exists := ds.nodes[nodeID]; exists &amp;&amp; nodeID != ds.nodeID </span><span class="cov0" title="0">{
                                candidates = append(candidates, node)
                        }</span>
                }
        }
        
        // Add other available nodes if needed
        <span class="cov0" title="0">if len(candidates) &lt; policy.MinReplicas </span><span class="cov0" title="0">{
                for nodeID, node := range ds.nodes </span><span class="cov0" title="0">{
                        if nodeID == ds.nodeID </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        
                        // Check if already in candidates
                        <span class="cov0" title="0">found := false
                        for _, candidate := range candidates </span><span class="cov0" title="0">{
                                if candidate.NodeID == nodeID </span><span class="cov0" title="0">{
                                        found = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if found </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        
                        // Check excluded nodes
                        <span class="cov0" title="0">excluded := false
                        for _, excludedID := range policy.ExcludedNodes </span><span class="cov0" title="0">{
                                if excludedID == nodeID </span><span class="cov0" title="0">{
                                        excluded = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if excluded </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        
                        <span class="cov0" title="0">candidates = append(candidates, node)
                        if len(candidates) &gt;= policy.MinReplicas </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
        }
        
        // Sort by availability and select top candidates
        <span class="cov0" title="0">sort.Slice(candidates, func(i, j int) bool </span><span class="cov0" title="0">{
                return candidates[i].Available &gt; candidates[j].Available
        }</span>)
        
        <span class="cov0" title="0">var targets []string
        for i, candidate := range candidates </span><span class="cov0" title="0">{
                if i &gt;= policy.MinReplicas </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">targets = append(targets, candidate.NodeID)</span>
        }
        
        <span class="cov0" title="0">return targets</span>
}

func (ds *DistributedStorageImpl) retrieveFromReplicas(ctx context.Context, key string) (io.ReadCloser, *ObjectMetadata, error) <span class="cov0" title="0">{
        // Get replication status
        status, err := ds.GetReplicationStatus(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        
        // Try to retrieve from healthy replicas
        <span class="cov0" title="0">for _, nodeID := range status.ReplicaNodes </span><span class="cov0" title="0">{
                if nodeID == ds.nodeID </span><span class="cov0" title="0">{
                        continue</span> // Skip local node
                }
                
                // TODO: Implement remote retrieval from peer node
                // This would involve network communication with the peer
                <span class="cov0" title="0">ds.logger.Debug("attempting to retrieve from replica", "key", key, "node", nodeID)</span>
        }
        
        <span class="cov0" title="0">return nil, nil, &amp;StorageError{
                Code:    ErrCodeNotFound,
                Message: "object not found on any replica",
        }</span>
}

func (ds *DistributedStorageImpl) deleteFromReplicas(ctx context.Context, key string) error <span class="cov0" title="0">{
        // Get replication status
        status, err := ds.GetReplicationStatus(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                return nil // No replicas to delete from
        }</span>
        
        // Send delete requests to replicas
        <span class="cov0" title="0">for _, nodeID := range status.ReplicaNodes </span><span class="cov0" title="0">{
                if nodeID == ds.nodeID </span><span class="cov0" title="0">{
                        continue</span> // Skip local node
                }
                
                // TODO: Implement remote deletion
                <span class="cov0" title="0">ds.logger.Debug("deleting from replica", "key", key, "node", nodeID)</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

func (ds *DistributedStorageImpl) existsOnReplicas(ctx context.Context, key string) (bool, error) <span class="cov0" title="0">{
        // Get replication status
        status, err := ds.GetReplicationStatus(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                return false, nil // No replicas
        }</span>
        
        // Check replicas
        <span class="cov0" title="0">for _, nodeID := range status.ReplicaNodes </span><span class="cov0" title="0">{
                if nodeID == ds.nodeID </span><span class="cov0" title="0">{
                        continue</span> // Skip local node
                }
                
                // TODO: Implement remote existence check
                <span class="cov0" title="0">ds.logger.Debug("checking existence on replica", "key", key, "node", nodeID)</span>
        }
        
        <span class="cov0" title="0">return false, nil</span>
}

func (ds *DistributedStorageImpl) enforceReplicationPolicy(ctx context.Context, key string, policy *ReplicationPolicy) {<span class="cov0" title="0">
        // TODO: Implement policy enforcement
        // This would check current replication status and adjust as needed
}</span>

// Health check methods

func (ds *DistributedStorageImpl) checkConsensusHealth() CheckResult <span class="cov0" title="0">{
        start := time.Now()
        
        return CheckResult{
                Status:  "ok",
                Message: "consensus simulation healthy",
                Latency: time.Since(start).Milliseconds(),
                Time:    time.Now(),
        }
}</span>

func (ds *DistributedStorageImpl) checkNodeConnectivity() CheckResult <span class="cov0" title="0">{
        start := time.Now()
        
        ds.nodesMutex.RLock()
        totalNodes := len(ds.nodes)
        connectedNodes := 0
        
        for _, node := range ds.nodes </span><span class="cov0" title="0">{
                if time.Since(node.LastSeen) &lt; ds.config.FailureDetectorTimeout </span><span class="cov0" title="0">{
                        connectedNodes++
                }</span>
        }
        <span class="cov0" title="0">ds.nodesMutex.RUnlock()
        
        if totalNodes == 0 </span><span class="cov0" title="0">{
                return CheckResult{
                        Status:  "warning",
                        Message: "no other nodes in cluster",
                        Latency: time.Since(start).Milliseconds(),
                        Time:    time.Now(),
                }
        }</span>
        
        <span class="cov0" title="0">connectivity := float64(connectedNodes) / float64(totalNodes)
        if connectivity &gt;= 0.8 </span><span class="cov0" title="0">{
                return CheckResult{
                        Status:  "ok",
                        Message: fmt.Sprintf("%.1f%% nodes connected", connectivity*100),
                        Latency: time.Since(start).Milliseconds(),
                        Time:    time.Now(),
                }
        }</span>
        
        <span class="cov0" title="0">return CheckResult{
                Status:  "error",
                Message: fmt.Sprintf("poor connectivity: %.1f%% nodes connected", connectivity*100),
                Latency: time.Since(start).Milliseconds(),
                Time:    time.Now(),
        }</span>
}

func (ds *DistributedStorageImpl) checkReplicationHealth() CheckResult <span class="cov0" title="0">{
        start := time.Now()
        
        ds.replicationMgr.replicasMutex.RLock()
        totalReplicas := 0
        healthyReplicas := 0
        
        for _, status := range ds.replicationMgr.replicas </span><span class="cov0" title="0">{
                totalReplicas += status.CurrentReplicas
                healthyReplicas += status.HealthyReplicas
        }</span>
        <span class="cov0" title="0">ds.replicationMgr.replicasMutex.RUnlock()
        
        if totalReplicas == 0 </span><span class="cov0" title="0">{
                return CheckResult{
                        Status:  "ok",
                        Message: "no replicated objects",
                        Latency: time.Since(start).Milliseconds(),
                        Time:    time.Now(),
                }
        }</span>
        
        <span class="cov0" title="0">healthRatio := float64(healthyReplicas) / float64(totalReplicas)
        if healthRatio &gt;= 0.9 </span><span class="cov0" title="0">{
                return CheckResult{
                        Status:  "ok",
                        Message: fmt.Sprintf("%.1f%% replicas healthy", healthRatio*100),
                        Latency: time.Since(start).Milliseconds(),
                        Time:    time.Now(),
                }
        }</span>
        
        <span class="cov0" title="0">return CheckResult{
                Status:  "warning",
                Message: fmt.Sprintf("%.1f%% replicas healthy", healthRatio*100),
                Latency: time.Since(start).Milliseconds(),
                Time:    time.Now(),
        }</span>
}

func (ds *DistributedStorageImpl) getReplicationStats() *ReplicationStats <span class="cov0" title="0">{
        ds.replicationMgr.replicasMutex.RLock()
        defer ds.replicationMgr.replicasMutex.RUnlock()
        
        stats := &amp;ReplicationStats{
                ReplicationLag: make(map[string]int64),
                SyncOperations: &amp;SyncStats{},
        }
        
        for _, status := range ds.replicationMgr.replicas </span><span class="cov0" title="0">{
                stats.TotalReplicas += int64(status.CurrentReplicas)
                stats.HealthyReplicas += int64(status.HealthyReplicas)
                stats.OutOfSyncReplicas += int64(status.CurrentReplicas - status.HealthyReplicas)
        }</span>
        
        <span class="cov0" title="0">return stats</span>
}

// Background routines

func (ds *DistributedStorageImpl) heartbeatRoutine() <span class="cov0" title="0">{
        ticker := time.NewTicker(ds.config.HeartbeatInterval)
        defer ticker.Stop()
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ds.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        ds.sendHeartbeats()</span>
                }
        }
}

func (ds *DistributedStorageImpl) consensusMonitorRoutine() <span class="cov0" title="0">{
        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ds.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        ds.updateConsensusState()</span>
                }
        }
}

func (ds *DistributedStorageImpl) metricsCollectionRoutine() <span class="cov0" title="0">{
        ticker := time.NewTicker(1 * time.Minute)
        defer ticker.Stop()
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ds.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        ds.collectDistributedMetrics()</span>
                }
        }
}

func (ds *DistributedStorageImpl) failureDetectorRoutine() <span class="cov0" title="0">{
        ticker := time.NewTicker(ds.config.FailureDetectorTimeout / 2)
        defer ticker.Stop()
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ds.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        ds.detectFailedNodes()</span>
                }
        }
}

func (ds *DistributedStorageImpl) sendHeartbeats() <span class="cov0" title="0">{
        // TODO: Implement heartbeat sending to peers
        ds.logger.Debug("sending heartbeats")
}</span>

func (ds *DistributedStorageImpl) updateConsensusState() <span class="cov0" title="0">{
        ds.consensusMutex.Lock()
        defer ds.consensusMutex.Unlock()
        
        ds.consensusState.LastHeartbeat = time.Now()
        ds.consensusState.Term = 1
        ds.consensusState.CommitIndex = 100
        ds.consensusState.LastApplied = 100
        ds.consensusState.LeaderID = ds.nodeID
}</span>

func (ds *DistributedStorageImpl) collectDistributedMetrics() <span class="cov0" title="0">{
        ds.metricsMutex.Lock()
        defer ds.metricsMutex.Unlock()
        
        // Update cluster metrics
        ds.nodesMutex.RLock()
        ds.metrics.ClusterSize = len(ds.nodes) + 1 // Include self
        healthyNodes := 1 // Self is always healthy
        for _, node := range ds.nodes </span><span class="cov0" title="0">{
                if time.Since(node.LastSeen) &lt; ds.config.FailureDetectorTimeout </span><span class="cov0" title="0">{
                        healthyNodes++
                }</span>
        }
        <span class="cov0" title="0">ds.metrics.HealthyNodes = healthyNodes
        ds.nodesMutex.RUnlock()
        
        // Update replication factor
        if ds.metrics.ClusterSize &gt; 0 </span><span class="cov0" title="0">{
                ds.metrics.ReplicationFactor = float64(ds.config.ReplicationFactor)
        }</span>
}

func (ds *DistributedStorageImpl) detectFailedNodes() <span class="cov0" title="0">{
        ds.nodesMutex.Lock()
        defer ds.nodesMutex.Unlock()
        
        cutoff := time.Now().Add(-ds.config.FailureDetectorTimeout)
        for nodeID, node := range ds.nodes </span><span class="cov0" title="0">{
                if node.LastSeen.Before(cutoff) </span><span class="cov0" title="0">{
                        ds.logger.Warn("node appears to have failed", "node_id", nodeID, "last_seen", node.LastSeen)
                        node.Status = "failed"
                }</span>
        }
}

// ReplicationManager methods

func (rm *ReplicationManager) removeReplicationStatus(key string) <span class="cov0" title="0">{
        rm.replicasMutex.Lock()
        defer rm.replicasMutex.Unlock()
        
        delete(rm.replicas, key)
}</span>

// ReplicationWorker methods

func (w *ReplicationWorker) start() <span class="cov0" title="0">{
        w.logger.Info("replication worker started", "worker_id", w.id)
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-w.manager.ctx.Done():<span class="cov0" title="0">
                        w.logger.Info("replication worker stopped", "worker_id", w.id)
                        return</span>
                case task := &lt;-w.manager.workQueue:<span class="cov0" title="0">
                        w.processTask(task)</span>
                }
        }
}

func (w *ReplicationWorker) processTask(task *ReplicationTask) <span class="cov0" title="0">{
        w.logger.Debug("processing replication task", "worker_id", w.id, "type", task.Type, "key", task.Key)
        
        // TODO: Implement actual replication logic
        // This would involve network communication with target nodes
        
        time.Sleep(100 * time.Millisecond) // Simulate work
}</span>

// DistributedLock methods

func (dl *DistributedLock) Release() error <span class="cov0" title="0">{
        dl.mutex.Lock()
        defer dl.mutex.Unlock()
        
        if dl.released </span><span class="cov0" title="0">{
                return &amp;StorageError{
                        Code:    ErrCodeInvalidArgument,
                        Message: "lock already released",
                }
        }</span>
        
        <span class="cov0" title="0">dl.storage.locksMutex.Lock()
        delete(dl.storage.locks, dl.lockID)
        dl.storage.locksMutex.Unlock()
        
        dl.released = true
        return nil</span>
}

func (dl *DistributedLock) Renew(timeout time.Duration) error <span class="cov0" title="0">{
        dl.mutex.Lock()
        defer dl.mutex.Unlock()
        
        if dl.released </span><span class="cov0" title="0">{
                return &amp;StorageError{
                        Code:    ErrCodeInvalidArgument,
                        Message: "cannot renew released lock",
                }
        }</span>
        
        <span class="cov0" title="0">dl.expiration = time.Now().Add(timeout)
        return nil</span>
}

func (dl *DistributedLock) IsHeld() bool <span class="cov0" title="0">{
        dl.mutex.Lock()
        defer dl.mutex.Unlock()
        
        return !dl.released &amp;&amp; time.Now().Before(dl.expiration)
}</span>

func (dl *DistributedLock) GetOwner() string <span class="cov0" title="0">{
        return dl.owner
}</span>

func (dl *DistributedLock) GetExpiration() time.Time <span class="cov0" title="0">{
        dl.mutex.Lock()
        defer dl.mutex.Unlock()
        
        return dl.expiration
}</pre>
		
		<pre class="file" id="file9" style="display: none">package storage

import (
        "context"
        "fmt"
        "io"
        "time"
)

// Storage defines the interface for distributed storage operations
type Storage interface {
        // Core storage operations
        Store(ctx context.Context, key string, data io.Reader, metadata *ObjectMetadata) error
        Retrieve(ctx context.Context, key string) (io.ReadCloser, *ObjectMetadata, error)
        Delete(ctx context.Context, key string) error
        Exists(ctx context.Context, key string) (bool, error)
        
        // Metadata operations
        GetMetadata(ctx context.Context, key string) (*ObjectMetadata, error)
        SetMetadata(ctx context.Context, key string, metadata *ObjectMetadata) error
        UpdateMetadata(ctx context.Context, key string, updates map[string]interface{}) error
        
        // Batch operations
        BatchStore(ctx context.Context, operations []BatchStoreOperation) error
        BatchDelete(ctx context.Context, keys []string) error
        
        // Listing and iteration
        List(ctx context.Context, prefix string, options *ListOptions) (*ListResult, error)
        ListKeys(ctx context.Context, prefix string) ([]string, error)
        
        // Health and monitoring
        HealthCheck(ctx context.Context) (*HealthStatus, error)
        GetStats(ctx context.Context) (*StorageStats, error)
        
        // Lifecycle management
        Start(ctx context.Context) error
        Stop(ctx context.Context) error
        Close() error
}

// DistributedStorage extends Storage with distributed-specific operations
type DistributedStorage interface {
        Storage
        
        // Replication operations
        Replicate(ctx context.Context, key string, targetNodes []string) error
        GetReplicationStatus(ctx context.Context, key string) (*ReplicationStatus, error)
        SetReplicationPolicy(ctx context.Context, key string, policy *ReplicationPolicy) error
        
        // Consensus and coordination
        ProposeWrite(ctx context.Context, key string, data io.Reader, metadata *ObjectMetadata) error
        ProposeDelete(ctx context.Context, key string) error
        GetConsensusState(ctx context.Context) (*ConsensusState, error)
        
        // Node management
        AddNode(ctx context.Context, nodeID string, nodeInfo *NodeInfo) error
        RemoveNode(ctx context.Context, nodeID string) error
        GetNodes(ctx context.Context) ([]*NodeInfo, error)
        
        // Distributed coordination
        AcquireLock(ctx context.Context, lockID string, timeout time.Duration) (Lock, error)
        GetDistributedMetrics(ctx context.Context) (*DistributedMetrics, error)
}

// ModelStorage defines storage operations specific to AI models
type ModelStorage interface {
        Storage
        
        // Model-specific operations
        StoreModel(ctx context.Context, modelID string, modelData io.Reader, config *ModelConfig) error
        RetrieveModel(ctx context.Context, modelID string) (io.ReadCloser, *ModelConfig, error)
        DeleteModel(ctx context.Context, modelID string) error
        
        // Model metadata and versioning
        GetModelVersions(ctx context.Context, modelID string) ([]*ModelVersion, error)
        GetModelConfig(ctx context.Context, modelID string) (*ModelConfig, error)
        SetModelConfig(ctx context.Context, modelID string, config *ModelConfig) error
        
        // Model lifecycle
        ArchiveModel(ctx context.Context, modelID string) error
        RestoreModel(ctx context.Context, modelID string) error
        GetArchivedModels(ctx context.Context) ([]*ArchivedModel, error)
}

// BackupStorage defines backup and recovery operations
type BackupStorage interface {
        // Backup operations
        CreateBackup(ctx context.Context, backupID string, options *BackupOptions) error
        RestoreBackup(ctx context.Context, backupID string, options *RestoreOptions) error
        DeleteBackup(ctx context.Context, backupID string) error
        
        // Backup management
        ListBackups(ctx context.Context) ([]*BackupInfo, error)
        GetBackupInfo(ctx context.Context, backupID string) (*BackupInfo, error)
        VerifyBackup(ctx context.Context, backupID string) (*BackupVerification, error)
        
        // Incremental backup support
        CreateIncrementalBackup(ctx context.Context, backupID string, baseBackupID string, options *BackupOptions) error
        GetBackupChain(ctx context.Context, backupID string) ([]*BackupInfo, error)
}

// Lock represents a distributed lock
type Lock interface {
        Release() error
        Renew(timeout time.Duration) error
        IsHeld() bool
        GetOwner() string
        GetExpiration() time.Time
}

// ObjectMetadata contains metadata for stored objects
type ObjectMetadata struct {
        Key         string                 `json:"key"`
        Size        int64                  `json:"size"`
        ContentType string                 `json:"content_type"`
        Hash        string                 `json:"hash"`
        CreatedAt   time.Time              `json:"created_at"`
        UpdatedAt   time.Time              `json:"updated_at"`
        AccessedAt  time.Time              `json:"accessed_at"`
        Version     string                 `json:"version"`
        Attributes  map[string]interface{} `json:"attributes"`
        
        // Replication metadata
        ReplicationPolicy *ReplicationPolicy `json:"replication_policy,omitempty"`
        ReplicationNodes  []string           `json:"replication_nodes,omitempty"`
        
        // Model-specific metadata
        ModelInfo *ModelMetadata `json:"model_info,omitempty"`
}

// ModelMetadata contains AI model specific metadata
type ModelMetadata struct {
        ModelID     string            `json:"model_id"`
        ModelType   string            `json:"model_type"`
        Format      string            `json:"format"`
        Parameters  map[string]string `json:"parameters"`
        Tags        []string          `json:"tags"`
        Description string            `json:"description"`
        Author      string            `json:"author"`
        License     string            `json:"license"`
}

// BatchStoreOperation represents a batch store operation
type BatchStoreOperation struct {
        Key      string          `json:"key"`
        Data     io.Reader       `json:"-"`
        Metadata *ObjectMetadata `json:"metadata"`
}

// ListOptions contains options for listing operations
type ListOptions struct {
        Limit        int    `json:"limit"`
        Continuation string `json:"continuation"`
        Recursive    bool   `json:"recursive"`
        IncludeSize  bool   `json:"include_size"`
        SortBy       string `json:"sort_by"`
        SortOrder    string `json:"sort_order"`
}

// ListResult contains the result of a list operation
type ListResult struct {
        Items        []*ObjectMetadata `json:"items"`
        Continuation string            `json:"continuation"`
        Total        int64             `json:"total"`
        HasMore      bool              `json:"has_more"`
}

// HealthStatus represents the health status of storage
type HealthStatus struct {
        Status     string                 `json:"status"`
        Healthy    bool                   `json:"healthy"`
        LastCheck  time.Time              `json:"last_check"`
        Checks     map[string]CheckResult `json:"checks"`
        NodeHealth map[string]NodeHealth  `json:"node_health,omitempty"`
}

// CheckResult represents the result of a health check
type CheckResult struct {
        Status  string    `json:"status"`
        Message string    `json:"message"`
        Latency int64     `json:"latency_ms"`
        Time    time.Time `json:"time"`
}

// NodeHealth represents the health of a storage node
type NodeHealth struct {
        NodeID      string    `json:"node_id"`
        Status      string    `json:"status"`
        LastSeen    time.Time `json:"last_seen"`
        Latency     int64     `json:"latency_ms"`
        StorageUsed int64     `json:"storage_used"`
        StorageTotal int64    `json:"storage_total"`
}

// StorageStats contains storage statistics
type StorageStats struct {
        TotalObjects    int64             `json:"total_objects"`
        TotalSize       int64             `json:"total_size"`
        UsedSpace       int64             `json:"used_space"`
        AvailableSpace  int64             `json:"available_space"`
        OperationCounts map[string]int64  `json:"operation_counts"`
        Performance     *PerformanceStats `json:"performance"`
        Replication     *ReplicationStats `json:"replication,omitempty"`
}

// PerformanceStats contains performance metrics
type PerformanceStats struct {
        ReadLatency   *LatencyStats `json:"read_latency"`
        WriteLatency  *LatencyStats `json:"write_latency"`
        DeleteLatency *LatencyStats `json:"delete_latency"`
        Throughput    *Throughput   `json:"throughput"`
}

// LatencyStats contains latency statistics
type LatencyStats struct {
        Min     int64   `json:"min_ms"`
        Max     int64   `json:"max_ms"`
        Mean    float64 `json:"mean_ms"`
        Median  int64   `json:"median_ms"`
        P95     int64   `json:"p95_ms"`
        P99     int64   `json:"p99_ms"`
        Samples int64   `json:"samples"`
}

// Throughput contains throughput metrics
type Throughput struct {
        ReadOpsPerSec   float64 `json:"read_ops_per_sec"`
        WriteOpsPerSec  float64 `json:"write_ops_per_sec"`
        DeleteOpsPerSec float64 `json:"delete_ops_per_sec"`
        ReadBytesPerSec int64   `json:"read_bytes_per_sec"`
        WriteBytesPerSec int64  `json:"write_bytes_per_sec"`
}

// ReplicationPolicy defines how objects should be replicated
type ReplicationPolicy struct {
        MinReplicas      int                    `json:"min_replicas"`
        MaxReplicas      int                    `json:"max_replicas"`
        PreferredNodes   []string               `json:"preferred_nodes"`
        ExcludedNodes    []string               `json:"excluded_nodes"`
        ConsistencyLevel string                 `json:"consistency_level"` // strong, eventual, weak
        Strategy         string                 `json:"strategy"`          // eager, lazy, on_demand
        Priority         int                    `json:"priority"`
        Constraints      map[string]interface{} `json:"constraints"`
}

// ReplicationStatus represents the status of object replication
type ReplicationStatus struct {
        Key              string            `json:"key"`
        Policy           *ReplicationPolicy `json:"policy"`
        CurrentReplicas  int               `json:"current_replicas"`
        HealthyReplicas  int               `json:"healthy_replicas"`
        ReplicaNodes     []string          `json:"replica_nodes"`
        SyncStatus       map[string]string `json:"sync_status"`
        LastSync         time.Time         `json:"last_sync"`
        ConsistencyCheck time.Time         `json:"consistency_check"`
}

// ReplicationStats contains replication statistics
type ReplicationStats struct {
        TotalReplicas     int64             `json:"total_replicas"`
        HealthyReplicas   int64             `json:"healthy_replicas"`
        OutOfSyncReplicas int64             `json:"out_of_sync_replicas"`
        ReplicationLag    map[string]int64  `json:"replication_lag_ms"`
        SyncOperations    *SyncStats        `json:"sync_operations"`
}

// SyncStats contains synchronization statistics
type SyncStats struct {
        SuccessfulSyncs int64 `json:"successful_syncs"`
        FailedSyncs     int64 `json:"failed_syncs"`
        PendingSyncs    int64 `json:"pending_syncs"`
        AverageSyncTime int64 `json:"average_sync_time_ms"`
}

// ConsensusState represents the state of distributed consensus
type ConsensusState struct {
        LeaderID       string            `json:"leader_id"`
        Term           int64             `json:"term"`
        CommitIndex    int64             `json:"commit_index"`
        LastApplied    int64             `json:"last_applied"`
        Nodes          map[string]string `json:"nodes"` // nodeID -&gt; status
        QuorumSize     int               `json:"quorum_size"`
        IsHealthy      bool              `json:"is_healthy"`
        LastHeartbeat  time.Time         `json:"last_heartbeat"`
}

// NodeInfo contains information about a storage node
type NodeInfo struct {
        NodeID       string                 `json:"node_id"`
        Address      string                 `json:"address"`
        Port         int                    `json:"port"`
        Region       string                 `json:"region"`
        Zone         string                 `json:"zone"`
        Capacity     int64                  `json:"capacity"`
        Used         int64                  `json:"used"`
        Available    int64                  `json:"available"`
        Status       string                 `json:"status"`
        Capabilities []string               `json:"capabilities"`
        Metadata     map[string]interface{} `json:"metadata"`
        JoinedAt     time.Time              `json:"joined_at"`
        LastSeen     time.Time              `json:"last_seen"`
}

// DistributedMetrics contains distributed storage metrics
type DistributedMetrics struct {
        ClusterSize       int                    `json:"cluster_size"`
        HealthyNodes      int                    `json:"healthy_nodes"`
        TotalCapacity     int64                  `json:"total_capacity"`
        UsedCapacity      int64                  `json:"used_capacity"`
        ReplicationFactor float64                `json:"replication_factor"`
        DataDistribution  map[string]int64       `json:"data_distribution"`
        NetworkMetrics    *NetworkMetrics        `json:"network_metrics"`
        ConsensusMetrics  *ConsensusMetrics      `json:"consensus_metrics"`
}

// NetworkMetrics contains network-related metrics
type NetworkMetrics struct {
        AverageLatency    int64            `json:"average_latency_ms"`
        TotalBandwidth    int64            `json:"total_bandwidth_bps"`
        UsedBandwidth     int64            `json:"used_bandwidth_bps"`
        NetworkErrors     int64            `json:"network_errors"`
        ConnectionCounts  map[string]int64 `json:"connection_counts"`
}

// ConsensusMetrics contains consensus-related metrics
type ConsensusMetrics struct {
        LeaderElections    int64 `json:"leader_elections"`
        TermsCompleted     int64 `json:"terms_completed"`
        ProposalsSubmitted int64 `json:"proposals_submitted"`
        ProposalsCommitted int64 `json:"proposals_committed"`
        ConsensuLatency    int64 `json:"consensus_latency_ms"`
}

// ModelConfig contains configuration for AI models
type ModelConfig struct {
        ModelID      string                 `json:"model_id"`
        Name         string                 `json:"name"`
        Description  string                 `json:"description"`
        Version      string                 `json:"version"`
        Type         string                 `json:"type"`
        Format       string                 `json:"format"`
        Size         int64                  `json:"size"`
        Hash         string                 `json:"hash"`
        Parameters   map[string]interface{} `json:"parameters"`
        Metadata     map[string]interface{} `json:"metadata"`
        Dependencies []string               `json:"dependencies"`
        CreatedAt    time.Time              `json:"created_at"`
        UpdatedAt    time.Time              `json:"updated_at"`
}

// ModelVersion represents a version of a model
type ModelVersion struct {
        Version   string    `json:"version"`
        Hash      string    `json:"hash"`
        Size      int64     `json:"size"`
        Changes   []string  `json:"changes"`
        CreatedAt time.Time `json:"created_at"`
        IsActive  bool      `json:"is_active"`
}

// ArchivedModel represents an archived model
type ArchivedModel struct {
        ModelID     string    `json:"model_id"`
        ArchiveID   string    `json:"archive_id"`
        ArchivePath string    `json:"archive_path"`
        OriginalSize int64    `json:"original_size"`
        CompressedSize int64  `json:"compressed_size"`
        ArchivedAt  time.Time `json:"archived_at"`
        Reason      string    `json:"reason"`
}

// BackupOptions contains options for backup operations
type BackupOptions struct {
        Compression    string            `json:"compression"`
        Encryption     bool              `json:"encryption"`
        IncludeIndex   bool              `json:"include_index"`
        IncludeMetadata bool             `json:"include_metadata"`
        Filters        []string          `json:"filters"`
        ChunkSize      int64             `json:"chunk_size"`
        Parallel       bool              `json:"parallel"`
        Metadata       map[string]string `json:"metadata"`
}

// RestoreOptions contains options for restore operations
type RestoreOptions struct {
        OverwriteExisting bool              `json:"overwrite_existing"`
        VerifyIntegrity   bool              `json:"verify_integrity"`
        RestoreMetadata   bool              `json:"restore_metadata"`
        RestoreIndex      bool              `json:"restore_index"`
        Filters           []string          `json:"filters"`
        TargetPath        string            `json:"target_path"`
        Parallel          bool              `json:"parallel"`
        Metadata          map[string]string `json:"metadata"`
}

// BackupInfo contains information about a backup
type BackupInfo struct {
        BackupID      string    `json:"backup_id"`
        BaseBackupID  string    `json:"base_backup_id,omitempty"`
        Type          string    `json:"type"` // full, incremental
        Status        string    `json:"status"`
        Size          int64     `json:"size"`
        CompressedSize int64    `json:"compressed_size"`
        ObjectCount   int64     `json:"object_count"`
        CreatedAt     time.Time `json:"created_at"`
        CompletedAt   time.Time `json:"completed_at"`
        ExpiresAt     time.Time `json:"expires_at"`
        Metadata      map[string]string `json:"metadata"`
        Checksums     map[string]string `json:"checksums"`
}

// BackupVerification contains the result of backup verification
type BackupVerification struct {
        BackupID    string            `json:"backup_id"`
        IsValid     bool              `json:"is_valid"`
        Errors      []string          `json:"errors"`
        Warnings    []string          `json:"warnings"`
        CheckedAt   time.Time         `json:"checked_at"`
        Checksums   map[string]string `json:"checksums"`
        ObjectCount int64             `json:"object_count"`
        TotalSize   int64             `json:"total_size"`
}

// StorageError represents storage operation errors
type StorageError struct {
        Code      string `json:"code"`
        Message   string `json:"message"`
        Operation string `json:"operation"`
        Key       string `json:"key,omitempty"`
        Cause     error  `json:"-"`
}

func (e *StorageError) Error() string <span class="cov0" title="0">{
        if e.Cause != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s: %s (caused by: %v)", e.Code, e.Message, e.Cause)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s: %s", e.Code, e.Message)</span>
}

func (e *StorageError) Unwrap() error <span class="cov0" title="0">{
        return e.Cause
}</span>

// Common error codes
const (
        ErrCodeNotFound         = "NOT_FOUND"
        ErrCodeAlreadyExists    = "ALREADY_EXISTS"
        ErrCodePermissionDenied = "PERMISSION_DENIED"
        ErrCodeQuotaExceeded    = "QUOTA_EXCEEDED"
        ErrCodeInvalidArgument  = "INVALID_ARGUMENT"
        ErrCodeInternal         = "INTERNAL_ERROR"
        ErrCodeUnavailable      = "UNAVAILABLE"
        ErrCodeTimeout          = "TIMEOUT"
        ErrCodeCorrupted        = "CORRUPTED"
        ErrCodeConsistency      = "CONSISTENCY_ERROR"
)</pre>
		
		<pre class="file" id="file10" style="display: none">package storage

import (
        "context"
        "crypto/sha256"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "sort"
        "strings"
        "sync"
        "time"

        "log/slog"
)

// LocalStorage implements Storage interface for local filesystem storage
type LocalStorage struct {
        basePath    string
        metaPath    string
        logger      *slog.Logger
        
        // Configuration
        maxSize     int64
        compression bool
        encryption  bool
        
        // Caching and performance
        metadataCache map[string]*ObjectMetadata
        cacheMutex    sync.RWMutex
        cacheSize     int
        maxCacheSize  int
        
        // Statistics
        stats       *StorageStats
        statsMutex  sync.RWMutex
        
        // File locks for concurrent access
        fileLocks   map[string]*sync.RWMutex
        locksMutex  sync.RWMutex
        
        // Health monitoring
        lastHealthCheck time.Time
        healthy         bool
        
        // Background tasks
        ctx         context.Context
        cancel      context.CancelFunc
        started     bool
        mu          sync.RWMutex
}

// LocalStorageConfig contains configuration for local storage
type LocalStorageConfig struct {
        BasePath      string `json:"base_path"`
        MaxSize       int64  `json:"max_size"`
        Compression   bool   `json:"compression"`
        Encryption    bool   `json:"encryption"`
        MaxCacheSize  int    `json:"max_cache_size"`
        CleanupAge    time.Duration `json:"cleanup_age"`
        SyncWrites    bool   `json:"sync_writes"`
}

// NewLocalStorage creates a new local storage instance
func NewLocalStorage(config *LocalStorageConfig, logger *slog.Logger) (*LocalStorage, error) <span class="cov8" title="1">{
        if config.BasePath == "" </span><span class="cov0" title="0">{
                return nil, &amp;StorageError{
                        Code:    ErrCodeInvalidArgument,
                        Message: "base path cannot be empty",
                }
        }</span>
        
        // Create base directories
        <span class="cov8" title="1">if err := os.MkdirAll(config.BasePath, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, &amp;StorageError{
                        Code:    ErrCodeInternal,
                        Message: "failed to create base directory",
                        Cause:   err,
                }
        }</span>
        
        <span class="cov8" title="1">metaPath := filepath.Join(config.BasePath, "metadata")
        if err := os.MkdirAll(metaPath, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, &amp;StorageError{
                        Code:    ErrCodeInternal,
                        Message: "failed to create metadata directory",
                        Cause:   err,
                }
        }</span>
        
        <span class="cov8" title="1">ctx, cancel := context.WithCancel(context.Background())
        
        ls := &amp;LocalStorage{
                basePath:      config.BasePath,
                metaPath:      metaPath,
                logger:        logger,
                maxSize:       config.MaxSize,
                compression:   config.Compression,
                encryption:    config.Encryption,
                metadataCache: make(map[string]*ObjectMetadata),
                maxCacheSize:  config.MaxCacheSize,
                fileLocks:     make(map[string]*sync.RWMutex),
                stats: &amp;StorageStats{
                        OperationCounts: make(map[string]int64),
                        Performance: &amp;PerformanceStats{
                                ReadLatency:   &amp;LatencyStats{},
                                WriteLatency:  &amp;LatencyStats{},
                                DeleteLatency: &amp;LatencyStats{},
                                Throughput:    &amp;Throughput{},
                        },
                },
                ctx:     ctx,
                cancel:  cancel,
                healthy: true,
        }
        
        // Load existing metadata into cache
        if err := ls.loadMetadataCache(); err != nil </span><span class="cov0" title="0">{
                logger.Warn("failed to load metadata cache", "error", err)
        }</span>
        
        <span class="cov8" title="1">return ls, nil</span>
}

// Start starts the local storage
func (ls *LocalStorage) Start(ctx context.Context) error <span class="cov8" title="1">{
        ls.mu.Lock()
        defer ls.mu.Unlock()
        
        if ls.started </span><span class="cov0" title="0">{
                return &amp;StorageError{
                        Code:    ErrCodeInternal,
                        Message: "storage already started",
                }
        }</span>
        
        // Start background cleanup routine
        <span class="cov8" title="1">go ls.cleanupRoutine()
        
        // Start health monitoring
        go ls.healthMonitorRoutine()
        
        // Start statistics collection
        go ls.statsCollectionRoutine()
        
        ls.started = true
        ls.logger.Info("local storage started", "base_path", ls.basePath)
        
        return nil</span>
}

// Stop stops the local storage
func (ls *LocalStorage) Stop(ctx context.Context) error <span class="cov8" title="1">{
        ls.mu.Lock()
        defer ls.mu.Unlock()
        
        if !ls.started </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov8" title="1">ls.cancel()
        ls.started = false
        
        // Save metadata cache
        if err := ls.saveMetadataCache(); err != nil </span><span class="cov0" title="0">{
                ls.logger.Error("failed to save metadata cache", "error", err)
        }</span>
        
        <span class="cov8" title="1">ls.logger.Info("local storage stopped")
        return nil</span>
}

// Close closes the local storage
func (ls *LocalStorage) Close() error <span class="cov8" title="1">{
        return ls.Stop(context.Background())
}</span>

// Store stores an object in local storage
func (ls *LocalStorage) Store(ctx context.Context, key string, data io.Reader, metadata *ObjectMetadata) error <span class="cov8" title="1">{
        start := time.Now()
        defer func() </span><span class="cov8" title="1">{
                ls.updateLatencyStats("write", time.Since(start))
                ls.incrementOperationCount("store")
        }</span>()
        
        <span class="cov8" title="1">if err := ls.validateKey(key); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // Get file lock
        <span class="cov8" title="1">lock := ls.getFileLock(key)
        lock.Lock()
        defer lock.Unlock()
        
        // Create object path
        objPath := ls.getObjectPath(key)
        if err := os.MkdirAll(filepath.Dir(objPath), 0755); err != nil </span><span class="cov0" title="0">{
                return &amp;StorageError{
                        Code:      ErrCodeInternal,
                        Message:   "failed to create object directory",
                        Operation: "store",
                        Key:       key,
                        Cause:     err,
                }
        }</span>
        
        // Create temporary file for atomic write
        <span class="cov8" title="1">tempPath := objPath + ".tmp"
        tempFile, err := os.Create(tempPath)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;StorageError{
                        Code:      ErrCodeInternal,
                        Message:   "failed to create temporary file",
                        Operation: "store",
                        Key:       key,
                        Cause:     err,
                }
        }</span>
        <span class="cov8" title="1">defer os.Remove(tempPath) // Cleanup on error
        
        // Copy data and calculate hash
        hash := sha256.New()
        size, err := io.Copy(io.MultiWriter(tempFile, hash), data)
        if err != nil </span><span class="cov0" title="0">{
                tempFile.Close()
                return &amp;StorageError{
                        Code:      ErrCodeInternal,
                        Message:   "failed to write data",
                        Operation: "store",
                        Key:       key,
                        Cause:     err,
                }
        }</span>
        
        <span class="cov8" title="1">if err := tempFile.Sync(); err != nil </span><span class="cov0" title="0">{
                tempFile.Close()
                return &amp;StorageError{
                        Code:      ErrCodeInternal,
                        Message:   "failed to sync file",
                        Operation: "store",
                        Key:       key,
                        Cause:     err,
                }
        }</span>
        <span class="cov8" title="1">tempFile.Close()
        
        // Check size limits
        if ls.maxSize &gt; 0 &amp;&amp; size &gt; ls.maxSize </span><span class="cov0" title="0">{
                return &amp;StorageError{
                        Code:      ErrCodeQuotaExceeded,
                        Message:   "object size exceeds maximum allowed size",
                        Operation: "store",
                        Key:       key,
                }
        }</span>
        
        // Prepare metadata
        <span class="cov8" title="1">now := time.Now()
        if metadata == nil </span><span class="cov8" title="1">{
                metadata = &amp;ObjectMetadata{}
        }</span>
        <span class="cov8" title="1">metadata.Key = key
        metadata.Size = size
        metadata.Hash = hex.EncodeToString(hash.Sum(nil))
        metadata.CreatedAt = now
        metadata.UpdatedAt = now
        metadata.AccessedAt = now
        
        // Atomic move
        if err := os.Rename(tempPath, objPath); err != nil </span><span class="cov0" title="0">{
                return &amp;StorageError{
                        Code:      ErrCodeInternal,
                        Message:   "failed to move temporary file",
                        Operation: "store",
                        Key:       key,
                        Cause:     err,
                }
        }</span>
        
        // Store metadata
        <span class="cov8" title="1">if err := ls.storeMetadata(key, metadata); err != nil </span><span class="cov0" title="0">{
                // Try to cleanup object file
                os.Remove(objPath)
                return err
        }</span>
        
        // Update cache
        <span class="cov8" title="1">ls.updateMetadataCache(key, metadata)
        
        // Update statistics
        ls.statsMutex.Lock()
        ls.stats.TotalObjects++
        ls.stats.TotalSize += size
        ls.stats.UsedSpace += size
        ls.statsMutex.Unlock()
        
        ls.logger.Debug("object stored", "key", key, "size", size, "hash", metadata.Hash)
        return nil</span>
}

// Retrieve retrieves an object from local storage
func (ls *LocalStorage) Retrieve(ctx context.Context, key string) (io.ReadCloser, *ObjectMetadata, error) <span class="cov8" title="1">{
        start := time.Now()
        defer func() </span><span class="cov8" title="1">{
                ls.updateLatencyStats("read", time.Since(start))
                ls.incrementOperationCount("retrieve")
        }</span>()
        
        <span class="cov8" title="1">if err := ls.validateKey(key); err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        
        // Get metadata first
        <span class="cov8" title="1">metadata, err := ls.GetMetadata(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        
        // Open object file
        <span class="cov8" title="1">objPath := ls.getObjectPath(key)
        file, err := os.Open(objPath)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return nil, nil, &amp;StorageError{
                                Code:      ErrCodeNotFound,
                                Message:   "object not found",
                                Operation: "retrieve",
                                Key:       key,
                        }
                }</span>
                <span class="cov0" title="0">return nil, nil, &amp;StorageError{
                        Code:      ErrCodeInternal,
                        Message:   "failed to open object file",
                        Operation: "retrieve",
                        Key:       key,
                        Cause:     err,
                }</span>
        }
        
        // Update access time
        <span class="cov8" title="1">metadata.AccessedAt = time.Now()
        ls.updateMetadataCache(key, metadata)
        go ls.storeMetadata(key, metadata) // Async update
        
        return file, metadata, nil</span>
}

// Delete deletes an object from local storage
func (ls *LocalStorage) Delete(ctx context.Context, key string) error <span class="cov8" title="1">{
        start := time.Now()
        defer func() </span><span class="cov8" title="1">{
                ls.updateLatencyStats("delete", time.Since(start))
                ls.incrementOperationCount("delete")
        }</span>()
        
        <span class="cov8" title="1">if err := ls.validateKey(key); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // Get file lock
        <span class="cov8" title="1">lock := ls.getFileLock(key)
        lock.Lock()
        defer lock.Unlock()
        
        // Get metadata for size accounting
        metadata, err := ls.GetMetadata(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                if isNotFoundError(err) </span><span class="cov0" title="0">{
                        return nil // Already deleted
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        
        // Delete object file
        <span class="cov8" title="1">objPath := ls.getObjectPath(key)
        if err := os.Remove(objPath); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return &amp;StorageError{
                        Code:      ErrCodeInternal,
                        Message:   "failed to delete object file",
                        Operation: "delete",
                        Key:       key,
                        Cause:     err,
                }
        }</span>
        
        // Delete metadata
        <span class="cov8" title="1">metaPath := ls.getMetadataPath(key)
        if err := os.Remove(metaPath); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                ls.logger.Warn("failed to delete metadata file", "key", key, "error", err)
        }</span>
        
        // Remove from cache
        <span class="cov8" title="1">ls.removeFromMetadataCache(key)
        
        // Update statistics
        ls.statsMutex.Lock()
        ls.stats.TotalObjects--
        ls.stats.TotalSize -= metadata.Size
        ls.stats.UsedSpace -= metadata.Size
        ls.statsMutex.Unlock()
        
        ls.logger.Debug("object deleted", "key", key, "size", metadata.Size)
        return nil</span>
}

// Exists checks if an object exists in local storage
func (ls *LocalStorage) Exists(ctx context.Context, key string) (bool, error) <span class="cov8" title="1">{
        if err := ls.validateKey(key); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        
        <span class="cov8" title="1">objPath := ls.getObjectPath(key)
        _, err := os.Stat(objPath)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, &amp;StorageError{
                        Code:      ErrCodeInternal,
                        Message:   "failed to check object existence",
                        Operation: "exists",
                        Key:       key,
                        Cause:     err,
                }</span>
        }
        
        <span class="cov8" title="1">return true, nil</span>
}

// GetMetadata retrieves metadata for an object
func (ls *LocalStorage) GetMetadata(ctx context.Context, key string) (*ObjectMetadata, error) <span class="cov8" title="1">{
        if err := ls.validateKey(key); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // Check cache first
        <span class="cov8" title="1">if metadata := ls.getFromMetadataCache(key); metadata != nil </span><span class="cov8" title="1">{
                return metadata, nil
        }</span>
        
        // Load from disk
        <span class="cov0" title="0">metaPath := ls.getMetadataPath(key)
        data, err := os.ReadFile(metaPath)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return nil, &amp;StorageError{
                                Code:      ErrCodeNotFound,
                                Message:   "metadata not found",
                                Operation: "get_metadata",
                                Key:       key,
                        }
                }</span>
                <span class="cov0" title="0">return nil, &amp;StorageError{
                        Code:      ErrCodeInternal,
                        Message:   "failed to read metadata file",
                        Operation: "get_metadata",
                        Key:       key,
                        Cause:     err,
                }</span>
        }
        
        <span class="cov0" title="0">var metadata ObjectMetadata
        if err := json.Unmarshal(data, &amp;metadata); err != nil </span><span class="cov0" title="0">{
                return nil, &amp;StorageError{
                        Code:      ErrCodeInternal,
                        Message:   "failed to parse metadata",
                        Operation: "get_metadata",
                        Key:       key,
                        Cause:     err,
                }
        }</span>
        
        // Update cache
        <span class="cov0" title="0">ls.updateMetadataCache(key, &amp;metadata)
        
        return &amp;metadata, nil</span>
}

// SetMetadata sets metadata for an object
func (ls *LocalStorage) SetMetadata(ctx context.Context, key string, metadata *ObjectMetadata) error <span class="cov8" title="1">{
        if err := ls.validateKey(key); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">metadata.Key = key
        metadata.UpdatedAt = time.Now()
        
        if err := ls.storeMetadata(key, metadata); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">ls.updateMetadataCache(key, metadata)
        return nil</span>
}

// UpdateMetadata updates specific metadata fields
func (ls *LocalStorage) UpdateMetadata(ctx context.Context, key string, updates map[string]interface{}) error <span class="cov8" title="1">{
        metadata, err := ls.GetMetadata(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // Apply updates
        <span class="cov8" title="1">if metadata.Attributes == nil </span><span class="cov0" title="0">{
                metadata.Attributes = make(map[string]interface{})
        }</span>
        
        <span class="cov8" title="1">for field, value := range updates </span><span class="cov8" title="1">{
                switch field </span>{
                case "content_type":<span class="cov0" title="0">
                        if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                metadata.ContentType = v
                        }</span>
                case "version":<span class="cov8" title="1">
                        if v, ok := value.(string); ok </span><span class="cov8" title="1">{
                                metadata.Version = v
                        }</span>
                default:<span class="cov8" title="1">
                        metadata.Attributes[field] = value</span>
                }
        }
        
        <span class="cov8" title="1">return ls.SetMetadata(ctx, key, metadata)</span>
}

// BatchStore performs batch store operations
func (ls *LocalStorage) BatchStore(ctx context.Context, operations []BatchStoreOperation) error <span class="cov8" title="1">{
        var errors []error
        
        for _, op := range operations </span><span class="cov8" title="1">{
                if err := ls.Store(ctx, op.Key, op.Data, op.Metadata); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Errorf("failed to store %s: %w", op.Key, err))
                }</span>
        }
        
        <span class="cov8" title="1">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return &amp;StorageError{
                        Code:    ErrCodeInternal,
                        Message: fmt.Sprintf("batch store failed with %d errors", len(errors)),
                }
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

// BatchDelete performs batch delete operations
func (ls *LocalStorage) BatchDelete(ctx context.Context, keys []string) error <span class="cov8" title="1">{
        var errors []error
        
        for _, key := range keys </span><span class="cov8" title="1">{
                if err := ls.Delete(ctx, key); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Errorf("failed to delete %s: %w", key, err))
                }</span>
        }
        
        <span class="cov8" title="1">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return &amp;StorageError{
                        Code:    ErrCodeInternal,
                        Message: fmt.Sprintf("batch delete failed with %d errors", len(errors)),
                }
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

// List lists objects with optional prefix and pagination
func (ls *LocalStorage) List(ctx context.Context, prefix string, options *ListOptions) (*ListResult, error) <span class="cov8" title="1">{
        if options == nil </span><span class="cov0" title="0">{
                options = &amp;ListOptions{Limit: 1000}
        }</span>
        
        <span class="cov8" title="1">var items []*ObjectMetadata
        
        // Walk the metadata directory
        err := filepath.Walk(ls.metaPath, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                <span class="cov8" title="1">if info.IsDir() </span><span class="cov8" title="1">{
                        return nil
                }</span>
                
                // Extract key from path
                <span class="cov8" title="1">relPath, err := filepath.Rel(ls.metaPath, path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                <span class="cov8" title="1">key := strings.ReplaceAll(relPath, string(filepath.Separator), "/")
                key = strings.TrimSuffix(key, ".meta")
                
                // Check prefix filter
                if prefix != "" &amp;&amp; !strings.HasPrefix(key, prefix) </span><span class="cov8" title="1">{
                        return nil
                }</span>
                
                // Load metadata
                <span class="cov8" title="1">metadata, err := ls.GetMetadata(ctx, key)
                if err != nil </span><span class="cov0" title="0">{
                        ls.logger.Warn("failed to load metadata during list", "key", key, "error", err)
                        return nil
                }</span>
                
                <span class="cov8" title="1">items = append(items, metadata)
                
                // Check limit
                if options.Limit &gt; 0 &amp;&amp; len(items) &gt;= options.Limit </span><span class="cov0" title="0">{
                        return filepath.SkipDir
                }</span>
                
                <span class="cov8" title="1">return nil</span>
        })
        
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;StorageError{
                        Code:      ErrCodeInternal,
                        Message:   "failed to list objects",
                        Operation: "list",
                        Cause:     err,
                }
        }</span>
        
        // Sort results
        <span class="cov8" title="1">if options.SortBy == "name" </span><span class="cov0" title="0">{
                sort.Slice(items, func(i, j int) bool </span><span class="cov0" title="0">{
                        if options.SortOrder == "desc" </span><span class="cov0" title="0">{
                                return items[i].Key &gt; items[j].Key
                        }</span>
                        <span class="cov0" title="0">return items[i].Key &lt; items[j].Key</span>
                })
        } else<span class="cov8" title="1"> if options.SortBy == "size" </span><span class="cov0" title="0">{
                sort.Slice(items, func(i, j int) bool </span><span class="cov0" title="0">{
                        if options.SortOrder == "desc" </span><span class="cov0" title="0">{
                                return items[i].Size &gt; items[j].Size
                        }</span>
                        <span class="cov0" title="0">return items[i].Size &lt; items[j].Size</span>
                })
        } else<span class="cov8" title="1"> if options.SortBy == "modified" </span><span class="cov0" title="0">{
                sort.Slice(items, func(i, j int) bool </span><span class="cov0" title="0">{
                        if options.SortOrder == "desc" </span><span class="cov0" title="0">{
                                return items[i].UpdatedAt.After(items[j].UpdatedAt)
                        }</span>
                        <span class="cov0" title="0">return items[i].UpdatedAt.Before(items[j].UpdatedAt)</span>
                })
        }
        
        <span class="cov8" title="1">return &amp;ListResult{
                Items:   items,
                Total:   int64(len(items)),
                HasMore: false,
        }, nil</span>
}

// ListKeys lists object keys with optional prefix
func (ls *LocalStorage) ListKeys(ctx context.Context, prefix string) ([]string, error) <span class="cov0" title="0">{
        result, err := ls.List(ctx, prefix, &amp;ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">keys := make([]string, len(result.Items))
        for i, item := range result.Items </span><span class="cov0" title="0">{
                keys[i] = item.Key
        }</span>
        
        <span class="cov0" title="0">return keys, nil</span>
}

// HealthCheck performs a health check on local storage
func (ls *LocalStorage) HealthCheck(ctx context.Context) (*HealthStatus, error) <span class="cov8" title="1">{
        checks := make(map[string]CheckResult)
        healthy := true
        
        // Check disk space
        start := time.Now()
        stat, err := ls.getDiskUsage()
        if err != nil </span><span class="cov0" title="0">{
                checks["disk_space"] = CheckResult{
                        Status:  "error",
                        Message: "failed to get disk usage",
                        Latency: time.Since(start).Milliseconds(),
                        Time:    time.Now(),
                }
                healthy = false
        }</span> else<span class="cov8" title="1"> {
                status := "ok"
                message := fmt.Sprintf("%.1f%% used", float64(stat.Used)/float64(stat.Total)*100)
                
                if float64(stat.Used)/float64(stat.Total) &gt; 0.9 </span><span class="cov0" title="0">{
                        status = "warning"
                        message = "disk space running low"
                }</span>
                
                <span class="cov8" title="1">checks["disk_space"] = CheckResult{
                        Status:  status,
                        Message: message,
                        Latency: time.Since(start).Milliseconds(),
                        Time:    time.Now(),
                }
                
                if status != "ok" </span><span class="cov0" title="0">{
                        healthy = false
                }</span>
        }
        
        // Check write performance
        <span class="cov8" title="1">start = time.Now()
        testKey := "health_check_test"
        testData := strings.NewReader("health check test data")
        err = ls.Store(ctx, testKey, testData, nil)
        writeLatency := time.Since(start).Milliseconds()
        
        if err != nil </span><span class="cov0" title="0">{
                checks["write_test"] = CheckResult{
                        Status:  "error",
                        Message: "write test failed",
                        Latency: writeLatency,
                        Time:    time.Now(),
                }
                healthy = false
        }</span> else<span class="cov8" title="1"> {
                // Cleanup test object
                ls.Delete(ctx, testKey)
                
                status := "ok"
                message := "write test passed"
                if writeLatency &gt; 1000 </span><span class="cov0" title="0">{
                        status = "warning"
                        message = "slow write performance"
                }</span>
                
                <span class="cov8" title="1">checks["write_test"] = CheckResult{
                        Status:  status,
                        Message: message,
                        Latency: writeLatency,
                        Time:    time.Now(),
                }</span>
        }
        
        <span class="cov8" title="1">ls.lastHealthCheck = time.Now()
        ls.healthy = healthy
        
        status := "healthy"
        if !healthy </span><span class="cov0" title="0">{
                status = "unhealthy"
        }</span>
        
        <span class="cov8" title="1">return &amp;HealthStatus{
                Status:    status,
                Healthy:   healthy,
                LastCheck: ls.lastHealthCheck,
                Checks:    checks,
        }, nil</span>
}

// GetStats returns storage statistics
func (ls *LocalStorage) GetStats(ctx context.Context) (*StorageStats, error) <span class="cov8" title="1">{
        ls.statsMutex.RLock()
        defer ls.statsMutex.RUnlock()
        
        // Update disk usage
        diskStat, err := ls.getDiskUsage()
        if err != nil </span><span class="cov0" title="0">{
                ls.logger.Warn("failed to get disk usage", "error", err)
        }</span> else<span class="cov8" title="1"> {
                ls.stats.AvailableSpace = diskStat.Available
        }</span>
        
        // Create a copy of stats
        <span class="cov8" title="1">stats := *ls.stats
        stats.OperationCounts = make(map[string]int64)
        for k, v := range ls.stats.OperationCounts </span><span class="cov8" title="1">{
                stats.OperationCounts[k] = v
        }</span>
        
        // Copy performance stats
        <span class="cov8" title="1">if ls.stats.Performance != nil </span><span class="cov8" title="1">{
                perf := *ls.stats.Performance
                if ls.stats.Performance.ReadLatency != nil </span><span class="cov8" title="1">{
                        readLat := *ls.stats.Performance.ReadLatency
                        perf.ReadLatency = &amp;readLat
                }</span>
                <span class="cov8" title="1">if ls.stats.Performance.WriteLatency != nil </span><span class="cov8" title="1">{
                        writeLat := *ls.stats.Performance.WriteLatency
                        perf.WriteLatency = &amp;writeLat
                }</span>
                <span class="cov8" title="1">if ls.stats.Performance.DeleteLatency != nil </span><span class="cov8" title="1">{
                        deleteLat := *ls.stats.Performance.DeleteLatency
                        perf.DeleteLatency = &amp;deleteLat
                }</span>
                <span class="cov8" title="1">if ls.stats.Performance.Throughput != nil </span><span class="cov8" title="1">{
                        throughput := *ls.stats.Performance.Throughput
                        perf.Throughput = &amp;throughput
                }</span>
                <span class="cov8" title="1">stats.Performance = &amp;perf</span>
        }
        
        <span class="cov8" title="1">return &amp;stats, nil</span>
}

// Helper methods

func (ls *LocalStorage) validateKey(key string) error <span class="cov8" title="1">{
        if key == "" </span><span class="cov0" title="0">{
                return &amp;StorageError{
                        Code:    ErrCodeInvalidArgument,
                        Message: "key cannot be empty",
                }
        }</span>
        
        <span class="cov8" title="1">if strings.Contains(key, "..") </span><span class="cov0" title="0">{
                return &amp;StorageError{
                        Code:    ErrCodeInvalidArgument,
                        Message: "key cannot contain '..'",
                }
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

func (ls *LocalStorage) getObjectPath(key string) string <span class="cov8" title="1">{
        // Create a safe path by replacing path separators
        safePath := strings.ReplaceAll(key, "/", string(filepath.Separator))
        return filepath.Join(ls.basePath, "objects", safePath)
}</span>

func (ls *LocalStorage) getMetadataPath(key string) string <span class="cov8" title="1">{
        safePath := strings.ReplaceAll(key, "/", string(filepath.Separator))
        return filepath.Join(ls.metaPath, safePath+".meta")
}</span>

func (ls *LocalStorage) getFileLock(key string) *sync.RWMutex <span class="cov8" title="1">{
        ls.locksMutex.Lock()
        defer ls.locksMutex.Unlock()
        
        if lock, exists := ls.fileLocks[key]; exists </span><span class="cov8" title="1">{
                return lock
        }</span>
        
        <span class="cov8" title="1">lock := &amp;sync.RWMutex{}
        ls.fileLocks[key] = lock
        return lock</span>
}

func (ls *LocalStorage) storeMetadata(key string, metadata *ObjectMetadata) error <span class="cov8" title="1">{
        metaPath := ls.getMetadataPath(key)
        if err := os.MkdirAll(filepath.Dir(metaPath), 0755); err != nil </span><span class="cov0" title="0">{
                return &amp;StorageError{
                        Code:      ErrCodeInternal,
                        Message:   "failed to create metadata directory",
                        Operation: "store_metadata",
                        Key:       key,
                        Cause:     err,
                }
        }</span>
        
        <span class="cov8" title="1">data, err := json.MarshalIndent(metadata, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return &amp;StorageError{
                        Code:      ErrCodeInternal,
                        Message:   "failed to serialize metadata",
                        Operation: "store_metadata",
                        Key:       key,
                        Cause:     err,
                }
        }</span>
        
        <span class="cov8" title="1">tempPath := metaPath + ".tmp"
        if err := os.WriteFile(tempPath, data, 0644); err != nil </span><span class="cov0" title="0">{
                return &amp;StorageError{
                        Code:      ErrCodeInternal,
                        Message:   "failed to write metadata file",
                        Operation: "store_metadata",
                        Key:       key,
                        Cause:     err,
                }
        }</span>
        
        <span class="cov8" title="1">if err := os.Rename(tempPath, metaPath); err != nil </span><span class="cov0" title="0">{
                os.Remove(tempPath)
                return &amp;StorageError{
                        Code:      ErrCodeInternal,
                        Message:   "failed to move metadata file",
                        Operation: "store_metadata",
                        Key:       key,
                        Cause:     err,
                }
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

// Cache management methods

func (ls *LocalStorage) getFromMetadataCache(key string) *ObjectMetadata <span class="cov8" title="1">{
        ls.cacheMutex.RLock()
        defer ls.cacheMutex.RUnlock()
        
        if metadata, exists := ls.metadataCache[key]; exists </span><span class="cov8" title="1">{
                // Create a copy to avoid race conditions
                copy := *metadata
                return &amp;copy
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

func (ls *LocalStorage) updateMetadataCache(key string, metadata *ObjectMetadata) <span class="cov8" title="1">{
        ls.cacheMutex.Lock()
        defer ls.cacheMutex.Unlock()
        
        // Check cache size and evict if necessary
        if len(ls.metadataCache) &gt;= ls.maxCacheSize </span><span class="cov0" title="0">{
                ls.evictFromCache()
        }</span>
        
        // Create a copy to store in cache
        <span class="cov8" title="1">copy := *metadata
        ls.metadataCache[key] = &amp;copy
        ls.cacheSize++</span>
}

func (ls *LocalStorage) removeFromMetadataCache(key string) <span class="cov8" title="1">{
        ls.cacheMutex.Lock()
        defer ls.cacheMutex.Unlock()
        
        if _, exists := ls.metadataCache[key]; exists </span><span class="cov8" title="1">{
                delete(ls.metadataCache, key)
                ls.cacheSize--
        }</span>
}

func (ls *LocalStorage) evictFromCache() <span class="cov0" title="0">{
        // Simple LRU eviction - remove oldest accessed
        var oldestKey string
        var oldestTime time.Time = time.Now()
        
        for key, metadata := range ls.metadataCache </span><span class="cov0" title="0">{
                if metadata.AccessedAt.Before(oldestTime) </span><span class="cov0" title="0">{
                        oldestTime = metadata.AccessedAt
                        oldestKey = key
                }</span>
        }
        
        <span class="cov0" title="0">if oldestKey != "" </span><span class="cov0" title="0">{
                delete(ls.metadataCache, oldestKey)
                ls.cacheSize--
        }</span>
}

func (ls *LocalStorage) loadMetadataCache() error <span class="cov8" title="1">{
        // Load frequently accessed metadata into cache
        return filepath.Walk(ls.metaPath, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil || info.IsDir() </span><span class="cov8" title="1">{
                        return err
                }</span>
                
                <span class="cov0" title="0">if !strings.HasSuffix(path, ".meta") </span><span class="cov0" title="0">{
                        return nil
                }</span>
                
                // Extract key
                <span class="cov0" title="0">relPath, err := filepath.Rel(ls.metaPath, path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">key := strings.TrimSuffix(relPath, ".meta")
                key = strings.ReplaceAll(key, string(filepath.Separator), "/")
                
                // Load metadata
                data, err := os.ReadFile(path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                <span class="cov0" title="0">var metadata ObjectMetadata
                if err := json.Unmarshal(data, &amp;metadata); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                // Add to cache if recently accessed
                <span class="cov0" title="0">if time.Since(metadata.AccessedAt) &lt; 24*time.Hour </span><span class="cov0" title="0">{
                        ls.cacheMutex.Lock()
                        if len(ls.metadataCache) &lt; ls.maxCacheSize </span><span class="cov0" title="0">{
                                ls.metadataCache[key] = &amp;metadata
                                ls.cacheSize++
                        }</span>
                        <span class="cov0" title="0">ls.cacheMutex.Unlock()</span>
                }
                
                <span class="cov0" title="0">return nil</span>
        })
}

func (ls *LocalStorage) saveMetadataCache() error <span class="cov8" title="1">{
        // No need to explicitly save as metadata is persisted on writes
        return nil
}</span>

// Statistics and monitoring methods

func (ls *LocalStorage) updateLatencyStats(operation string, latency time.Duration) <span class="cov8" title="1">{
        ls.statsMutex.Lock()
        defer ls.statsMutex.Unlock()
        
        latencyMs := latency.Milliseconds()
        
        var stats *LatencyStats
        switch operation </span>{
        case "read":<span class="cov8" title="1">
                stats = ls.stats.Performance.ReadLatency</span>
        case "write":<span class="cov8" title="1">
                stats = ls.stats.Performance.WriteLatency</span>
        case "delete":<span class="cov8" title="1">
                stats = ls.stats.Performance.DeleteLatency</span>
        default:<span class="cov0" title="0">
                return</span>
        }
        
        // Update statistics
        <span class="cov8" title="1">if stats.Samples == 0 </span><span class="cov8" title="1">{
                stats.Min = latencyMs
                stats.Max = latencyMs
                stats.Mean = float64(latencyMs)
                stats.Median = latencyMs
        }</span> else<span class="cov8" title="1"> {
                if latencyMs &lt; stats.Min </span><span class="cov8" title="1">{
                        stats.Min = latencyMs
                }</span>
                <span class="cov8" title="1">if latencyMs &gt; stats.Max </span><span class="cov8" title="1">{
                        stats.Max = latencyMs
                }</span>
                
                // Update mean
                <span class="cov8" title="1">stats.Mean = (stats.Mean*float64(stats.Samples) + float64(latencyMs)) / float64(stats.Samples+1)</span>
        }
        
        <span class="cov8" title="1">stats.Samples++</span>
}

func (ls *LocalStorage) incrementOperationCount(operation string) <span class="cov8" title="1">{
        ls.statsMutex.Lock()
        defer ls.statsMutex.Unlock()
        
        ls.stats.OperationCounts[operation]++
}</span>

// Background routines

func (ls *LocalStorage) cleanupRoutine() <span class="cov8" title="1">{
        ticker := time.NewTicker(1 * time.Hour)
        defer ticker.Stop()
        
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ls.ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        ls.performCleanup()</span>
                }
        }
}

func (ls *LocalStorage) healthMonitorRoutine() <span class="cov8" title="1">{
        ticker := time.NewTicker(5 * time.Minute)
        defer ticker.Stop()
        
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ls.ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        ls.HealthCheck(ls.ctx)</span>
                }
        }
}

func (ls *LocalStorage) statsCollectionRoutine() <span class="cov8" title="1">{
        ticker := time.NewTicker(1 * time.Minute)
        defer ticker.Stop()
        
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ls.ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        ls.collectStats()</span>
                }
        }
}

func (ls *LocalStorage) performCleanup() <span class="cov0" title="0">{
        // Clean up temporary files
        err := filepath.Walk(ls.basePath, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                <span class="cov0" title="0">if strings.HasSuffix(path, ".tmp") &amp;&amp; time.Since(info.ModTime()) &gt; time.Hour </span><span class="cov0" title="0">{
                        os.Remove(path)
                }</span>
                
                <span class="cov0" title="0">return nil</span>
        })
        
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                ls.logger.Error("cleanup failed", "error", err)
        }</span>
}

func (ls *LocalStorage) collectStats() <span class="cov0" title="0">{
        // Update throughput stats based on operation counts
        // This is a simplified implementation
        ls.statsMutex.Lock()
        defer ls.statsMutex.Unlock()
        
        // Calculate ops per second (simplified)
        if ls.stats.Performance != nil &amp;&amp; ls.stats.Performance.Throughput != nil </span><span class="cov0" title="0">{
                totalOps := int64(0)
                for _, count := range ls.stats.OperationCounts </span><span class="cov0" title="0">{
                        totalOps += count
                }</span>
                
                // Simple calculation - in practice this would be more sophisticated
                <span class="cov0" title="0">ls.stats.Performance.Throughput.ReadOpsPerSec = float64(ls.stats.OperationCounts["retrieve"]) / 60.0
                ls.stats.Performance.Throughput.WriteOpsPerSec = float64(ls.stats.OperationCounts["store"]) / 60.0
                ls.stats.Performance.Throughput.DeleteOpsPerSec = float64(ls.stats.OperationCounts["delete"]) / 60.0</span>
        }
}

// Disk usage calculation (platform-specific implementations would be needed)
type diskStat struct {
        Total     int64
        Used      int64
        Available int64
}

func (ls *LocalStorage) getDiskUsage() (*diskStat, error) <span class="cov8" title="1">{
        // This is a simplified implementation
        // In practice, this would use platform-specific syscalls
        return &amp;diskStat{
                Total:     100 * 1024 * 1024 * 1024, // 100GB
                Used:      ls.stats.UsedSpace,
                Available: (100 * 1024 * 1024 * 1024) - ls.stats.UsedSpace,
        }, nil
}</span>

// Helper function to check if error is not found
func isNotFoundError(err error) bool <span class="cov0" title="0">{
        if storageErr, ok := err.(*StorageError); ok </span><span class="cov0" title="0">{
                return storageErr.Code == ErrCodeNotFound
        }</span>
        <span class="cov0" title="0">return false</span>
}</pre>
		
		<pre class="file" id="file11" style="display: none">package storage

import (
        "context"
        "encoding/json"
        "fmt"
        "log/slog"
        "os"
        "path/filepath"
        "sort"
        "strings"
        "sync"
        "time"

        "github.com/syndtr/goleveldb/leveldb"
        "github.com/syndtr/goleveldb/leveldb/util"
)

// MetadataManager manages metadata storage and operations
type MetadataManager struct {
        logger *slog.Logger
        
        // Storage backends
        levelDB    *leveldb.DB
        fileSystem *FileSystemMetadata
        
        // Configuration
        config *MetadataConfig
        
        // Caching
        cache      map[string]*CachedMetadata
        cacheMutex sync.RWMutex
        cacheSize  int
        maxCache   int
        
        // Indexing
        indexes    map[string]*MetadataIndex
        indexMutex sync.RWMutex
        
        // Statistics
        stats      *MetadataStats
        statsMutex sync.RWMutex
        
        // Background tasks
        ctx     context.Context
        cancel  context.CancelFunc
        started bool
        mu      sync.RWMutex
}

// MetadataConfig contains configuration for metadata management
type MetadataConfig struct {
        Backend       string        `json:"backend"`        // leveldb, filesystem, memory
        DataDir       string        `json:"data_dir"`
        IndexingMode  string        `json:"indexing_mode"`  // eager, lazy, disabled
        CacheSize     int           `json:"cache_size"`
        SyncInterval  time.Duration `json:"sync_interval"`
        CompactInterval time.Duration `json:"compact_interval"`
        EnableSearch  bool          `json:"enable_search"`
        EnableVersioning bool       `json:"enable_versioning"`
}

// FileSystemMetadata implements filesystem-based metadata storage
type FileSystemMetadata struct {
        basePath string
        logger   *slog.Logger
}

// CachedMetadata represents cached metadata with additional information
type CachedMetadata struct {
        Metadata   *ObjectMetadata `json:"metadata"`
        CachedAt   time.Time       `json:"cached_at"`
        AccessCount int            `json:"access_count"`
        LastAccess time.Time       `json:"last_access"`
}

// MetadataIndex represents an index for fast metadata queries
type MetadataIndex struct {
        Name      string                     `json:"name"`
        Type      string                     `json:"type"` // btree, hash, text
        Fields    []string                   `json:"fields"`
        Values    map[string][]string        `json:"values"` // value -&gt; keys
        CreatedAt time.Time                  `json:"created_at"`
        UpdatedAt time.Time                  `json:"updated_at"`
        Stats     *IndexStats                `json:"stats"`
}

// IndexStats contains statistics about an index
type IndexStats struct {
        TotalEntries  int64     `json:"total_entries"`
        UniqueValues  int64     `json:"unique_values"`
        LastUpdated   time.Time `json:"last_updated"`
        UpdateCount   int64     `json:"update_count"`
        QueryCount    int64     `json:"query_count"`
        AverageDepth  float64   `json:"average_depth"`
}

// MetadataStats contains statistics about metadata operations
type MetadataStats struct {
        TotalObjects     int64             `json:"total_objects"`
        TotalSize        int64             `json:"total_size"`
        CacheHitRate     float64           `json:"cache_hit_rate"`
        CacheHits        int64             `json:"cache_hits"`
        CacheMisses      int64             `json:"cache_misses"`
        IndexQueries     int64             `json:"index_queries"`
        OperationCounts  map[string]int64  `json:"operation_counts"`
        Performance      *MetadataPerformance `json:"performance"`
        LastCompaction   time.Time         `json:"last_compaction"`
        LastSync         time.Time         `json:"last_sync"`
}

// MetadataPerformance contains performance metrics
type MetadataPerformance struct {
        GetLatency    *LatencyStats `json:"get_latency"`
        SetLatency    *LatencyStats `json:"set_latency"`
        SearchLatency *LatencyStats `json:"search_latency"`
        IndexLatency  *LatencyStats `json:"index_latency"`
}

// MetadataQuery represents a metadata query
type MetadataQuery struct {
        Fields     map[string]interface{} `json:"fields"`
        Conditions []*QueryCondition      `json:"conditions"`
        Sort       *SortOptions           `json:"sort"`
        Limit      int                    `json:"limit"`
        Offset     int                    `json:"offset"`
        FullText   string                 `json:"full_text"`
}

// QueryCondition represents a query condition
type QueryCondition struct {
        Field    string      `json:"field"`
        Operator string      `json:"operator"` // eq, ne, gt, lt, gte, lte, in, like, regex
        Value    interface{} `json:"value"`
        LogicalOp string     `json:"logical_op"` // and, or, not
}

// SortOptions represents sorting options
type SortOptions struct {
        Field string `json:"field"`
        Order string `json:"order"` // asc, desc
}

// MetadataQueryResult represents the result of a metadata query
type MetadataQueryResult struct {
        Objects      []*ObjectMetadata `json:"objects"`
        Total        int64             `json:"total"`
        QueryTime    time.Duration     `json:"query_time"`
        IndexUsed    string            `json:"index_used"`
        Explanation  string            `json:"explanation"`
}

// NewMetadataManager creates a new metadata manager
func NewMetadataManager(config *MetadataConfig, logger *slog.Logger) (*MetadataManager, error) <span class="cov8" title="1">{
        ctx, cancel := context.WithCancel(context.Background())
        
        mm := &amp;MetadataManager{
                logger:     logger,
                config:     config,
                cache:      make(map[string]*CachedMetadata),
                maxCache:   config.CacheSize,
                indexes:    make(map[string]*MetadataIndex),
                stats: &amp;MetadataStats{
                        OperationCounts: make(map[string]int64),
                        Performance: &amp;MetadataPerformance{
                                GetLatency:    &amp;LatencyStats{},
                                SetLatency:    &amp;LatencyStats{},
                                SearchLatency: &amp;LatencyStats{},
                                IndexLatency:  &amp;LatencyStats{},
                        },
                },
                ctx:    ctx,
                cancel: cancel,
        }
        
        // Initialize storage backend
        if err := mm.initializeBackend(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize metadata backend: %w", err)
        }</span>
        
        // Create default indexes
        <span class="cov8" title="1">if config.IndexingMode != "disabled" </span><span class="cov8" title="1">{
                mm.createDefaultIndexes()
        }</span>
        
        <span class="cov8" title="1">return mm, nil</span>
}

// Start starts the metadata manager
func (mm *MetadataManager) Start(ctx context.Context) error <span class="cov8" title="1">{
        mm.mu.Lock()
        defer mm.mu.Unlock()
        
        if mm.started </span><span class="cov0" title="0">{
                return fmt.Errorf("metadata manager already started")
        }</span>
        
        // Start background routines
        <span class="cov8" title="1">go mm.syncRoutine()
        go mm.compactionRoutine()
        go mm.cacheMaintenanceRoutine()
        go mm.statsCollectionRoutine()
        
        mm.started = true
        mm.logger.Info("metadata manager started", "backend", mm.config.Backend)
        
        return nil</span>
}

// Stop stops the metadata manager
func (mm *MetadataManager) Stop(ctx context.Context) error <span class="cov8" title="1">{
        mm.mu.Lock()
        defer mm.mu.Unlock()
        
        if !mm.started </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov8" title="1">mm.cancel()
        
        // Close storage backends
        if mm.levelDB != nil </span><span class="cov0" title="0">{
                mm.levelDB.Close()
        }</span>
        
        <span class="cov8" title="1">mm.started = false
        mm.logger.Info("metadata manager stopped")
        
        return nil</span>
}

// Store stores metadata for an object
func (mm *MetadataManager) Store(ctx context.Context, key string, metadata *ObjectMetadata) error <span class="cov8" title="1">{
        start := time.Now()
        defer func() </span><span class="cov8" title="1">{
                mm.updateLatencyStats("set", time.Since(start))
                mm.incrementOperationCount("store")
        }</span>()
        
        // Prepare metadata
        <span class="cov8" title="1">metadata.Key = key
        metadata.UpdatedAt = time.Now()
        if metadata.CreatedAt.IsZero() </span><span class="cov0" title="0">{
                metadata.CreatedAt = time.Now()
        }</span>
        
        // Store in backend
        <span class="cov8" title="1">if err := mm.storeInBackend(key, metadata); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // Update cache
        <span class="cov8" title="1">mm.updateCache(key, metadata)
        
        // Update indexes
        if mm.config.IndexingMode == "eager" </span><span class="cov8" title="1">{
                mm.updateIndexes(key, metadata)
        }</span>
        
        // Update statistics
        <span class="cov8" title="1">mm.statsMutex.Lock()
        mm.stats.TotalObjects++
        if metadata.Size &gt; 0 </span><span class="cov8" title="1">{
                mm.stats.TotalSize += metadata.Size
        }</span>
        <span class="cov8" title="1">mm.statsMutex.Unlock()
        
        return nil</span>
}

// Get retrieves metadata for an object
func (mm *MetadataManager) Get(ctx context.Context, key string) (*ObjectMetadata, error) <span class="cov8" title="1">{
        start := time.Now()
        defer func() </span><span class="cov8" title="1">{
                mm.updateLatencyStats("get", time.Since(start))
                mm.incrementOperationCount("get")
        }</span>()
        
        // Check cache first
        <span class="cov8" title="1">if cached := mm.getFromCache(key); cached != nil </span><span class="cov8" title="1">{
                mm.incrementCacheHits()
                return cached.Metadata, nil
        }</span>
        
        <span class="cov8" title="1">mm.incrementCacheMisses()
        
        // Load from backend
        metadata, err := mm.loadFromBackend(key)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        
        // Update cache
        <span class="cov0" title="0">mm.updateCache(key, metadata)
        
        return metadata, nil</span>
}

// Update updates specific metadata fields
func (mm *MetadataManager) Update(ctx context.Context, key string, updates map[string]interface{}) error <span class="cov8" title="1">{
        // Get current metadata
        metadata, err := mm.Get(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // Apply updates
        <span class="cov8" title="1">if metadata.Attributes == nil </span><span class="cov0" title="0">{
                metadata.Attributes = make(map[string]interface{})
        }</span>
        
        <span class="cov8" title="1">for field, value := range updates </span><span class="cov8" title="1">{
                switch field </span>{
                case "content_type":<span class="cov0" title="0">
                        if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                metadata.ContentType = v
                        }</span>
                case "version":<span class="cov8" title="1">
                        if v, ok := value.(string); ok </span><span class="cov8" title="1">{
                                metadata.Version = v
                        }</span>
                case "size":<span class="cov0" title="0">
                        if v, ok := value.(int64); ok </span><span class="cov0" title="0">{
                                metadata.Size = v
                        }</span>
                case "hash":<span class="cov0" title="0">
                        if v, ok := value.(string); ok </span><span class="cov0" title="0">{
                                metadata.Hash = v
                        }</span>
                default:<span class="cov8" title="1">
                        metadata.Attributes[field] = value</span>
                }
        }
        
        <span class="cov8" title="1">return mm.Store(ctx, key, metadata)</span>
}

// Delete deletes metadata for an object
func (mm *MetadataManager) Delete(ctx context.Context, key string) error <span class="cov8" title="1">{
        start := time.Now()
        defer func() </span><span class="cov8" title="1">{
                mm.updateLatencyStats("delete", time.Since(start))
                mm.incrementOperationCount("delete")
        }</span>()
        
        // Get metadata for size accounting
        <span class="cov8" title="1">metadata, err := mm.Get(ctx, key)
        if err != nil &amp;&amp; !isNotFoundError(err) </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // Delete from backend
        <span class="cov8" title="1">if err := mm.deleteFromBackend(key); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // Remove from cache
        <span class="cov8" title="1">mm.removeFromCache(key)
        
        // Remove from indexes
        if mm.config.IndexingMode != "disabled" </span><span class="cov8" title="1">{
                mm.removeFromIndexes(key, metadata)
        }</span>
        
        // Update statistics
        <span class="cov8" title="1">if metadata != nil </span><span class="cov8" title="1">{
                mm.statsMutex.Lock()
                mm.stats.TotalObjects--
                if metadata.Size &gt; 0 </span><span class="cov8" title="1">{
                        mm.stats.TotalSize -= metadata.Size
                }</span>
                <span class="cov8" title="1">mm.statsMutex.Unlock()</span>
        }
        
        <span class="cov8" title="1">return nil</span>
}

// List lists metadata with optional filtering
func (mm *MetadataManager) List(ctx context.Context, prefix string, options *ListOptions) ([]*ObjectMetadata, error) <span class="cov8" title="1">{
        start := time.Now()
        defer func() </span><span class="cov8" title="1">{
                mm.updateLatencyStats("list", time.Since(start))
                mm.incrementOperationCount("list")
        }</span>()
        
        <span class="cov8" title="1">return mm.listFromBackend(prefix, options)</span>
}

// Search performs advanced metadata search
func (mm *MetadataManager) Search(ctx context.Context, query *MetadataQuery) (*MetadataQueryResult, error) <span class="cov8" title="1">{
        start := time.Now()
        defer func() </span><span class="cov8" title="1">{
                mm.updateLatencyStats("search", time.Since(start))
                mm.incrementOperationCount("search")
        }</span>()
        
        <span class="cov8" title="1">if !mm.config.EnableSearch </span><span class="cov0" title="0">{
                return nil, &amp;StorageError{
                        Code:    ErrCodeUnavailable,
                        Message: "search not enabled",
                }
        }</span>
        
        // Determine best index to use
        <span class="cov8" title="1">indexName := mm.selectBestIndex(query)
        
        var results []*ObjectMetadata
        var err error
        
        if indexName != "" </span><span class="cov8" title="1">{
                results, err = mm.searchWithIndex(ctx, query, indexName)
        }</span> else<span class="cov8" title="1"> {
                results, err = mm.searchWithoutIndex(ctx, query)
        }</span>
        
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // Apply sorting and pagination
        <span class="cov8" title="1">results = mm.applySortingAndPagination(results, query)
        
        return &amp;MetadataQueryResult{
                Objects:     results,
                Total:       int64(len(results)),
                QueryTime:   time.Since(start),
                IndexUsed:   indexName,
                Explanation: mm.explainQuery(query, indexName),
        }, nil</span>
}

// CreateIndex creates a new metadata index
func (mm *MetadataManager) CreateIndex(ctx context.Context, name string, fields []string, indexType string) error <span class="cov8" title="1">{
        start := time.Now()
        defer func() </span><span class="cov8" title="1">{
                mm.updateLatencyStats("index", time.Since(start))
                mm.incrementOperationCount("create_index")
        }</span>()
        
        <span class="cov8" title="1">mm.indexMutex.Lock()
        defer mm.indexMutex.Unlock()
        
        if _, exists := mm.indexes[name]; exists </span><span class="cov0" title="0">{
                return &amp;StorageError{
                        Code:    ErrCodeAlreadyExists,
                        Message: "index already exists",
                }
        }</span>
        
        <span class="cov8" title="1">index := &amp;MetadataIndex{
                Name:      name,
                Type:      indexType,
                Fields:    fields,
                Values:    make(map[string][]string),
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
                Stats:     &amp;IndexStats{},
        }
        
        mm.indexes[name] = index
        
        // Build index from existing metadata
        go mm.buildIndex(ctx, index)
        
        mm.logger.Info("metadata index created", "name", name, "fields", fields, "type", indexType)
        
        return nil</span>
}

// DropIndex drops a metadata index
func (mm *MetadataManager) DropIndex(ctx context.Context, name string) error <span class="cov0" title="0">{
        mm.indexMutex.Lock()
        defer mm.indexMutex.Unlock()
        
        if _, exists := mm.indexes[name]; !exists </span><span class="cov0" title="0">{
                return &amp;StorageError{
                        Code:    ErrCodeNotFound,
                        Message: "index not found",
                }
        }</span>
        
        <span class="cov0" title="0">delete(mm.indexes, name)
        
        mm.logger.Info("metadata index dropped", "name", name)
        
        return nil</span>
}

// GetIndexes returns all metadata indexes
func (mm *MetadataManager) GetIndexes(ctx context.Context) ([]*MetadataIndex, error) <span class="cov8" title="1">{
        mm.indexMutex.RLock()
        defer mm.indexMutex.RUnlock()
        
        indexes := make([]*MetadataIndex, 0, len(mm.indexes))
        for _, index := range mm.indexes </span><span class="cov8" title="1">{
                // Create a copy
                indexCopy := *index
                indexCopy.Values = make(map[string][]string)
                for k, v := range index.Values </span><span class="cov8" title="1">{
                        indexCopy.Values[k] = append([]string{}, v...)
                }</span>
                <span class="cov8" title="1">indexes = append(indexes, &amp;indexCopy)</span>
        }
        
        <span class="cov8" title="1">return indexes, nil</span>
}

// GetStats returns metadata statistics
func (mm *MetadataManager) GetStats(ctx context.Context) (*MetadataStats, error) <span class="cov8" title="1">{
        mm.statsMutex.RLock()
        defer mm.statsMutex.RUnlock()
        
        // Update cache hit rate
        totalRequests := mm.stats.CacheHits + mm.stats.CacheMisses
        if totalRequests &gt; 0 </span><span class="cov8" title="1">{
                mm.stats.CacheHitRate = float64(mm.stats.CacheHits) / float64(totalRequests)
        }</span>
        
        // Create a copy
        <span class="cov8" title="1">stats := *mm.stats
        stats.OperationCounts = make(map[string]int64)
        for k, v := range mm.stats.OperationCounts </span><span class="cov8" title="1">{
                stats.OperationCounts[k] = v
        }</span>
        
        <span class="cov8" title="1">return &amp;stats, nil</span>
}

// Backend initialization

func (mm *MetadataManager) initializeBackend() error <span class="cov8" title="1">{
        switch mm.config.Backend </span>{
        case "leveldb":<span class="cov0" title="0">
                return mm.initializeLevelDB()</span>
        case "filesystem":<span class="cov8" title="1">
                return mm.initializeFileSystem()</span>
        case "memory":<span class="cov0" title="0">
                return nil</span> // Memory backend is the default cache
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported metadata backend: %s", mm.config.Backend)</span>
        }
}

func (mm *MetadataManager) initializeLevelDB() error <span class="cov0" title="0">{
        dbPath := filepath.Join(mm.config.DataDir, "metadata.db")
        if err := os.MkdirAll(filepath.Dir(dbPath), 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov0" title="0">db, err := leveldb.OpenFile(dbPath, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov0" title="0">mm.levelDB = db
        return nil</span>
}

func (mm *MetadataManager) initializeFileSystem() error <span class="cov8" title="1">{
        metaPath := filepath.Join(mm.config.DataDir, "metadata")
        if err := os.MkdirAll(metaPath, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">mm.fileSystem = &amp;FileSystemMetadata{
                basePath: metaPath,
                logger:   mm.logger,
        }
        
        return nil</span>
}

// Backend operations

func (mm *MetadataManager) storeInBackend(key string, metadata *ObjectMetadata) error <span class="cov8" title="1">{
        data, err := json.Marshal(metadata)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">switch mm.config.Backend </span>{
        case "leveldb":<span class="cov0" title="0">
                return mm.levelDB.Put([]byte(key), data, nil)</span>
        case "filesystem":<span class="cov8" title="1">
                return mm.fileSystem.store(key, data)</span>
        case "memory":<span class="cov0" title="0">
                return nil</span> // Only stored in cache
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported backend: %s", mm.config.Backend)</span>
        }
}

func (mm *MetadataManager) loadFromBackend(key string) (*ObjectMetadata, error) <span class="cov8" title="1">{
        var data []byte
        var err error
        
        switch mm.config.Backend </span>{
        case "leveldb":<span class="cov0" title="0">
                data, err = mm.levelDB.Get([]byte(key), nil)
                if err == leveldb.ErrNotFound </span><span class="cov0" title="0">{
                        return nil, &amp;StorageError{
                                Code:    ErrCodeNotFound,
                                Message: "metadata not found",
                        }
                }</span>
        case "filesystem":<span class="cov8" title="1">
                data, err = mm.fileSystem.load(key)</span>
        case "memory":<span class="cov0" title="0">
                return nil, &amp;StorageError{
                        Code:    ErrCodeNotFound,
                        Message: "metadata not found in memory",
                }</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported backend: %s", mm.config.Backend)</span>
        }
        
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">var metadata ObjectMetadata
        if err := json.Unmarshal(data, &amp;metadata); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">return &amp;metadata, nil</span>
}

func (mm *MetadataManager) deleteFromBackend(key string) error <span class="cov8" title="1">{
        switch mm.config.Backend </span>{
        case "leveldb":<span class="cov0" title="0">
                return mm.levelDB.Delete([]byte(key), nil)</span>
        case "filesystem":<span class="cov8" title="1">
                return mm.fileSystem.delete(key)</span>
        case "memory":<span class="cov0" title="0">
                return nil</span> // Only deleted from cache
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported backend: %s", mm.config.Backend)</span>
        }
}

func (mm *MetadataManager) listFromBackend(prefix string, options *ListOptions) ([]*ObjectMetadata, error) <span class="cov8" title="1">{
        var results []*ObjectMetadata
        
        switch mm.config.Backend </span>{
        case "leveldb":<span class="cov0" title="0">
                iter := mm.levelDB.NewIterator(util.BytesPrefix([]byte(prefix)), nil)
                defer iter.Release()
                
                for iter.Next() </span><span class="cov0" title="0">{
                        var metadata ObjectMetadata
                        if err := json.Unmarshal(iter.Value(), &amp;metadata); err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">results = append(results, &amp;metadata)
                        
                        if options != nil &amp;&amp; options.Limit &gt; 0 &amp;&amp; len(results) &gt;= options.Limit </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                
                <span class="cov0" title="0">return results, iter.Error()</span>
                
        case "filesystem":<span class="cov8" title="1">
                return mm.fileSystem.list(prefix, options)</span>
                
        case "memory":<span class="cov0" title="0">
                // List from cache
                mm.cacheMutex.RLock()
                defer mm.cacheMutex.RUnlock()
                
                for key, cached := range mm.cache </span><span class="cov0" title="0">{
                        if strings.HasPrefix(key, prefix) </span><span class="cov0" title="0">{
                                results = append(results, cached.Metadata)
                                if options != nil &amp;&amp; options.Limit &gt; 0 &amp;&amp; len(results) &gt;= options.Limit </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                }
                
                <span class="cov0" title="0">return results, nil</span>
                
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported backend: %s", mm.config.Backend)</span>
        }
}

// Cache management

func (mm *MetadataManager) getFromCache(key string) *CachedMetadata <span class="cov8" title="1">{
        mm.cacheMutex.RLock()
        defer mm.cacheMutex.RUnlock()
        
        if cached, exists := mm.cache[key]; exists </span><span class="cov8" title="1">{
                cached.LastAccess = time.Now()
                cached.AccessCount++
                return cached
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

func (mm *MetadataManager) updateCache(key string, metadata *ObjectMetadata) <span class="cov8" title="1">{
        mm.cacheMutex.Lock()
        defer mm.cacheMutex.Unlock()
        
        // Check cache size
        if len(mm.cache) &gt;= mm.maxCache </span><span class="cov0" title="0">{
                mm.evictFromCache()
        }</span>
        
        <span class="cov8" title="1">mm.cache[key] = &amp;CachedMetadata{
                Metadata:    metadata,
                CachedAt:    time.Now(),
                AccessCount: 1,
                LastAccess:  time.Now(),
        }
        mm.cacheSize++</span>
}

func (mm *MetadataManager) removeFromCache(key string) <span class="cov8" title="1">{
        mm.cacheMutex.Lock()
        defer mm.cacheMutex.Unlock()
        
        if _, exists := mm.cache[key]; exists </span><span class="cov8" title="1">{
                delete(mm.cache, key)
                mm.cacheSize--
        }</span>
}

func (mm *MetadataManager) evictFromCache() <span class="cov0" title="0">{
        // LRU eviction
        var oldestKey string
        var oldestTime time.Time = time.Now()
        
        for key, cached := range mm.cache </span><span class="cov0" title="0">{
                if cached.LastAccess.Before(oldestTime) </span><span class="cov0" title="0">{
                        oldestTime = cached.LastAccess
                        oldestKey = key
                }</span>
        }
        
        <span class="cov0" title="0">if oldestKey != "" </span><span class="cov0" title="0">{
                delete(mm.cache, oldestKey)
                mm.cacheSize--
        }</span>
}

// Index management

func (mm *MetadataManager) createDefaultIndexes() <span class="cov8" title="1">{
        // Create indexes for common fields
        commonIndexes := map[string][]string{
                "size_index":         {"size"},
                "type_index":         {"content_type"},
                "created_index":      {"created_at"},
                "updated_index":      {"updated_at"},
                "hash_index":         {"hash"},
        }
        
        for name, fields := range commonIndexes </span><span class="cov8" title="1">{
                if err := mm.CreateIndex(context.Background(), name, fields, "btree"); err != nil </span><span class="cov0" title="0">{
                        mm.logger.Warn("failed to create default index", "name", name, "error", err)
                }</span>
        }
}

func (mm *MetadataManager) updateIndexes(key string, metadata *ObjectMetadata) <span class="cov8" title="1">{
        mm.indexMutex.Lock()
        defer mm.indexMutex.Unlock()
        
        for _, index := range mm.indexes </span><span class="cov8" title="1">{
                mm.updateIndex(index, key, metadata)
        }</span>
}

func (mm *MetadataManager) updateIndex(index *MetadataIndex, key string, metadata *ObjectMetadata) <span class="cov8" title="1">{
        for _, field := range index.Fields </span><span class="cov8" title="1">{
                value := mm.extractFieldValue(metadata, field)
                if value != "" </span><span class="cov8" title="1">{
                        if keys, exists := index.Values[value]; exists </span><span class="cov8" title="1">{
                                // Check if key already exists
                                found := false
                                for _, k := range keys </span><span class="cov8" title="1">{
                                        if k == key </span><span class="cov8" title="1">{
                                                found = true
                                                break</span>
                                        }
                                }
                                <span class="cov8" title="1">if !found </span><span class="cov0" title="0">{
                                        index.Values[value] = append(keys, key)
                                }</span>
                        } else<span class="cov8" title="1"> {
                                index.Values[value] = []string{key}
                        }</span>
                }
        }
        
        <span class="cov8" title="1">index.UpdatedAt = time.Now()
        index.Stats.UpdateCount++</span>
}

func (mm *MetadataManager) removeFromIndexes(key string, metadata *ObjectMetadata) <span class="cov8" title="1">{
        if metadata == nil </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov8" title="1">mm.indexMutex.Lock()
        defer mm.indexMutex.Unlock()
        
        for _, index := range mm.indexes </span><span class="cov8" title="1">{
                mm.removeFromIndex(index, key, metadata)
        }</span>
}

func (mm *MetadataManager) removeFromIndex(index *MetadataIndex, key string, metadata *ObjectMetadata) <span class="cov8" title="1">{
        for _, field := range index.Fields </span><span class="cov8" title="1">{
                value := mm.extractFieldValue(metadata, field)
                if value != "" </span><span class="cov8" title="1">{
                        if keys, exists := index.Values[value]; exists </span><span class="cov8" title="1">{
                                // Remove key from slice
                                var newKeys []string
                                for _, k := range keys </span><span class="cov8" title="1">{
                                        if k != key </span><span class="cov0" title="0">{
                                                newKeys = append(newKeys, k)
                                        }</span>
                                }
                                
                                <span class="cov8" title="1">if len(newKeys) == 0 </span><span class="cov8" title="1">{
                                        delete(index.Values, value)
                                }</span> else<span class="cov0" title="0"> {
                                        index.Values[value] = newKeys
                                }</span>
                        }
                }
        }
        
        <span class="cov8" title="1">index.UpdatedAt = time.Now()</span>
}

func (mm *MetadataManager) buildIndex(ctx context.Context, index *MetadataIndex) <span class="cov8" title="1">{
        mm.logger.Info("building metadata index", "name", index.Name)
        
        // Get all metadata from backend
        allMetadata, err := mm.listFromBackend("", nil)
        if err != nil </span><span class="cov0" title="0">{
                mm.logger.Error("failed to load metadata for index building", "error", err)
                return
        }</span>
        
        // Build index
        <span class="cov8" title="1">for _, metadata := range allMetadata </span><span class="cov8" title="1">{
                mm.updateIndex(index, metadata.Key, metadata)
        }</span>
        
        <span class="cov8" title="1">index.Stats.TotalEntries = int64(len(allMetadata))
        index.Stats.UniqueValues = int64(len(index.Values))
        index.Stats.LastUpdated = time.Now()
        
        mm.logger.Info("metadata index built", "name", index.Name, "entries", index.Stats.TotalEntries)</span>
}

// Search implementation

func (mm *MetadataManager) selectBestIndex(query *MetadataQuery) string <span class="cov8" title="1">{
        mm.indexMutex.RLock()
        defer mm.indexMutex.RUnlock()
        
        var bestIndex string
        var bestScore int
        
        for name, index := range mm.indexes </span><span class="cov8" title="1">{
                score := mm.calculateIndexScore(index, query)
                if score &gt; bestScore </span><span class="cov8" title="1">{
                        bestScore = score
                        bestIndex = name
                }</span>
        }
        
        <span class="cov8" title="1">return bestIndex</span>
}

func (mm *MetadataManager) calculateIndexScore(index *MetadataIndex, query *MetadataQuery) int <span class="cov8" title="1">{
        score := 0
        
        // Check if index fields match query conditions
        for _, condition := range query.Conditions </span><span class="cov8" title="1">{
                for _, field := range index.Fields </span><span class="cov8" title="1">{
                        if field == condition.Field </span><span class="cov8" title="1">{
                                score += 10
                                
                                // Bonus for exact match operators
                                if condition.Operator == "eq" </span><span class="cov8" title="1">{
                                        score += 5
                                }</span>
                        }
                }
        }
        
        // Check sorting field
        <span class="cov8" title="1">if query.Sort != nil </span><span class="cov0" title="0">{
                for _, field := range index.Fields </span><span class="cov0" title="0">{
                        if field == query.Sort.Field </span><span class="cov0" title="0">{
                                score += 3
                        }</span>
                }
        }
        
        <span class="cov8" title="1">return score</span>
}

func (mm *MetadataManager) searchWithIndex(ctx context.Context, query *MetadataQuery, indexName string) ([]*ObjectMetadata, error) <span class="cov8" title="1">{
        mm.indexMutex.RLock()
        index, exists := mm.indexes[indexName]
        mm.indexMutex.RUnlock()
        
        if !exists </span><span class="cov0" title="0">{
                return mm.searchWithoutIndex(ctx, query)
        }</span>
        
        <span class="cov8" title="1">var candidateKeys []string
        
        // Find candidate keys using index
        for _, condition := range query.Conditions </span><span class="cov8" title="1">{
                if mm.isFieldIndexed(index, condition.Field) </span><span class="cov8" title="1">{
                        keys := mm.getKeysFromIndex(index, condition)
                        if candidateKeys == nil </span><span class="cov8" title="1">{
                                candidateKeys = keys
                        }</span> else<span class="cov0" title="0"> {
                                candidateKeys = mm.intersectKeys(candidateKeys, keys)
                        }</span>
                }
        }
        
        // Load metadata for candidate keys
        <span class="cov8" title="1">var results []*ObjectMetadata
        for _, key := range candidateKeys </span><span class="cov8" title="1">{
                metadata, err := mm.Get(ctx, key)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                // Apply additional filtering
                <span class="cov8" title="1">if mm.matchesQuery(metadata, query) </span><span class="cov8" title="1">{
                        results = append(results, metadata)
                }</span>
        }
        
        <span class="cov8" title="1">index.Stats.QueryCount++
        
        return results, nil</span>
}

func (mm *MetadataManager) searchWithoutIndex(ctx context.Context, query *MetadataQuery) ([]*ObjectMetadata, error) <span class="cov8" title="1">{
        // Full scan
        allMetadata, err := mm.listFromBackend("", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov8" title="1">var results []*ObjectMetadata
        for _, metadata := range allMetadata </span><span class="cov8" title="1">{
                if mm.matchesQuery(metadata, query) </span><span class="cov8" title="1">{
                        results = append(results, metadata)
                }</span>
        }
        
        <span class="cov8" title="1">return results, nil</span>
}

func (mm *MetadataManager) applySortingAndPagination(results []*ObjectMetadata, query *MetadataQuery) []*ObjectMetadata <span class="cov8" title="1">{
        // Apply sorting
        if query.Sort != nil </span><span class="cov0" title="0">{
                sort.Slice(results, func(i, j int) bool </span><span class="cov0" title="0">{
                        return mm.compareMetadata(results[i], results[j], query.Sort)
                }</span>)
        }
        
        // Apply pagination
        <span class="cov8" title="1">start := query.Offset
        if start &lt; 0 </span><span class="cov0" title="0">{
                start = 0
        }</span>
        <span class="cov8" title="1">if start &gt;= len(results) </span><span class="cov0" title="0">{
                return []*ObjectMetadata{}
        }</span>
        
        <span class="cov8" title="1">end := start + query.Limit
        if query.Limit &lt;= 0 || end &gt; len(results) </span><span class="cov8" title="1">{
                end = len(results)
        }</span>
        
        <span class="cov8" title="1">return results[start:end]</span>
}

// Helper methods

func (mm *MetadataManager) extractFieldValue(metadata *ObjectMetadata, field string) string <span class="cov8" title="1">{
        switch field </span>{
        case "key":<span class="cov0" title="0">
                return metadata.Key</span>
        case "size":<span class="cov8" title="1">
                return fmt.Sprintf("%d", metadata.Size)</span>
        case "content_type":<span class="cov8" title="1">
                return metadata.ContentType</span>
        case "hash":<span class="cov8" title="1">
                return metadata.Hash</span>
        case "version":<span class="cov0" title="0">
                return metadata.Version</span>
        case "created_at":<span class="cov8" title="1">
                return metadata.CreatedAt.Format(time.RFC3339)</span>
        case "updated_at":<span class="cov8" title="1">
                return metadata.UpdatedAt.Format(time.RFC3339)</span>
        case "accessed_at":<span class="cov0" title="0">
                return metadata.AccessedAt.Format(time.RFC3339)</span>
        default:<span class="cov8" title="1">
                if metadata.Attributes != nil </span><span class="cov8" title="1">{
                        if value, exists := metadata.Attributes[field]; exists </span><span class="cov8" title="1">{
                                return fmt.Sprintf("%v", value)
                        }</span>
                }
                <span class="cov0" title="0">return ""</span>
        }
}

func (mm *MetadataManager) isFieldIndexed(index *MetadataIndex, field string) bool <span class="cov8" title="1">{
        for _, indexField := range index.Fields </span><span class="cov8" title="1">{
                if indexField == field </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (mm *MetadataManager) getKeysFromIndex(index *MetadataIndex, condition *QueryCondition) []string <span class="cov8" title="1">{
        value := fmt.Sprintf("%v", condition.Value)
        
        switch condition.Operator </span>{
        case "eq":<span class="cov8" title="1">
                if keys, exists := index.Values[value]; exists </span><span class="cov8" title="1">{
                        return keys
                }</span>
                <span class="cov0" title="0">return []string{}</span>
        case "ne":<span class="cov0" title="0">
                var allKeys []string
                for v, keys := range index.Values </span><span class="cov0" title="0">{
                        if v != value </span><span class="cov0" title="0">{
                                allKeys = append(allKeys, keys...)
                        }</span>
                }
                <span class="cov0" title="0">return allKeys</span>
        default:<span class="cov0" title="0">
                // For other operators, return all keys for full evaluation
                var allKeys []string
                for _, keys := range index.Values </span><span class="cov0" title="0">{
                        allKeys = append(allKeys, keys...)
                }</span>
                <span class="cov0" title="0">return allKeys</span>
        }
}

func (mm *MetadataManager) intersectKeys(keys1, keys2 []string) []string <span class="cov0" title="0">{
        keyMap := make(map[string]bool)
        for _, key := range keys1 </span><span class="cov0" title="0">{
                keyMap[key] = true
        }</span>
        
        <span class="cov0" title="0">var result []string
        for _, key := range keys2 </span><span class="cov0" title="0">{
                if keyMap[key] </span><span class="cov0" title="0">{
                        result = append(result, key)
                }</span>
        }
        
        <span class="cov0" title="0">return result</span>
}

func (mm *MetadataManager) matchesQuery(metadata *ObjectMetadata, query *MetadataQuery) bool <span class="cov8" title="1">{
        for _, condition := range query.Conditions </span><span class="cov8" title="1">{
                if !mm.matchesCondition(metadata, condition) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        
        // TODO: Implement full-text search
        <span class="cov8" title="1">if query.FullText != "" </span><span class="cov0" title="0">{
                // Simplified full-text search
                searchText := strings.ToLower(query.FullText)
                if !strings.Contains(strings.ToLower(metadata.Key), searchText) &amp;&amp;
                   !strings.Contains(strings.ToLower(metadata.ContentType), searchText) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        
        <span class="cov8" title="1">return true</span>
}

func (mm *MetadataManager) matchesCondition(metadata *ObjectMetadata, condition *QueryCondition) bool <span class="cov8" title="1">{
        fieldValue := mm.extractFieldValue(metadata, condition.Field)
        conditionValue := fmt.Sprintf("%v", condition.Value)
        
        switch condition.Operator </span>{
        case "eq":<span class="cov8" title="1">
                return fieldValue == conditionValue</span>
        case "ne":<span class="cov0" title="0">
                return fieldValue != conditionValue</span>
        case "like":<span class="cov0" title="0">
                return strings.Contains(strings.ToLower(fieldValue), strings.ToLower(conditionValue))</span>
        case "gt", "gte", "lt", "lte":<span class="cov0" title="0">
                // Numeric comparison (simplified)
                return mm.compareValues(fieldValue, conditionValue, condition.Operator)</span>
        case "in":<span class="cov0" title="0">
                // TODO: Implement IN operator
                return false</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

func (mm *MetadataManager) compareValues(value1, value2, operator string) bool <span class="cov0" title="0">{
        // Simplified comparison (would need proper type handling)
        switch operator </span>{
        case "gt":<span class="cov0" title="0">
                return value1 &gt; value2</span>
        case "gte":<span class="cov0" title="0">
                return value1 &gt;= value2</span>
        case "lt":<span class="cov0" title="0">
                return value1 &lt; value2</span>
        case "lte":<span class="cov0" title="0">
                return value1 &lt;= value2</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

func (mm *MetadataManager) compareMetadata(m1, m2 *ObjectMetadata, sort *SortOptions) bool <span class="cov0" title="0">{
        value1 := mm.extractFieldValue(m1, sort.Field)
        value2 := mm.extractFieldValue(m2, sort.Field)
        
        if sort.Order == "desc" </span><span class="cov0" title="0">{
                return value1 &gt; value2
        }</span>
        <span class="cov0" title="0">return value1 &lt; value2</span>
}

func (mm *MetadataManager) explainQuery(query *MetadataQuery, indexUsed string) string <span class="cov8" title="1">{
        if indexUsed != "" </span><span class="cov8" title="1">{
                return fmt.Sprintf("Used index: %s", indexUsed)
        }</span>
        <span class="cov8" title="1">return "Full table scan"</span>
}

// Statistics methods

func (mm *MetadataManager) updateLatencyStats(operation string, latency time.Duration) <span class="cov8" title="1">{
        mm.statsMutex.Lock()
        defer mm.statsMutex.Unlock()
        
        latencyMs := latency.Milliseconds()
        
        var stats *LatencyStats
        switch operation </span>{
        case "get":<span class="cov8" title="1">
                stats = mm.stats.Performance.GetLatency</span>
        case "set":<span class="cov8" title="1">
                stats = mm.stats.Performance.SetLatency</span>
        case "search":<span class="cov8" title="1">
                stats = mm.stats.Performance.SearchLatency</span>
        case "index":<span class="cov8" title="1">
                stats = mm.stats.Performance.IndexLatency</span>
        default:<span class="cov8" title="1">
                return</span>
        }
        
        <span class="cov8" title="1">if stats.Samples == 0 </span><span class="cov8" title="1">{
                stats.Min = latencyMs
                stats.Max = latencyMs
                stats.Mean = float64(latencyMs)
        }</span> else<span class="cov8" title="1"> {
                if latencyMs &lt; stats.Min </span><span class="cov0" title="0">{
                        stats.Min = latencyMs
                }</span>
                <span class="cov8" title="1">if latencyMs &gt; stats.Max </span><span class="cov0" title="0">{
                        stats.Max = latencyMs
                }</span>
                <span class="cov8" title="1">stats.Mean = (stats.Mean*float64(stats.Samples) + float64(latencyMs)) / float64(stats.Samples+1)</span>
        }
        
        <span class="cov8" title="1">stats.Samples++</span>
}

func (mm *MetadataManager) incrementOperationCount(operation string) <span class="cov8" title="1">{
        mm.statsMutex.Lock()
        defer mm.statsMutex.Unlock()
        
        mm.stats.OperationCounts[operation]++
}</span>

func (mm *MetadataManager) incrementCacheHits() <span class="cov8" title="1">{
        mm.statsMutex.Lock()
        defer mm.statsMutex.Unlock()
        
        mm.stats.CacheHits++
}</span>

func (mm *MetadataManager) incrementCacheMisses() <span class="cov8" title="1">{
        mm.statsMutex.Lock()
        defer mm.statsMutex.Unlock()
        
        mm.stats.CacheMisses++
}</span>

// Background routines

func (mm *MetadataManager) syncRoutine() <span class="cov8" title="1">{
        if mm.config.SyncInterval &lt;= 0 </span><span class="cov8" title="1">{
                return
        }</span>
        
        <span class="cov8" title="1">ticker := time.NewTicker(mm.config.SyncInterval)
        defer ticker.Stop()
        
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-mm.ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        mm.performSync()</span>
                }
        }
}

func (mm *MetadataManager) compactionRoutine() <span class="cov8" title="1">{
        if mm.config.CompactInterval &lt;= 0 </span><span class="cov8" title="1">{
                return
        }</span>
        
        <span class="cov8" title="1">ticker := time.NewTicker(mm.config.CompactInterval)
        defer ticker.Stop()
        
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-mm.ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        mm.performCompaction()</span>
                }
        }
}

func (mm *MetadataManager) cacheMaintenanceRoutine() <span class="cov8" title="1">{
        ticker := time.NewTicker(5 * time.Minute)
        defer ticker.Stop()
        
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-mm.ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        mm.performCacheMaintenance()</span>
                }
        }
}

func (mm *MetadataManager) statsCollectionRoutine() <span class="cov8" title="1">{
        ticker := time.NewTicker(1 * time.Minute)
        defer ticker.Stop()
        
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-mm.ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        mm.collectStats()</span>
                }
        }
}

func (mm *MetadataManager) performSync() <span class="cov0" title="0">{
        if mm.levelDB != nil </span>{<span class="cov0" title="0">
                // Force sync to disk
                // LevelDB doesn't have explicit sync, but compaction helps
        }</span>
        
        <span class="cov0" title="0">mm.statsMutex.Lock()
        mm.stats.LastSync = time.Now()
        mm.statsMutex.Unlock()</span>
}

func (mm *MetadataManager) performCompaction() <span class="cov0" title="0">{
        if mm.levelDB != nil </span><span class="cov0" title="0">{
                // Compact database
                mm.levelDB.CompactRange(util.Range{})
        }</span>
        
        <span class="cov0" title="0">mm.statsMutex.Lock()
        mm.stats.LastCompaction = time.Now()
        mm.statsMutex.Unlock()</span>
}

func (mm *MetadataManager) performCacheMaintenance() <span class="cov0" title="0">{
        mm.cacheMutex.Lock()
        defer mm.cacheMutex.Unlock()
        
        // Remove stale cache entries
        cutoff := time.Now().Add(-1 * time.Hour)
        for key, cached := range mm.cache </span><span class="cov0" title="0">{
                if cached.LastAccess.Before(cutoff) &amp;&amp; cached.AccessCount &lt; 5 </span><span class="cov0" title="0">{
                        delete(mm.cache, key)
                        mm.cacheSize--
                }</span>
        }
}

func (mm *MetadataManager) collectStats() <span class="cov0" title="0">{
        // Update cache statistics
        mm.cacheMutex.RLock()
        cacheSize := len(mm.cache)
        mm.cacheMutex.RUnlock()
        
        mm.logger.Debug("metadata stats", "cache_size", cacheSize, "total_objects", mm.stats.TotalObjects)
}</span>

// FileSystemMetadata implementation

func (fsm *FileSystemMetadata) store(key string, data []byte) error <span class="cov8" title="1">{
        safePath := strings.ReplaceAll(key, "/", string(filepath.Separator))
        metaPath := filepath.Join(fsm.basePath, safePath+".meta")
        
        if err := os.MkdirAll(filepath.Dir(metaPath), 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">return os.WriteFile(metaPath, data, 0644)</span>
}

func (fsm *FileSystemMetadata) load(key string) ([]byte, error) <span class="cov8" title="1">{
        safePath := strings.ReplaceAll(key, "/", string(filepath.Separator))
        metaPath := filepath.Join(fsm.basePath, safePath+".meta")
        
        data, err := os.ReadFile(metaPath)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return nil, &amp;StorageError{
                                Code:    ErrCodeNotFound,
                                Message: "metadata not found",
                        }
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        
        <span class="cov0" title="0">return data, nil</span>
}

func (fsm *FileSystemMetadata) delete(key string) error <span class="cov8" title="1">{
        safePath := strings.ReplaceAll(key, "/", string(filepath.Separator))
        metaPath := filepath.Join(fsm.basePath, safePath+".meta")
        
        err := os.Remove(metaPath)
        if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

func (fsm *FileSystemMetadata) list(prefix string, options *ListOptions) ([]*ObjectMetadata, error) <span class="cov8" title="1">{
        var results []*ObjectMetadata
        
        err := filepath.Walk(fsm.basePath, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                <span class="cov8" title="1">if info.IsDir() || !strings.HasSuffix(path, ".meta") </span><span class="cov8" title="1">{
                        return nil
                }</span>
                
                // Extract key
                <span class="cov8" title="1">relPath, err := filepath.Rel(fsm.basePath, path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                <span class="cov8" title="1">key := strings.TrimSuffix(relPath, ".meta")
                key = strings.ReplaceAll(key, string(filepath.Separator), "/")
                
                if prefix != "" &amp;&amp; !strings.HasPrefix(key, prefix) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                
                // Load metadata
                <span class="cov8" title="1">data, err := os.ReadFile(path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                <span class="cov8" title="1">var metadata ObjectMetadata
                if err := json.Unmarshal(data, &amp;metadata); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                <span class="cov8" title="1">results = append(results, &amp;metadata)
                
                if options != nil &amp;&amp; options.Limit &gt; 0 &amp;&amp; len(results) &gt;= options.Limit </span><span class="cov0" title="0">{
                        return filepath.SkipDir
                }</span>
                
                <span class="cov8" title="1">return nil</span>
        })
        
        <span class="cov8" title="1">return results, err</span>
}</pre>
		
		<pre class="file" id="file12" style="display: none">package storage

import (
        "context"
        "fmt"
        "log/slog"
        "math/rand"
        "sort"
        "sync"
        "time"
)

// ReplicationEngine manages data replication across storage nodes
type ReplicationEngine struct {
        logger *slog.Logger
        
        // Storage and node management
        localStorage Storage
        nodeManager  *NodeManager
        
        // Replication coordination
        coordinator *ReplicationCoordinator
        
        // Replication strategies
        strategies map[string]ReplicationStrategy
        
        // Configuration
        config *ReplicationConfig
        
        // Monitoring and health
        health      *ReplicationHealth
        healthMutex sync.RWMutex
        
        // Background tasks
        ctx     context.Context
        cancel  context.CancelFunc
        started bool
        mu      sync.RWMutex
}

// ReplicationConfig contains configuration for replication
type ReplicationConfig struct {
        DefaultStrategy      string        `json:"default_strategy"`
        MinReplicas         int           `json:"min_replicas"`
        MaxReplicas         int           `json:"max_replicas"`
        ReplicationFactor   int           `json:"replication_factor"`
        ConsistencyLevel    string        `json:"consistency_level"`
        SyncTimeout         time.Duration `json:"sync_timeout"`
        HealthCheckInterval time.Duration `json:"health_check_interval"`
        MaxConcurrentSyncs  int           `json:"max_concurrent_syncs"`
        RetryAttempts       int           `json:"retry_attempts"`
        RetryDelay          time.Duration `json:"retry_delay"`
        QuorumSize          int           `json:"quorum_size"`
        EnableAsyncRepl     bool          `json:"enable_async_replication"`
        EnableCompression   bool          `json:"enable_compression"`
        BandwidthLimit      int64         `json:"bandwidth_limit_bps"`
}

// NodeManager manages storage nodes in the cluster
type NodeManager struct {
        logger *slog.Logger
        
        // Node registry
        nodes      map[string]*StorageNode
        nodesMutex sync.RWMutex
        
        // Node selection and ranking
        selector *NodeSelector
        
        // Health monitoring
        healthChecker *NodeHealthChecker
        
        // Configuration
        config *NodeManagerConfig
}

// NodeManagerConfig contains configuration for node management
type NodeManagerConfig struct {
        HeartbeatInterval   time.Duration `json:"heartbeat_interval"`
        FailureTimeout      time.Duration `json:"failure_timeout"`
        MaxFailures         int           `json:"max_failures"`
        EnableLoadBalancing bool          `json:"enable_load_balancing"`
        PreferLocalReplicas bool          `json:"prefer_local_replicas"`
}

// StorageNode represents a storage node in the cluster
type StorageNode struct {
        ID           string                 `json:"id"`
        Address      string                 `json:"address"`
        Port         int                    `json:"port"`
        Region       string                 `json:"region"`
        Zone         string                 `json:"zone"`
        Datacenter   string                 `json:"datacenter"`
        Capabilities []string               `json:"capabilities"`
        Capacity     *NodeCapacity          `json:"capacity"`
        Health       *NodeHealthStatus      `json:"health"`
        Metadata     map[string]interface{} `json:"metadata"`
        
        // Runtime state
        Status       string    `json:"status"`
        LastSeen     time.Time `json:"last_seen"`
        JoinedAt     time.Time `json:"joined_at"`
        FailureCount int       `json:"failure_count"`
        
        // Performance metrics
        Latency      time.Duration `json:"latency"`
        Bandwidth    int64         `json:"bandwidth"`
        LoadFactor   float64       `json:"load_factor"`
        
        // Connection state
        Connected    bool      `json:"connected"`
        LastPing     time.Time `json:"last_ping"`
        
        mutex sync.RWMutex
}

// NodeCapacity represents node storage capacity
type NodeCapacity struct {
        TotalBytes     int64   `json:"total_bytes"`
        UsedBytes      int64   `json:"used_bytes"`
        AvailableBytes int64   `json:"available_bytes"`
        UsagePercent   float64 `json:"usage_percent"`
        ObjectCount    int64   `json:"object_count"`
}

// NodeHealthStatus represents node health information
type NodeHealthStatus struct {
        Status         string            `json:"status"` // healthy, degraded, unhealthy, down
        LastCheck      time.Time         `json:"last_check"`
        Checks         map[string]bool   `json:"checks"`
        Errors         []string          `json:"errors"`
        Warnings       []string          `json:"warnings"`
        ResponseTime   time.Duration     `json:"response_time"`
        SuccessRate    float64           `json:"success_rate"`
        TotalRequests  int64             `json:"total_requests"`
        FailedRequests int64             `json:"failed_requests"`
}

// ReplicationCoordinator coordinates replication operations
type ReplicationCoordinator struct {
        engine *ReplicationEngine
        logger *slog.Logger
        
        // Operation queues
        replicationQueue chan *ReplicationOperation
        syncQueue        chan *SyncOperation
        
        // Worker pools
        replWorkers []*ReplicationEngineWorker
        syncWorkers []*SyncWorker
        
        // Operation tracking
        operations      map[string]*ReplicationOperation
        operationsMutex sync.RWMutex
        
        ctx    context.Context
        cancel context.CancelFunc
}

// ReplicationOperation represents a replication operation
type ReplicationOperation struct {
        ID            string              `json:"id"`
        Type          string              `json:"type"` // replicate, sync, remove, verify
        Key           string              `json:"key"`
        SourceNode    string              `json:"source_node"`
        TargetNodes   []string            `json:"target_nodes"`
        Strategy      string              `json:"strategy"`
        Priority      int                 `json:"priority"`
        Status        string              `json:"status"`
        Progress      float64             `json:"progress"`
        BytesTotal    int64               `json:"bytes_total"`
        BytesReplicated int64             `json:"bytes_replicated"`
        StartTime     time.Time           `json:"start_time"`
        EndTime       time.Time           `json:"end_time"`
        Error         string              `json:"error,omitempty"`
        RetryCount    int                 `json:"retry_count"`
        Metadata      map[string]interface{} `json:"metadata"`
        
        // Channels for coordination
        ResultChan chan error `json:"-"`
        CancelChan chan struct{} `json:"-"`
}

// SyncOperation represents a data synchronization operation
type SyncOperation struct {
        ID          string    `json:"id"`
        Key         string    `json:"key"`
        SourceNode  string    `json:"source_node"`
        TargetNode  string    `json:"target_node"`
        SyncType    string    `json:"sync_type"` // full, incremental, checksum
        Status      string    `json:"status"`
        StartTime   time.Time `json:"start_time"`
        EndTime     time.Time `json:"end_time"`
        Error       string    `json:"error,omitempty"`
        Checksum    string    `json:"checksum"`
        BytesTransferred int64 `json:"bytes_transferred"`
}

// ReplicationStrategy defines how data should be replicated
type ReplicationStrategy interface {
        GetName() string
        SelectTargetNodes(sourceNode string, nodes []*StorageNode, policy *ReplicationPolicy) ([]*StorageNode, error)
        GetReplicationOrder(sourceNode string, targetNodes []*StorageNode) []*StorageNode
        ShouldReplicate(key string, metadata *ObjectMetadata, policy *ReplicationPolicy) bool
        GetConsistencyLevel() string
}

// EagerReplicationStrategy implements eager replication
type EagerReplicationStrategy struct {
        config *ReplicationConfig
}

// LazyReplicationStrategy implements lazy replication
type LazyReplicationStrategy struct {
        config *ReplicationConfig
}

// GeographicReplicationStrategy implements geographic replication
type GeographicReplicationStrategy struct {
        config         *ReplicationConfig
        regionPriority map[string]int
}

// ReplicationEngineWorker handles replication tasks
type ReplicationEngineWorker struct {
        id          int
        coordinator *ReplicationCoordinator
        logger      *slog.Logger
        
        ctx    context.Context
        cancel context.CancelFunc
}

// SyncWorker handles synchronization tasks
type SyncWorker struct {
        id          int
        coordinator *ReplicationCoordinator
        logger      *slog.Logger
        
        ctx    context.Context
        cancel context.CancelFunc
}

// NodeSelector selects optimal nodes for replication
type NodeSelector struct {
        manager *NodeManager
        logger  *slog.Logger
        
        // Selection strategies
        strategies map[string]SelectionStrategy
}

// SelectionStrategy defines node selection algorithms
type SelectionStrategy interface {
        SelectNodes(availableNodes []*StorageNode, count int, constraints map[string]interface{}) ([]*StorageNode, error)
}

// LoadBalancedSelection implements load-balanced node selection
type LoadBalancedSelection struct{}

// GeographicSelection implements geographic-aware node selection
type GeographicSelection struct {
        preferredRegions []string
}

// CapacityBasedSelection implements capacity-based node selection
type CapacityBasedSelection struct{}

// NodeHealthChecker monitors node health
type NodeHealthChecker struct {
        manager *NodeManager
        logger  *slog.Logger
        
        // Health check configuration
        interval time.Duration
        timeout  time.Duration
        
        ctx    context.Context
        cancel context.CancelFunc
}

// ReplicationHealth tracks overall replication health
type ReplicationHealth struct {
        OverallStatus     string                 `json:"overall_status"`
        HealthyNodes      int                    `json:"healthy_nodes"`
        TotalNodes        int                    `json:"total_nodes"`
        ActiveOperations  int                    `json:"active_operations"`
        FailedOperations  int                    `json:"failed_operations"`
        ReplicationLag    time.Duration          `json:"replication_lag"`
        ConsistencyScore  float64                `json:"consistency_score"`
        ThroughputBPS     int64                  `json:"throughput_bps"`
        ErrorRate         float64                `json:"error_rate"`
        LastHealthCheck   time.Time              `json:"last_health_check"`
        RegionHealth      map[string]RegionHealth `json:"region_health"`
}

// RegionHealth tracks health per region
type RegionHealth struct {
        Region        string  `json:"region"`
        HealthyNodes  int     `json:"healthy_nodes"`
        TotalNodes    int     `json:"total_nodes"`
        AverageLatency time.Duration `json:"average_latency"`
        Status        string  `json:"status"`
}

// NewReplicationEngine creates a new replication engine
func NewReplicationEngine(
        localStorage Storage,
        config *ReplicationConfig,
        logger *slog.Logger,
) (*ReplicationEngine, error) <span class="cov8" title="1">{
        ctx, cancel := context.WithCancel(context.Background())
        
        // Create node manager
        nodeManager, err := NewNodeManager(&amp;NodeManagerConfig{
                HeartbeatInterval:   30 * time.Second,
                FailureTimeout:      2 * time.Minute,
                MaxFailures:         3,
                EnableLoadBalancing: true,
                PreferLocalReplicas: true,
        }, logger)
        if err != nil </span><span class="cov0" title="0">{
                cancel()
                return nil, fmt.Errorf("failed to create node manager: %w", err)
        }</span>
        
        <span class="cov8" title="1">re := &amp;ReplicationEngine{
                logger:      logger,
                localStorage: localStorage,
                nodeManager: nodeManager,
                strategies:  make(map[string]ReplicationStrategy),
                config:      config,
                health: &amp;ReplicationHealth{
                        RegionHealth: make(map[string]RegionHealth),
                },
                ctx:    ctx,
                cancel: cancel,
        }
        
        // Create coordinator
        re.coordinator = &amp;ReplicationCoordinator{
                engine:           re,
                logger:           logger,
                replicationQueue: make(chan *ReplicationOperation, 1000),
                syncQueue:        make(chan *SyncOperation, 1000),
                operations:       make(map[string]*ReplicationOperation),
                ctx:              ctx,
                cancel:           cancel,
        }
        
        // Register default strategies
        re.registerDefaultStrategies()
        
        return re, nil</span>
}

// Start starts the replication engine
func (re *ReplicationEngine) Start(ctx context.Context) error <span class="cov8" title="1">{
        re.mu.Lock()
        defer re.mu.Unlock()
        
        if re.started </span><span class="cov0" title="0">{
                return fmt.Errorf("replication engine already started")
        }</span>
        
        // Start node manager
        <span class="cov8" title="1">if err := re.nodeManager.Start(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start node manager: %w", err)
        }</span>
        
        // Start coordinator
        <span class="cov8" title="1">if err := re.coordinator.Start(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start coordinator: %w", err)
        }</span>
        
        // Start background routines
        <span class="cov8" title="1">go re.healthMonitorRoutine()
        go re.maintenanceRoutine()
        
        re.started = true
        re.logger.Info("replication engine started")
        
        return nil</span>
}

// Stop stops the replication engine
func (re *ReplicationEngine) Stop(ctx context.Context) error <span class="cov8" title="1">{
        re.mu.Lock()
        defer re.mu.Unlock()
        
        if !re.started </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov8" title="1">re.cancel()
        
        // Stop coordinator
        if err := re.coordinator.Stop(ctx); err != nil </span><span class="cov0" title="0">{
                re.logger.Error("failed to stop coordinator", "error", err)
        }</span>
        
        // Stop node manager
        <span class="cov8" title="1">if err := re.nodeManager.Stop(ctx); err != nil </span><span class="cov0" title="0">{
                re.logger.Error("failed to stop node manager", "error", err)
        }</span>
        
        <span class="cov8" title="1">re.started = false
        re.logger.Info("replication engine stopped")
        
        return nil</span>
}

// Replicate replicates an object according to policy
func (re *ReplicationEngine) Replicate(ctx context.Context, key string, policy *ReplicationPolicy) error <span class="cov8" title="1">{
        metadata, err := re.localStorage.GetMetadata(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get metadata: %w", err)
        }</span>
        
        // Get replication strategy
        <span class="cov8" title="1">strategy, exists := re.strategies[policy.Strategy]
        if !exists </span><span class="cov0" title="0">{
                strategy = re.strategies[re.config.DefaultStrategy]
        }</span>
        
        // Check if replication is needed
        <span class="cov8" title="1">if !strategy.ShouldReplicate(key, metadata, policy) </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        // Get available nodes
        <span class="cov8" title="1">nodes := re.nodeManager.GetHealthyNodes()
        
        // Select target nodes
        targetNodes, err := strategy.SelectTargetNodes("local", nodes, policy)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to select target nodes: %w", err)
        }</span>
        
        <span class="cov8" title="1">if len(targetNodes) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no suitable target nodes available")
        }</span>
        
        // Create replication operation
        <span class="cov8" title="1">operation := &amp;ReplicationOperation{
                ID:          generateOperationID(),
                Type:        "replicate",
                Key:         key,
                SourceNode:  "local",
                TargetNodes: extractNodeIDs(targetNodes),
                Strategy:    strategy.GetName(),
                Priority:    policy.Priority,
                Status:      "pending",
                Progress:    0.0,
                BytesTotal:  metadata.Size,
                StartTime:   time.Now(),
                ResultChan:  make(chan error, 1),
                CancelChan:  make(chan struct{}),
                Metadata:    make(map[string]interface{}),
        }
        
        // Submit operation
        select </span>{
        case re.coordinator.replicationQueue &lt;- operation:<span class="cov8" title="1"></span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        case &lt;-time.After(5 * time.Second):<span class="cov0" title="0">
                return fmt.Errorf("replication queue full")</span>
        }
        
        // Wait for result based on consistency level
        <span class="cov8" title="1">if policy.ConsistencyLevel == "strong" </span><span class="cov8" title="1">{
                select </span>{
                case err := &lt;-operation.ResultChan:<span class="cov8" title="1">
                        return err</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                }
        }
        
        <span class="cov0" title="0">return nil</span>
}

// GetReplicationStatus gets the status of a key's replication
func (re *ReplicationEngine) GetReplicationStatus(ctx context.Context, key string) (*ReplicationStatus, error) <span class="cov8" title="1">{
        // Query all nodes for replica information
        nodes := re.nodeManager.GetHealthyNodes()
        
        status := &amp;ReplicationStatus{
                Key:             key,
                CurrentReplicas: 0,
                HealthyReplicas: 0,
                ReplicaNodes:    []string{},
                SyncStatus:      make(map[string]string),
                LastSync:        time.Now(),
        }
        
        // Check local copy
        if exists, err := re.localStorage.Exists(ctx, key); err == nil &amp;&amp; exists </span><span class="cov8" title="1">{
                status.CurrentReplicas++
                status.HealthyReplicas++
                status.ReplicaNodes = append(status.ReplicaNodes, "local")
                status.SyncStatus["local"] = "healthy"
        }</span>
        
        // Check remote replicas
        <span class="cov8" title="1">for _, node := range nodes </span><span class="cov8" title="1">{
                // TODO: Implement remote existence check
                re.logger.Debug("checking replica on node", "key", key, "node", node.ID)
        }</span>
        
        <span class="cov8" title="1">return status, nil</span>
}

// SynchronizeReplicas synchronizes all replicas of a key
func (re *ReplicationEngine) SynchronizeReplicas(ctx context.Context, key string) error <span class="cov0" title="0">{
        status, err := re.GetReplicationStatus(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov0" title="0">if len(status.ReplicaNodes) &lt;= 1 </span><span class="cov0" title="0">{
                return nil // No replicas to sync
        }</span>
        
        // Create sync operations
        <span class="cov0" title="0">sourceNode := status.ReplicaNodes[0] // Use first healthy replica as source
        
        for _, targetNode := range status.ReplicaNodes[1:] </span><span class="cov0" title="0">{
                syncOp := &amp;SyncOperation{
                        ID:         generateOperationID(),
                        Key:        key,
                        SourceNode: sourceNode,
                        TargetNode: targetNode,
                        SyncType:   "checksum",
                        Status:     "pending",
                        StartTime:  time.Now(),
                }
                
                select </span>{
                case re.coordinator.syncQueue &lt;- syncOp:<span class="cov0" title="0"></span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                default:<span class="cov0" title="0">
                        re.logger.Warn("sync queue full", "key", key)</span>
                }
        }
        
        <span class="cov0" title="0">return nil</span>
}

// GetHealth returns replication health status
func (re *ReplicationEngine) GetHealth(ctx context.Context) (*ReplicationHealth, error) <span class="cov8" title="1">{
        re.healthMutex.RLock()
        defer re.healthMutex.RUnlock()
        
        // Create a copy
        health := *re.health
        health.RegionHealth = make(map[string]RegionHealth)
        for k, v := range re.health.RegionHealth </span><span class="cov0" title="0">{
                health.RegionHealth[k] = v
        }</span>
        
        <span class="cov8" title="1">return &amp;health, nil</span>
}

// Node management methods

// AddNode adds a node to the cluster
func (re *ReplicationEngine) AddNode(ctx context.Context, node *StorageNode) error <span class="cov8" title="1">{
        return re.nodeManager.AddNode(ctx, node)
}</span>

// RemoveNode removes a node from the cluster
func (re *ReplicationEngine) RemoveNode(ctx context.Context, nodeID string) error <span class="cov8" title="1">{
        return re.nodeManager.RemoveNode(ctx, nodeID)
}</span>

// GetNodes returns all nodes in the cluster
func (re *ReplicationEngine) GetNodes(ctx context.Context) ([]*StorageNode, error) <span class="cov8" title="1">{
        return re.nodeManager.GetAllNodes(), nil
}</span>

// Private methods

func (re *ReplicationEngine) registerDefaultStrategies() <span class="cov8" title="1">{
        re.strategies["eager"] = &amp;EagerReplicationStrategy{config: re.config}
        re.strategies["lazy"] = &amp;LazyReplicationStrategy{config: re.config}
        re.strategies["geographic"] = &amp;GeographicReplicationStrategy{
                config:         re.config,
                regionPriority: make(map[string]int),
        }
}</span>

func (re *ReplicationEngine) healthMonitorRoutine() <span class="cov8" title="1">{
        ticker := time.NewTicker(re.config.HealthCheckInterval)
        defer ticker.Stop()
        
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-re.ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        re.updateHealth()</span>
                }
        }
}

func (re *ReplicationEngine) maintenanceRoutine() <span class="cov8" title="1">{
        ticker := time.NewTicker(1 * time.Hour)
        defer ticker.Stop()
        
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-re.ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        re.performMaintenance()</span>
                }
        }
}

func (re *ReplicationEngine) updateHealth() <span class="cov0" title="0">{
        re.healthMutex.Lock()
        defer re.healthMutex.Unlock()
        
        nodes := re.nodeManager.GetAllNodes()
        healthyNodes := 0
        totalNodes := len(nodes)
        
        regionStats := make(map[string]*RegionHealth)
        
        for _, node := range nodes </span><span class="cov0" title="0">{
                if node.Health.Status == "healthy" </span><span class="cov0" title="0">{
                        healthyNodes++
                }</span>
                
                // Update region stats
                <span class="cov0" title="0">region := node.Region
                if region == "" </span><span class="cov0" title="0">{
                        region = "default"
                }</span>
                
                <span class="cov0" title="0">if regionStats[region] == nil </span><span class="cov0" title="0">{
                        regionStats[region] = &amp;RegionHealth{
                                Region: region,
                                Status: "healthy",
                        }
                }</span>
                
                <span class="cov0" title="0">regionStats[region].TotalNodes++
                if node.Health.Status == "healthy" </span><span class="cov0" title="0">{
                        regionStats[region].HealthyNodes++
                }</span>
        }
        
        // Update overall health
        <span class="cov0" title="0">re.health.HealthyNodes = healthyNodes
        re.health.TotalNodes = totalNodes
        re.health.LastHealthCheck = time.Now()
        
        if float64(healthyNodes)/float64(totalNodes) &gt;= 0.8 </span><span class="cov0" title="0">{
                re.health.OverallStatus = "healthy"
        }</span> else<span class="cov0" title="0"> if float64(healthyNodes)/float64(totalNodes) &gt;= 0.5 </span><span class="cov0" title="0">{
                re.health.OverallStatus = "degraded"
        }</span> else<span class="cov0" title="0"> {
                re.health.OverallStatus = "unhealthy"
        }</span>
        
        // Update region health
        <span class="cov0" title="0">for region, stats := range regionStats </span><span class="cov0" title="0">{
                if float64(stats.HealthyNodes)/float64(stats.TotalNodes) &gt;= 0.8 </span><span class="cov0" title="0">{
                        stats.Status = "healthy"
                }</span> else<span class="cov0" title="0"> {
                        stats.Status = "degraded"
                }</span>
                <span class="cov0" title="0">re.health.RegionHealth[region] = *stats</span>
        }
}

func (re *ReplicationEngine) performMaintenance() <span class="cov0" title="0">{
        re.logger.Info("performing replication maintenance")
        
        // Clean up completed operations
        re.coordinator.cleanupOperations()
        
        // Check for under-replicated objects
        re.checkUnderReplicatedObjects()
        
        // Rebalance replicas if needed
        re.rebalanceReplicas()
}</span>

func (re *ReplicationEngine) checkUnderReplicatedObjects() <span class="cov0" title="0">{
        // TODO: Implement under-replication detection
        re.logger.Debug("checking for under-replicated objects")
}</span>

func (re *ReplicationEngine) rebalanceReplicas() <span class="cov0" title="0">{
        // TODO: Implement replica rebalancing
        re.logger.Debug("rebalancing replicas")
}</span>

// NodeManager implementation

func NewNodeManager(config *NodeManagerConfig, logger *slog.Logger) (*NodeManager, error) <span class="cov8" title="1">{
        nm := &amp;NodeManager{
                logger: logger,
                nodes:  make(map[string]*StorageNode),
                config: config,
        }
        
        // Create node selector
        nm.selector = &amp;NodeSelector{
                manager:    nm,
                logger:     logger,
                strategies: make(map[string]SelectionStrategy),
        }
        
        // Register selection strategies
        nm.selector.strategies["load_balanced"] = &amp;LoadBalancedSelection{}
        nm.selector.strategies["geographic"] = &amp;GeographicSelection{}
        nm.selector.strategies["capacity_based"] = &amp;CapacityBasedSelection{}
        
        // Create health checker
        nm.healthChecker = &amp;NodeHealthChecker{
                manager:  nm,
                logger:   logger,
                interval: config.HeartbeatInterval,
                timeout:  config.FailureTimeout,
        }
        
        return nm, nil
}</span>

func (nm *NodeManager) Start(ctx context.Context) error <span class="cov8" title="1">{
        // Start health checker
        return nm.healthChecker.Start(ctx)
}</span>

func (nm *NodeManager) Stop(ctx context.Context) error <span class="cov8" title="1">{
        // Stop health checker
        return nm.healthChecker.Stop(ctx)
}</span>

func (nm *NodeManager) AddNode(ctx context.Context, node *StorageNode) error <span class="cov8" title="1">{
        nm.nodesMutex.Lock()
        defer nm.nodesMutex.Unlock()
        
        node.JoinedAt = time.Now()
        node.LastSeen = time.Now()
        node.Status = "joining"
        node.Connected = true
        
        nm.nodes[node.ID] = node
        
        nm.logger.Info("node added", "node_id", node.ID, "address", node.Address)
        
        return nil
}</span>

func (nm *NodeManager) RemoveNode(ctx context.Context, nodeID string) error <span class="cov8" title="1">{
        nm.nodesMutex.Lock()
        defer nm.nodesMutex.Unlock()
        
        if node, exists := nm.nodes[nodeID]; exists </span><span class="cov8" title="1">{
                node.Status = "leaving"
                node.Connected = false
                delete(nm.nodes, nodeID)
                
                nm.logger.Info("node removed", "node_id", nodeID)
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

func (nm *NodeManager) GetAllNodes() []*StorageNode <span class="cov8" title="1">{
        nm.nodesMutex.RLock()
        defer nm.nodesMutex.RUnlock()
        
        nodes := make([]*StorageNode, 0, len(nm.nodes))
        for _, node := range nm.nodes </span><span class="cov8" title="1">{
                // Create a copy
                nodeCopy := *node
                nodes = append(nodes, &amp;nodeCopy)
        }</span>
        
        <span class="cov8" title="1">return nodes</span>
}

func (nm *NodeManager) GetHealthyNodes() []*StorageNode <span class="cov8" title="1">{
        allNodes := nm.GetAllNodes()
        var healthyNodes []*StorageNode
        
        for _, node := range allNodes </span><span class="cov8" title="1">{
                if node.Health.Status == "healthy" &amp;&amp; node.Connected </span><span class="cov8" title="1">{
                        healthyNodes = append(healthyNodes, node)
                }</span>
        }
        
        <span class="cov8" title="1">return healthyNodes</span>
}

func (nm *NodeManager) SelectNodes(strategy string, count int, constraints map[string]interface{}) ([]*StorageNode, error) <span class="cov0" title="0">{
        return nm.selector.SelectNodes(strategy, count, constraints)
}</span>

// NodeSelector implementation

func (ns *NodeSelector) SelectNodes(strategy string, count int, constraints map[string]interface{}) ([]*StorageNode, error) <span class="cov0" title="0">{
        availableNodes := ns.manager.GetHealthyNodes()
        
        if len(availableNodes) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no healthy nodes available")
        }</span>
        
        <span class="cov0" title="0">selectionStrategy, exists := ns.strategies[strategy]
        if !exists </span><span class="cov0" title="0">{
                selectionStrategy = ns.strategies["load_balanced"]
        }</span>
        
        <span class="cov0" title="0">return selectionStrategy.SelectNodes(availableNodes, count, constraints)</span>
}

// ReplicationCoordinator implementation

func (rc *ReplicationCoordinator) Start(ctx context.Context) error <span class="cov8" title="1">{
        // Start replication workers
        workerCount := rc.engine.config.MaxConcurrentSyncs
        if workerCount &lt;= 0 </span><span class="cov0" title="0">{
                workerCount = 10
        }</span>
        
        <span class="cov8" title="1">rc.replWorkers = make([]*ReplicationEngineWorker, workerCount)
        for i := 0; i &lt; workerCount; i++ </span><span class="cov8" title="1">{
                worker := &amp;ReplicationEngineWorker{
                        id:          i,
                        coordinator: rc,
                        logger:      rc.logger,
                        ctx:         ctx,
                }
                rc.replWorkers[i] = worker
                go worker.start()
        }</span>
        
        // Start sync workers
        <span class="cov8" title="1">rc.syncWorkers = make([]*SyncWorker, workerCount/2)
        for i := 0; i &lt; workerCount/2; i++ </span><span class="cov8" title="1">{
                worker := &amp;SyncWorker{
                        id:          i,
                        coordinator: rc,
                        logger:      rc.logger,
                        ctx:         ctx,
                }
                rc.syncWorkers[i] = worker
                go worker.start()
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

func (rc *ReplicationCoordinator) Stop(ctx context.Context) error <span class="cov8" title="1">{
        rc.cancel()
        return nil
}</span>

func (rc *ReplicationCoordinator) cleanupOperations() <span class="cov0" title="0">{
        rc.operationsMutex.Lock()
        defer rc.operationsMutex.Unlock()
        
        cutoff := time.Now().Add(-1 * time.Hour)
        for id, op := range rc.operations </span><span class="cov0" title="0">{
                if op.EndTime.Before(cutoff) &amp;&amp; (op.Status == "completed" || op.Status == "failed") </span><span class="cov0" title="0">{
                        delete(rc.operations, id)
                }</span>
        }
}

// ReplicationEngineWorker implementation

func (rw *ReplicationEngineWorker) start() <span class="cov8" title="1">{
        rw.logger.Info("replication worker started", "worker_id", rw.id)
        
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-rw.ctx.Done():<span class="cov0" title="0">
                        rw.logger.Info("replication worker stopped", "worker_id", rw.id)
                        return</span>
                case operation := &lt;-rw.coordinator.replicationQueue:<span class="cov8" title="1">
                        rw.processReplication(operation)</span>
                }
        }
}

func (rw *ReplicationEngineWorker) processReplication(operation *ReplicationOperation) <span class="cov8" title="1">{
        rw.logger.Info("processing replication", "worker_id", rw.id, "operation_id", operation.ID, "key", operation.Key)
        
        operation.Status = "in_progress"
        
        // Track operation
        rw.coordinator.operationsMutex.Lock()
        rw.coordinator.operations[operation.ID] = operation
        rw.coordinator.operationsMutex.Unlock()
        
        // Simulate replication work
        err := rw.performReplication(operation)
        
        // Update operation status
        if err != nil </span><span class="cov0" title="0">{
                operation.Status = "failed"
                operation.Error = err.Error()
                rw.logger.Error("replication failed", "worker_id", rw.id, "operation_id", operation.ID, "error", err)
        }</span> else<span class="cov8" title="1"> {
                operation.Status = "completed"
                operation.Progress = 100.0
                rw.logger.Info("replication completed", "worker_id", rw.id, "operation_id", operation.ID)
        }</span>
        
        <span class="cov8" title="1">operation.EndTime = time.Now()
        
        // Send result
        select </span>{
        case operation.ResultChan &lt;- err:<span class="cov8" title="1"></span>
        default:<span class="cov0" title="0"></span>
        }
}

func (rw *ReplicationEngineWorker) performReplication(operation *ReplicationOperation) error <span class="cov8" title="1">{
        // TODO: Implement actual replication logic
        // This would involve:
        // 1. Reading data from source
        // 2. Transferring to target nodes
        // 3. Verifying transfer integrity
        // 4. Updating progress
        
        // Simulate work
        time.Sleep(100 * time.Millisecond)
        
        return nil
}</span>

// SyncWorker implementation

func (sw *SyncWorker) start() <span class="cov8" title="1">{
        sw.logger.Info("sync worker started", "worker_id", sw.id)
        
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-sw.ctx.Done():<span class="cov0" title="0">
                        sw.logger.Info("sync worker stopped", "worker_id", sw.id)
                        return</span>
                case operation := &lt;-sw.coordinator.syncQueue:<span class="cov0" title="0">
                        sw.processSync(operation)</span>
                }
        }
}

func (sw *SyncWorker) processSync(operation *SyncOperation) <span class="cov0" title="0">{
        sw.logger.Info("processing sync", "worker_id", sw.id, "operation_id", operation.ID, "key", operation.Key)
        
        operation.Status = "in_progress"
        
        // TODO: Implement actual sync logic
        time.Sleep(50 * time.Millisecond)
        
        operation.Status = "completed"
        operation.EndTime = time.Now()
}</span>

// Strategy implementations

func (ers *EagerReplicationStrategy) GetName() string <span class="cov8" title="1">{
        return "eager"
}</span>

func (ers *EagerReplicationStrategy) SelectTargetNodes(sourceNode string, nodes []*StorageNode, policy *ReplicationPolicy) ([]*StorageNode, error) <span class="cov8" title="1">{
        if len(nodes) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no nodes available")
        }</span>
        
        // Sort nodes by health and capacity
        <span class="cov8" title="1">sortedNodes := make([]*StorageNode, len(nodes))
        copy(sortedNodes, nodes)
        
        sort.Slice(sortedNodes, func(i, j int) bool </span><span class="cov8" title="1">{
                scoreI := ers.calculateNodeScore(sortedNodes[i])
                scoreJ := ers.calculateNodeScore(sortedNodes[j])
                return scoreI &gt; scoreJ
        }</span>)
        
        // Select top nodes up to MinReplicas
        <span class="cov8" title="1">count := policy.MinReplicas
        if count &gt; len(sortedNodes) </span><span class="cov0" title="0">{
                count = len(sortedNodes)
        }</span>
        
        <span class="cov8" title="1">return sortedNodes[:count], nil</span>
}

func (ers *EagerReplicationStrategy) GetReplicationOrder(sourceNode string, targetNodes []*StorageNode) []*StorageNode <span class="cov0" title="0">{
        // For eager replication, replicate to all nodes in parallel
        return targetNodes
}</span>

func (ers *EagerReplicationStrategy) ShouldReplicate(key string, metadata *ObjectMetadata, policy *ReplicationPolicy) bool <span class="cov8" title="1">{
        // Always replicate in eager strategy
        return true
}</span>

func (ers *EagerReplicationStrategy) GetConsistencyLevel() string <span class="cov0" title="0">{
        return "strong"
}</span>

func (ers *EagerReplicationStrategy) calculateNodeScore(node *StorageNode) float64 <span class="cov8" title="1">{
        score := 0.0
        
        // Health score
        if node.Health.Status == "healthy" </span><span class="cov8" title="1">{
                score += 100.0
        }</span> else<span class="cov0" title="0"> if node.Health.Status == "degraded" </span><span class="cov0" title="0">{
                score += 50.0
        }</span>
        
        // Capacity score
        <span class="cov8" title="1">if node.Capacity != nil </span><span class="cov8" title="1">{
                availableRatio := float64(node.Capacity.AvailableBytes) / float64(node.Capacity.TotalBytes)
                score += availableRatio * 50.0
        }</span>
        
        // Load factor score
        <span class="cov8" title="1">score += (1.0 - node.LoadFactor) * 30.0
        
        return score</span>
}

// GeographicReplicationStrategy implementation

func (grs *GeographicReplicationStrategy) GetName() string <span class="cov0" title="0">{
        return "geographic"
}</span>

func (grs *GeographicReplicationStrategy) SelectTargetNodes(sourceNode string, nodes []*StorageNode, policy *ReplicationPolicy) ([]*StorageNode, error) <span class="cov0" title="0">{
        // Group nodes by region
        regionNodes := make(map[string][]*StorageNode)
        for _, node := range nodes </span><span class="cov0" title="0">{
                region := node.Region
                if region == "" </span><span class="cov0" title="0">{
                        region = "default"
                }</span>
                <span class="cov0" title="0">regionNodes[region] = append(regionNodes[region], node)</span>
        }
        
        <span class="cov0" title="0">var selectedNodes []*StorageNode
        targetCount := policy.MinReplicas
        
        // Select nodes from different regions for geographic distribution
        for _, regionNodeList := range regionNodes </span><span class="cov0" title="0">{
                if len(selectedNodes) &gt;= targetCount </span><span class="cov0" title="0">{
                        break</span>
                }
                
                // Select best node from this region
                <span class="cov0" title="0">if len(regionNodeList) &gt; 0 </span><span class="cov0" title="0">{
                        // Sort by health and capacity
                        sort.Slice(regionNodeList, func(i, j int) bool </span><span class="cov0" title="0">{
                                scoreI := grs.calculateNodeScore(regionNodeList[i])
                                scoreJ := grs.calculateNodeScore(regionNodeList[j])
                                return scoreI &gt; scoreJ
                        }</span>)
                        
                        <span class="cov0" title="0">selectedNodes = append(selectedNodes, regionNodeList[0])</span>
                }
        }
        
        <span class="cov0" title="0">return selectedNodes, nil</span>
}

func (grs *GeographicReplicationStrategy) GetReplicationOrder(sourceNode string, targetNodes []*StorageNode) []*StorageNode <span class="cov0" title="0">{
        return targetNodes
}</span>

func (grs *GeographicReplicationStrategy) ShouldReplicate(key string, metadata *ObjectMetadata, policy *ReplicationPolicy) bool <span class="cov0" title="0">{
        return true
}</span>

func (grs *GeographicReplicationStrategy) GetConsistencyLevel() string <span class="cov0" title="0">{
        return "eventual"
}</span>

func (grs *GeographicReplicationStrategy) calculateNodeScore(node *StorageNode) float64 <span class="cov0" title="0">{
        score := 0.0
        
        // Health score
        if node.Health.Status == "healthy" </span><span class="cov0" title="0">{
                score += 100.0
        }</span> else<span class="cov0" title="0"> if node.Health.Status == "degraded" </span><span class="cov0" title="0">{
                score += 50.0
        }</span>
        
        // Regional priority
        <span class="cov0" title="0">if priority, exists := grs.regionPriority[node.Region]; exists </span><span class="cov0" title="0">{
                score += float64(priority * 10)
        }</span>
        
        <span class="cov0" title="0">return score</span>
}

// LazyReplicationStrategy implementation

func (lrs *LazyReplicationStrategy) GetName() string <span class="cov0" title="0">{
        return "lazy"
}</span>

func (lrs *LazyReplicationStrategy) SelectTargetNodes(sourceNode string, nodes []*StorageNode, policy *ReplicationPolicy) ([]*StorageNode, error) <span class="cov0" title="0">{
        // For lazy replication, select fewer nodes initially
        count := policy.MinReplicas / 2
        if count == 0 </span><span class="cov0" title="0">{
                count = 1
        }</span>
        
        <span class="cov0" title="0">if len(nodes) &lt; count </span><span class="cov0" title="0">{
                count = len(nodes)
        }</span>
        
        // Simple random selection for demonstration
        <span class="cov0" title="0">selectedNodes := make([]*StorageNode, count)
        for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                selectedNodes[i] = nodes[rand.Intn(len(nodes))]
        }</span>
        
        <span class="cov0" title="0">return selectedNodes, nil</span>
}

func (lrs *LazyReplicationStrategy) GetReplicationOrder(sourceNode string, targetNodes []*StorageNode) []*StorageNode <span class="cov0" title="0">{
        return targetNodes
}</span>

func (lrs *LazyReplicationStrategy) ShouldReplicate(key string, metadata *ObjectMetadata, policy *ReplicationPolicy) bool <span class="cov0" title="0">{
        // Replicate based on access patterns or other criteria
        return time.Since(metadata.CreatedAt) &gt; time.Hour
}</span>

func (lrs *LazyReplicationStrategy) GetConsistencyLevel() string <span class="cov0" title="0">{
        return "eventual"
}</span>

// Selection strategy implementations

func (lbs *LoadBalancedSelection) SelectNodes(availableNodes []*StorageNode, count int, constraints map[string]interface{}) ([]*StorageNode, error) <span class="cov0" title="0">{
        if len(availableNodes) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no nodes available")
        }</span>
        
        // Sort by load factor (ascending)
        <span class="cov0" title="0">sortedNodes := make([]*StorageNode, len(availableNodes))
        copy(sortedNodes, availableNodes)
        
        sort.Slice(sortedNodes, func(i, j int) bool </span><span class="cov0" title="0">{
                return sortedNodes[i].LoadFactor &lt; sortedNodes[j].LoadFactor
        }</span>)
        
        <span class="cov0" title="0">if count &gt; len(sortedNodes) </span><span class="cov0" title="0">{
                count = len(sortedNodes)
        }</span>
        
        <span class="cov0" title="0">return sortedNodes[:count], nil</span>
}

func (gs *GeographicSelection) SelectNodes(availableNodes []*StorageNode, count int, constraints map[string]interface{}) ([]*StorageNode, error) <span class="cov0" title="0">{
        // TODO: Implement geographic selection based on regions/zones
        return availableNodes[:min(count, len(availableNodes))], nil
}</span>

func (cbs *CapacityBasedSelection) SelectNodes(availableNodes []*StorageNode, count int, constraints map[string]interface{}) ([]*StorageNode, error) <span class="cov0" title="0">{
        // Sort by available capacity (descending)
        sortedNodes := make([]*StorageNode, len(availableNodes))
        copy(sortedNodes, availableNodes)
        
        sort.Slice(sortedNodes, func(i, j int) bool </span><span class="cov0" title="0">{
                if sortedNodes[i].Capacity == nil || sortedNodes[j].Capacity == nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">return sortedNodes[i].Capacity.AvailableBytes &gt; sortedNodes[j].Capacity.AvailableBytes</span>
        })
        
        <span class="cov0" title="0">if count &gt; len(sortedNodes) </span><span class="cov0" title="0">{
                count = len(sortedNodes)
        }</span>
        
        <span class="cov0" title="0">return sortedNodes[:count], nil</span>
}

// NodeHealthChecker implementation

func (nhc *NodeHealthChecker) Start(ctx context.Context) error <span class="cov8" title="1">{
        nhc.ctx, nhc.cancel = context.WithCancel(ctx)
        
        go nhc.healthCheckRoutine()
        
        nhc.logger.Info("node health checker started")
        return nil
}</span>

func (nhc *NodeHealthChecker) Stop(ctx context.Context) error <span class="cov8" title="1">{
        if nhc.cancel != nil </span><span class="cov8" title="1">{
                nhc.cancel()
        }</span>
        
        <span class="cov8" title="1">nhc.logger.Info("node health checker stopped")
        return nil</span>
}

func (nhc *NodeHealthChecker) healthCheckRoutine() <span class="cov8" title="1">{
        ticker := time.NewTicker(nhc.interval)
        defer ticker.Stop()
        
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-nhc.ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        nhc.checkAllNodes()</span>
                }
        }
}

func (nhc *NodeHealthChecker) checkAllNodes() <span class="cov0" title="0">{
        nodes := nhc.manager.GetAllNodes()
        
        for _, node := range nodes </span><span class="cov0" title="0">{
                go nhc.checkNode(node)
        }</span>
}

func (nhc *NodeHealthChecker) checkNode(node *StorageNode) <span class="cov0" title="0">{
        start := time.Now()
        
        // TODO: Implement actual health checks
        // This would involve network calls to the node
        
        // Simulate health check
        healthy := true
        if time.Since(node.LastSeen) &gt; nhc.timeout </span><span class="cov0" title="0">{
                healthy = false
        }</span>
        
        <span class="cov0" title="0">node.mutex.Lock()
        defer node.mutex.Unlock()
        
        node.Health.LastCheck = time.Now()
        node.Health.ResponseTime = time.Since(start)
        
        if healthy </span><span class="cov0" title="0">{
                node.Health.Status = "healthy"
                node.Connected = true
                node.LastSeen = time.Now()
                node.FailureCount = 0
        }</span> else<span class="cov0" title="0"> {
                node.FailureCount++
                if node.FailureCount &gt;= nhc.manager.config.MaxFailures </span><span class="cov0" title="0">{
                        node.Health.Status = "unhealthy"
                        node.Connected = false
                }</span> else<span class="cov0" title="0"> {
                        node.Health.Status = "degraded"
                }</span>
        }
}

// Utility functions

func generateOperationID() string <span class="cov8" title="1">{
        return fmt.Sprintf("op_%d_%d", time.Now().UnixNano(), rand.Intn(10000))
}</span>

func extractNodeIDs(nodes []*StorageNode) []string <span class="cov8" title="1">{
        ids := make([]string, len(nodes))
        for i, node := range nodes </span><span class="cov8" title="1">{
                ids[i] = node.ID
        }</span>
        <span class="cov8" title="1">return ids</span>
}

func min(a, b int) int <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
